<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>数据分析 | MyBlog</title><meta name="keywords" content="Python与机器学习"><meta name="author" content="Destiny"><meta name="copyright" content="Destiny"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="数据分析"><meta name="application-name" content="数据分析"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="数据分析"><meta property="og:url" content="http://example.com/2025/09/06/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/index.html"><meta property="og:site_name" content="MyBlog"><meta property="og:description" content="数据分析通过阅读本文，您可以大致了解基于 DataFrame 数据框实现的基本数据分析方法 DataFrame用法DataFrame 可以看成是一个二维数组，既有行索引（index）又有列索引（columns），通常来讲（对于大部分数据而言），DataFrame 的每一行代表一个数据实例（一个学生，"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="http://example.com/images/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A272.jpg"><meta property="article:author" content="Destiny"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://example.com/images/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A272.jpg"><meta name="description" content="数据分析通过阅读本文，您可以大致了解基于 DataFrame 数据框实现的基本数据分析方法 DataFrame用法DataFrame 可以看成是一个二维数组，既有行索引（index）又有列索引（columns），通常来讲（对于大部分数据而言），DataFrame 的每一行代表一个数据实例（一个学生，"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="http://example.com/2025/09/06/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"/images/文章封面48.jpg"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: Destiny","link":"链接: ","source":"来源: MyBlog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'MyBlog',
  title: '数据分析',
  postAI: '',
  pageFillDescription: '数据分析, DataFrame用法, 创建 DataFrame, 获取值行索引列索引, 修改行列名称, 重置索引, 设置某一列作为索引, 行列转置, 展示样本数据, 提取某一列, 提取某一行, 提取子表格, 筛选符合条件的行, 修改或新增某一列, 修改或更新某一行, 删除某一行或某一列, axis轴线, DataFrame 的运算, 广播机制, 行列统计, descirbe方法, apply方法, apply_map方法, value_counts方法, sort_values方法, Excel数据读取, xlsx文件读取, csv文件读取, 读取结果展示, xlsx和csv相互转换, 数据保存, 数据评估与清洗, 数据评估依据, 评估丢失数据, 评估重复数据, 行列索引修改, 设置行索引, 重置行索引, 索引排序, 按列拆分, 按列合并, 宽数据转长数据, 按行拆分, 缺失值填充, 缺失值删除, 重复数据删除, 列值进行替换, 数据类型转换, 数据整理, concat拼接, merge合并, join合并, 分组聚合, 表格形状重塑, 子组合并, 层次化索引展平, query获取满足条件的行, 数据可视化, 常用图表类型, 单变量图表绘制, 双变量图表绘制, 图表颜色的配置, 散点图2数值+1分类, 散点图3数值+1分类, 图例修改, 折线图2数值+1分类, 热力图, 多张图同图展示, 多张图并列展示, 配对图, 网页数据爬虫, 基本概念, HTTP请求, 获取网页数据, ****, 数据分析通过阅读本文您可以大致了解基于数据框实现的基本数据分析方法用法可以看成是一个二维数组既有行索引又有列索引通常来讲对于大部分数据而言的每一行代表一个数据实例一个学生一个城市每一列则代表数据实例的一个特征身高体重人口创建传入一个字典利用字典进行初始化则列索引就是字典的键行索引默认从开始传入一个二维列表利用二维列表进行初始化则列索引和行索引都默认从开始如果使用现有的二维列表进行创建同时想指定列索引和列索引可以使用和参数分别进行设置行行行列列列通过上述代码则行索引和列索引都从默认的变成我们所设置的索引值需要注意这里行列索引的数目需要和二维列表的形状一一对应获取值行索引列索引通过调用方法可以分别获取的值行索引名和列索引名修改行列名称通过对和重新赋值可以对行列索引重新命名但是需要注意每次都必须给出全部行或者全部列的名称不能只修改其中几个列列列行行行如果我们只想修改其中几个行索引名或列索引名我们可以通过调用方法进行实现修改指定列名保持其他列不变旧列名新列名旧列名新列名示例将波数改为波数修改指定行索引保持其他行不变旧行名新行名旧行名新行名示例将第行索引从改为重置索引当我们对的行进行删除或增加操作以后或者修改了行索引如果我们想按照从上到下的顺序对每一行回复这样顺序递增的行索引则通过方法可以实现其中有两个比较重要的参数表示舍弃掉原本的行索引表示在当前数据框本身上做修改设置某一列作为索引通过调用想作为索引的列的列名可以实现以某一列作为索行索引而不使用默认的行索引列行列转置直接把等价看成二维矩阵使用即可实现转置展示样本数据通过调用或可以分别查看对应的的前条和后条数据通过调用可以随机返回中的行数据进行展示提取某一列通过待提取列名可以提取目标列返回的结果是一个类型的对象包括当前列每一个元素的行索引以及这个元素的元素值列我们也可以在方括号中传入一个列表列表中加入我们想提取列的列名这样即可得到一个新的行索引不变列索引变成目标列列列列提取某一行通过标签索引或者下标索引的方式可以从中提取出目标行对应的返回值是这一行的所有元素和每个元素对应的列索引行标签索引下标索引也支持通过切片的方式取一段连续的行范围但是需要注意的是使用标签索引时范围是左闭右闭包含最后一个元素使用下标索引时范围是左闭右开不包含最后一个元素行行实则为行实则为行我们也可以通过在或者中传入一个行索引列表取出我们想要的特定的几行行行提取子表格通过调用行标签列标签或者行下标列下标我们可以提取出中某行某列具体的元素行列也可以分别传入两个切片获取中的一个子表格同样需要注意的是标签切片包含最后一个元素但下标切片不包含最后一个元素行行列列此外我们还有更多灵活的子表格提取方式简单展示如下列列提取所有行以及列提取第行记忆所有列提取所有行和所有列筛选符合条件的行通过判定某一列是否满足某个条件我们可以从中筛选出满足这个判定条件的所有行值得注意的是这里我们不再通过或者进行筛选而是通过进行筛选中传入筛选条件列我们可以通过来完成复合条件的筛选修改或新增某一列通过直接对待修改增加的列名即可完成对已有列的修改或新列的生成需要注意的是如果中存在行的标签索引我们修改新增的列也需要加上对应的标签索引才能和中原有的行索引对齐否则标签无法对齐的位置会产生缺失值列行行行正确操作列对应列会全变成我们也可以用列表进行赋值此时不需要额外指明标签索引会自动按照从上到下的顺序用列表元素对每一行进行填充前提是列表长度和行数相同列修改或更新某一行对于行的修改我们只能使用而不能使用后者会直接报错同时使用需要给出列索引使用列表需要保证列表长度和列数相同行列列列行删除某一行或某一列通过调用方法实现对某一列或某一行的删除如果要删除行只需要传入待删除的行名即可如果要删除列则需要传入待删除的列名以及设置表示对列进行操作行列需要注意的是方法不会对原始的进行修改因此我们需要把修改的结果返回给一个新的如果我们想删除多行或者多列只需要把传入行名和列名的地方替换成一个列表即可行行列列轴线这里表示对操作的轴线表示以列为轴线对每一行进行操作表示以行为轴线对每一列进行操作的运算我们以两个的相加为例进行演示我们通过观察这两组加法可以发现只有当被相加的两个的行索引和列索引都能对应得上的时候对应行列所确定的位置上的元素才会进行相应的运算否则结果中会保留原始中的行和列并且对应的元素值设为通过调用方法并且设置参数我们可以把只在某一个中出现过的行或者列设成默认值也就是的值这里之所以行列对应的值还是是因为在被相加的两个中都不存在行和列这样一个格子对于这种根本就不存在于任何一个原始的中的位置即便设置了最后的结果还是其余减法乘法除法的运算类似广播机制如果把和某个常数进行四则运算那么这个四则运算会被映射到中的每一个元素上这种机制称为广播机制但前提是需要保证中的元素支持这种运算行列统计再对进行统计的时候我们需要指定是对某一列进行统计还是对某一行进行统计值得注意的是这里和中的直观感觉是相反的在删除操作中删除行时删除列时数据统计时对行统计时对列统计时在行列统计时我们会用到库中的若干聚合函数所谓聚合函数就是那些能够根据给定的若干个数据加工出一个数据的函数方法通过调用方法可以得到每一列的常见统计信息行数均值标准差等默认是对每一列进行统计如果额外设置可以对行进行统计同时该方法会自动忽略非数字信息如名字等只对数字信息进行统计方法方法用于把某个函数多为统计函数应用到的每一行或每一列实现对每一行或每一列的某种操作设想如下的场景对于每个选手我们在统计其平均分时都要去掉一个最高分和一个最低分以后再统计当前我们得到若干个选手列索引和若干个评分行索引所组成的要求我们按列进行均分统计具体实现效果如下这里是默认按列统计如果想对每一行进行统计则可以传入参数方法该方法的使用格式和方法类似只不过该方法会把传入的函数作用到的每一个元素上可以看成是广播机制的另一种实现方式只不过它可以实现更加灵活的操作对每个元素加方法该方法本质上是对的统计方法该方法会统计中每个字段出现的次数返回一个字典结构同时我们知道的每一列为一个结构因此我们对也可以按列使用该统计方法列方法该方法用于对进行排序我们可以对按列进行排序列数据读取通过库的和函数可以分别读取和格式的文件二者都会对应返回一个结构文件读取使用函数该函数用于读取文件和接受以下几个参数参数作用示例待读取表格文件的路径指定工作表第一张表列名所在行首行为列名跳过的行数跳过标题行读取的列范围到列列数据类型列名自定义缺失值标记值得注意的是我们的表格一般都是第一行为列名类型因此在读取时我们通常要跳过列名所占的一行也就是这里注意参数代表的是行数此外如果表格没有表头即第一行就是数据我们需要设置文件读取使用函数该函数用于读取结构化文本文件和通常来讲性能优于接受以下几个参数参数作用示例文件路径缓冲区分隔符默认设置某一行作为列索引设置某一列作为行索引文件编码日期解析列日期分块读取行数对于参数如果我们的文件没有表头即第行就是数据本身我们可以设置此时得到的的列索引会默认为的递增索引而如果我们不特殊指明默认会以文件中第行的内容作为列索引对于参数如果我们不进行设置则返回的的行索引默认是的递增索引假设我们想选取原文件中的某一列作为行索引我们只需要设置列名即可注意这里我们取的是列名比如列而不是列号读取结果展示如果我们待读取的表格包含非常多的列或者某一个单元格内的文字内容非常多加载出的在编辑器中无法完整展示此时我们可以调用方法是库中用于设置全局显示选项的方法它可以控制在显示数据时的各种格式和行为这个方法非常有用特别是在处理大型数据集或需要特定显示格式时设置最多显示的列数为设置显示的每一列的列宽为设置最多显示的行数为设置显示的浮点数据保留到小数点后的位数为如果想大致了解某个结构的概况我们可以考虑使用方法或者方法进行展示效果效果和相互转换使用还可以把和文件进行相互转化二者可以分别通过和函数实现用法将文件转换为输入的文件路径输出的文件路径工作表名索引默认第一个表输出编码默认转换成功已保存到示例用法用法将文件转换为输入的文件路径输出的文件路径工作表名称默认转换成功已保存到示例用法数据保存我们先前介绍的和方法不仅能够实现两种数据格式的相互转换其还可以实现中的数据以或格式进行本地保存我们以为例进行介绍待保存的路径如果保存的目标文件已经存在则会用本次保存的内容覆盖其原有的内容值得注意的是方法会默认把原始数据的列名和索引全部写入到生成的文件中这就会导致下面的问题方法会把行索引保存到文件中但是再次读取时方法并不知道那是行索引而是会将其当成表格的第一列数据进行读取因此会额外生成的默认行索引同时读取得到的中会多一列对于这个问题的解决我们可以像调用方法把列进行重新命名换成一个有意义的名字接着调用方法把这一列重新设置回行索引即可有时候我们的中行索引就是默认的的递增序列而不存在额外索引我们在保存为文件时不希望额外保存行索引可以通过设置实现此时我们重新读取时就不会出现上面的问题保存路径数据评估与清洗数据评估依据我们对一份数据的评估往往可以从格式和内容两个角度进行考量乱数据整洁数据从格式上评估脏数据干净数据从内容上评估整洁数据的三大特征数据的整洁度每列是一个变量每行是一个观察值每个单元格中只能存在一个值脏数据的四大特征数据的干净程度存在缺失数据所谓的存在重复数据信息冗余存在不一致数据不同数据值实际指代同一目标如中文数字和阿拉伯数字混用数字单位不一致全程和简写混用等存在错误数据复合规则但不准确的数据如负数的身高评估丢失数据统计缺失值个数如果我们想检查某个中每一列中缺失值的个数我们可以先调用方法该方法会返回一个与原大小形状完全相同的为的位置表示原在该位置为缺失值为的位置表示原在该位置不是缺失值接着我们对统计得到的类型的进行统计也就是按列求和是统计方法默认会按列进行统计如果想按行进行统计可以设置轴即可得到原每一列缺失值的个数此外我们也可以只对中的某一列或某几列统计缺失值我们只需要使用列名把对应列提取出来以后再调用和方法即可返回中每一列缺失值的数量列返回列中缺失值的数量实现效果提取存在缺失值的行如果我们先从中提取出某一列以列为例存在缺失值的行我们可以先对该列进行得到一个与该列形状相同的列表再用这个列表作为条件提取所有列表位置为的行即为存在缺失值的行列列对应的数组提取出所有列缺失的行实现效果评估重复数据通过调用方法我们可以找到或者中的重复数据对于而言该方法返回一个和原形状相同的如果原中某个位置的元素在它前面的位置中出现过则对应这个位置就会为反之则为而如果是对而言该方法会返回一个以的行数为长度的如果中的某一行在它前面的行中出现过这里要求在这一行之前存在与它的每一列都完全相同的一行则对应位置为反之则为效果展示有些时候我们认定某一行重复可能不需要所有列都相同比如对于上例中的学生信息而言可能姓名和性别相同时我们就认为这个学生信息是重复的此时我们可以在中传入姓名性别也就是传入一个列表列表中传入待比较的列即可姓名性别效果展示最后我们可以仿照上面的行提取思路提取所有存在特定列重复的行姓名性别行列索引修改单个修改通过方法可以修改的行索引或列索引如果想修改行索引则传入参数如果想修改列索引则传入参数传入的参数都是第一个字典字典中的键是待修改的老索引值是想修改成的新索引旧行索引新行索引旧行索引新行索引旧列索引新列索引旧列索引新列索引用法示例对列名的修改同理只是传入的是参数此外方法会返回修改后的新的如果想对原本的进行修改我们可以通过设置实现批量修改也支持向中的和参数传入一个函数这个函数会作用到的每一个行索引或者列索引上实现对行列索引的批量修改把列名一致变成大写实现效果设置行索引通过调用列名可以把某一列的内容设置为新的行索引我们传入待设为行索引的那一列的列名即可列重置行索引通过调用可以实现把行索引重新设置为这种顺序排列的情况至于原本作为行索引的列是否保留我们可以通过设置参数实现人为设置为则选择舍弃默认设置为则为保留索引排序通过调用可以实现对行或列索引的排序默认参数表示对行索引排序如果人为设置则表示对列索引排序默认时沿着索引纵向操作设置时沿着索引横向操作按列拆分假设对于下面的模型我们希望把人口密度这一列按照的分隔拆分成人口数量和占地面积这两部分通过调用待拆分的列待使用的分隔字符可以实现对的某一列按照某个分隔符进行拆分的效果拆分的结果会以一个列表的形式返回但是这样拆分拆分后的两列以列表的形式给出我们通过设置这个参数表示拆分结果以的形式返回即可接着我们需要把新得到的两列加入到原始的中这里可以通过列名列名的形式把待加入的新列逐个加入人口面积人口密度实现效果最后我们只需要删除中原有的人口密度这一列即可可以通过待删除列名实现对这一列的删除按列合并假设对于下面的模型我们想把原始中姓这一列和名这一列进行合并通过调用列列方法即可实现把和列名对应的两列内容的拼接此外我们可以通过或设置参数指定拼接时的分隔符比如在上例中我们如果指定就会得到张三李四王五这样的拼接结果之后我们只需要把拼接得到的新列进行添加原始列进行删除即可姓名姓名姓名宽数据转长数据所谓的宽数据转长数据即为把一部分列名的值转换为变量的值比如对于下面的例子来说我们设置年龄组为新的一列把列名中男性和女性的各个年龄组都作为这一列中的变量通过调用即可实现宽数据向长数据的转化该方法接受四个参数待转化的要保留的列的列名构成的列表其余的列名都会作为新列的变量新生成列的列名被转化为变量的那些列名在原中对应的值所构成的新列的列名国家代码年份年龄组肺结核病例数按行拆分假设对于下面的例子我们先把每个学生所在的行按照它所选修的课程进行再次拆分可以通过调用待拆分列名传入待拆分的列名即可把该列中的每个元素拆分成为单独的一行课程列表缺失值填充通过调用方法可以实现对中缺失值的填充我们既可以实现对整个缺失值的统一填充也可以只针对其中某些列分别进行填充还支持传入一个字典分别指出每一列的填充值全局用填充列列只对列用这一列的平均值填充列列列对每一列用不同值填充缺失值删除如果有时候缺失的不是关键信息或者缺失的信息难以补全补全的价值也不大我们可以考虑使用方法直接把信息缺失的行进行删除如果单纯调用方法而不传入任何参数该方法会删除原中所有有缺失信息的行对于某一行而言只要存在一列信息是缺失的这一行就会被删除而实际上对于上面的例子而言如果我们想统计员工的工资问题那么年龄值的缺失其实并不总要所以我们只需要删除工资值有缺失的行即可可以通过对中传入参数列表中放上想要判定的列只有这些列存在缺失的行才会被删除其余列缺失的行会被保留工资我们可以通过指定来全局删除有缺失值的列重复数据删除通过调用方法我们可以删除掉中重复的行具体判定结果为对于当前的一行如果有和它完全相同每一列内容都相同的行在它之前出现过我们就把这一行删除反之这一行就保留实现效果和缺失值删除同理如果我们希望在部分列重复的时候比如上例中的姓名和性别就可以删除这些行而不是比较这一行的所有列此时也可以通过传入参数列表中写待比较的列名即可姓名性别一般而言如果两行或多行出现重复时会保留第一行而删除后面的行我们也可以设置来保留最后一行列值进行替换假设我们想对中某一列的值进行整体替换可以使用实现替换功能该方法的常见用法如下把学校这一列的全替换为学校把中所有的替换为把学校这一列的全替换为学校传入字典完成多组替换数据类型转换通过待转换的类型可以实现对中数据类型的强制转换对于而言我们可以对其按列进行这样的转换操作值得注意的是中的字符串类型也被表示成为类型二者是等价的中还有一类特殊的数据类型称为分类数据用进行表示对于而言数据可以被划分为两种类型分类数据取值范围有限比如性别国家省份一个公司中的部门数值数据取值范围无限比如身高体重对于类别有限的数据我们推荐将其转化为类型既可以节省内存空间也可以在后续可视化时提供便捷注意转换时需要加引号这是因为它不是本身的数据类型等而是中提供的一种数据类型不加引号无法识别数据整理拼接假设我们现在有两个相同类型的分别为和我们希望把二者从上到下拼接为一个完整的可以通过调用实现该方法接受一个列表列表中放入待拼接的即可如果和的列名是完全相同的在拼接时函数会自动对列进行对齐其中参数设置为时会忽略掉原有的行索引对拼接后整体的整体从进行行索引顺序排序如果待拼接的之间存在不相同的列比如有列而没有有列而没有拼接时新的列会在所有列之间取并集不存在的数据就会对应生成值列列列列运行结果如下我们也可以把沿着行方向进行横向拼接只需要在调用方法的时候设置即可不过不常用合并具体的合并实现假设我们有如下的两个这两个中存在某一列是相同的列名相同我们想基于这一列把两个进行合并可以通过该方法接受以下几个参数待合并的之一待合并的之一合并时根据哪一列进行合并合并所依据的列名此外参数中也可以传入一个列表表示依据多个列进行合并只有某一行对应的这些列值在两个中都出现时这一行在新的中才得以保留参考列参考列如果某个变量在和中都有出现但是二者所对应的列名不同比如订单日期和交易日期表述不同但含义相同此时我们仍然想依据这些列进行合并我们可以分别设置和参数分别指定和在合并时参考的列的参考列的参考列能这么合并的关键在于和的参考列的长度意义都相同对应也有重合的变量只是列名的表述形式不同在合并时如果除了我们所指定的用于作为合并参考的列两个中还有其他的重名列那么合并以后这两个重名列都会被保留会默认加上和的后缀如果我们想自定义后缀则可以设置参数进行修改合并后列数的确定对于合并后新的列数的确定实际上是通过合并时的参数进行确定的这个参数的值可以为如果不指定则默认为我们以下面这张表为例解释四个参数的含义假设我们要按照二者彩色的列进行合并只保留左右表都有匹配的列值相当于左右表的列值取交集保留左右表中的所有列值相当于左右表的列值取并集如果不存在则设为保留左边表中的所有列值右边表的每一个列值根据左边表去匹配相当于如果匹配不上则设为保留右边表中的所有列值左边表的每一个列值根据右边表去匹配相当于如果匹配不上则设为合并也可以用于的合并只不过它是基于索引去进行合并注意它是一个内置在中的方法需要用一个实例调用才能实现其接受以下几个参数拼接方式有重名列时左边列的后缀有重名列时右边列的后缀因为方法是按照索引拼接因此如果当待拼接的两个数据框有重名列的时候必须指定左右重名列在新中的后缀否则会发生列名冗余错误分组聚合如果我们想对某个进行分组比如对一家超市的三家分店分别进行研究可以通过调用方法实现相关的功能分店名称我们传入作为分类变量的列名该方法就会这一列中所有列值相同的行划分到一起组成一个新的返回该方法返回的是一个的实例这里我们聚合之后并不能直观的得到分组后的各个我们通常会直接对分组后得到的实例取某一列或者某几列然后接着调用一个聚合方法返回某一列或者某几列的聚合值这里我们只是做逻辑上的演示实际运行中分组得到的实例和取其中某几列的结果都是不可见的而最后聚合得到的结果是单个值还是一个则取决于我们是对单列统计还是对多列统计统计单列的结果待分组的列名待统计的列名聚合方法统计多列的结果待分组的列名待统计的列名待统计的列名待统计的列名聚合方法此外我们在分组时也可以传入多个列名组成的列表即可进行多重分组列列对于我们所使用的聚合方法这里我们不一定要调用现有的聚合函数也可以通过方法传入一个我们自定义的聚合函数表格形状重塑对于一个假设我们想改变它的结构其已有的列中进行选择指定某些列作为行索引某些列作为列名指定某些列作为值并且进行聚合得到一个新的结构的这一过程就称为表格形状的重塑可以通过调用实现也就是中类似透视表的功能该函数接受以下几个参数原始的作为行索引的原列作为列名的原列作为求值的原列选择聚合函数应用实例对于下面这张表格我们用分别做不同的处理处理要求把分店编号和时间段作为索引商品类别作为列计算销售额的总和分店编号时间段商品类别销售额实现效果处理要求把商品类别作为索引分店编号作为列计算销售额的平均值商品类别分店编号销售额实现效果子组合并上面我们已经可以通过方法进行分组划分假设我们以年龄为例进行划分那么每个年龄值都会被划分为一组这样就会导致分组过多假设我们想以每个年龄段年龄的范围区间作为一组即可通过方法对聚合后的结果进行进一步处理达到组数压缩的效果该方法接受以下几个参数用于分组的边界数组每个分组的命名所组成的数组长度为的长度假设我们要对年龄进行分组把年龄分成这些年龄段每个年龄段对应的标签少年青年壮年中年中老年老年年龄这段代码会输出原中年龄一列中每个年龄值所对应的年龄段标签这些标签整体组成一个类型为也就是分类变量类型有了每个年龄值对应的年龄标签以后我们就可以根据这个年龄标签对原进行分组聚合年龄段年龄年龄组工资层次化索引展平在使用分组时如果使用了不止一个的索引变量则会得到层次化索引针对层次化索引我们仍然可以通过多次调用方法逐层提取出我们想要的目标元素只提取分店编号同时提取分店编号和时间段如果我们需要把层次化索引展平成原本的一维行索引则可以通过调用方法把行索引进行展平此时原本的层次化索引会重新变回列值获取满足条件的行通过方法和在中传入条件表达式都可以获取满足条件的的行只是前者书写起来更加美观得体性别男年龄值得注意的是中传入的本身是一个字符串这个字符串中再调用列名的时候不需要使用引号进行包裹此外该字符串内部的其他字符串需要用与外层字符串不同的引号进行包裹数据可视化常用图表类型根据我们提供的原始数据不同我们可以绘制不同类型的图表两个数值变量散点图折线图一个分类变量一个数值变量条形图饼图散点图展示两个数值变量之间的相关性折线图展示连续间隔或时间跨度上数值的变化从而反应趋势变化条形图展示各个分类变量所对应的数值变量饼图展示各个分类对应的数值之间的比例给散点图引入更多变量如果要引入新的分类变量我们可以使用不同颜色的散点绘图如果要引入新的数值变量我们可以绘制气泡图改变点的大小越大的点表示此处对应的数值越大给折线图引入更多变量如果要引入新的分类变量我们可以用不同颜色绘制多条折线给条形图引入更多变量如果要引入新的分类变量我们可以绘制复式条形图也就是用不同颜色绘制条形图中的条柱我们通常使用和这两个库进行数据的可视化其中前者是基于后者实现的单变量图表绘制我们通过调用绘制对应的图表该函数有两种参数接受形式直接传入一个传入一个同时指定参数为具体要绘制的某一列通过调用可以把绘制好的图表进行展示直方图的绘制中待绘图的列密度图的绘制中待绘制的列箱型图的绘制中待绘制的列小提琴图的绘制中待绘制的列设置图表标题与标签通过调用图表标题即可完成对图表标题的设置通过调用轴标签即可完成对轴标签的设置通过调用轴标签即可完成对轴标签的设置企鹅样本的嘴长度分布嘴长度单位样本数量双变量图表绘制散点图的绘制如果图表的自变量和因变量来自于同一个可以用第一种形式实现如果来自不同的可以用第二种形式实现中作为图表自变量的列中作为图表因变量的列中作为图表自变量的列中作为图表因变量的列折线图的绘制中作为图表自变量的列中作为图表因变量的列条形图的绘制条形图和直方图在形状相近但是二者有明显区别条形图的横轴表示的是不同的分类纵轴表示的是每个分类对应的数值而直方图的横轴表示的是一维数据的整体数据范围纵轴表示的是每个数据数值范围出现的个数作为横坐标的列作为纵坐标的列对于条形图而言默认情况下条柱的高度对应所属分类下的对应所有值的平均值如果我们想展示其他聚合值可以设置参数将其赋值为库中其他常见的聚合函数如等列列使用实例比如对于这份数据而言我们如果要绘制条形图横轴显然以企鹅种类为分类变量纵轴则可以从嘴长度嘴深度鳍长度体重这四列重进行选择计数图绘制计数图和条形图的形状类似只不过计数图的纵轴表示的是每个分类中元素的个数因此我们只需要传入横轴指定作为分类变量的列即可作为分类变量的列饼图的绘制并不支持饼图的绘制因此我们需要调用进行绘制待绘制的列如果我们在参数中只传入一个要绘制成饼图的或者是的一列我们得到的饼图中是没有任何图标的以下是对饼图的可视化要指定每一部分的标签我们可以设置待作为标签的列来实现要显示每一部分的比例我们可以设置其中字符串表示以百分制形式展示且显示小数点后两位图表颜色的配置对于折线图或散点图这种只有单一颜色的图表我们可以通过给中传入参数进行设置其中参数的值可以是表示颜色的字符串等也可以是表示颜色的进制数码对于条形图或饼图这种有多重颜色的图表我们可以通过调整其色盘来实现颜色主题配置色盘的配置可以通过系统设置函数实现常见的色盘种类如清新山色等散点图数值分类通过引入颜色代表不同的分类变量我们可以通过设置参数色调的值引入不同的分类变量在展示时即可针对不同分类按不同颜色的散点输出作为横轴的列作为纵轴的列作为分类变量的列鸢尾花数据加按鸢尾花种类分类我们通常把参数设置为分类变量但是也可以将其设置为数值类型的变量此时会按照不同的数值输出不同颜色的散点如鸢尾花数据集按花瓣长度分类散点图数值分类如果要在二维图像上分别额外支持一个分类变量和一个数值变量我们不仅需要用参数通过颜色来表示分类变量还需要设置参数通过点的大小来表示数值变量我们把参数赋值为一个数值变量即可作为横轴的列作为纵轴的列作为分类变量的列作为数值变量的列鸢尾花数据加按鸢尾花种类和花瓣长度分别分类图例修改在上面的示意图中图例的位置挡住了图像本身我们需要调整图例的位置可以通过中设置实现我们传入一个元组其中和取或表示图例在图像左侧表示图例在图像右侧表示图例和图像偏下对齐表示图例和图像偏上对齐对下图而言我们想把图例放在右上角则可以传入元组折线图数值分类和散点图处理完全相同设置参数为目标分类变量即可热力图热力图天然就支持表示两个分类变量和一个数值变量其中横轴和纵轴分别表示分类变量数值变量由每个位置格点的颜色来表示热力图绘制中的分类变量中的分类变量实现如下如果我们希望得到更加直观的展示即每个位置显示具体的数值可以通过设置参数实现作为横轴的分类变量作为纵轴的分类变量多张图同图展示如果想在一张图表中绘制多张图像可以通过多次调用绘制图像最后在统一调用即可我们以同时展示鸢尾花数据集三个不同种类所对应的花瓣长度的直方图为例进行展示多张图同时展示的两个参数通过设置每张图的参数统一我们可以使得三张直方图显示在同一张图表中时条柱的宽度相同使得结果更加统一美观通过设置每张图的参数我们可以为图表加上图例指明每张图所描述的内容我们想展示图例和有关的内容时除了常规的之外还需要调用进行图例展示如果我们想把直方图转化为密度图进行展示也是同理的只是密度图不再需要参数的设置如果我们想在同一张图中展示多张箱型图或者小提琴图最好把横轴设置为分类变量这样得到的图表美观清晰待展示的列分类变量列待展示的列分类变量列多张图并列展示如果想把多张独立的图并列展示我们需要调用绘制子图的方法先进行子图空间绘制再进行填充该函数接受两个参数分别表示子图的行数和列数也就是说当前空间中会填入行每行有张子图如果我们想额外设置每个子图的宽和高可以通过设置实现该参数接受一个元组分别表示子图的宽度和高度该函数返回两个值分别为和其中表示大图整体表示大图中的每一张子图我们常用到的返回值是该变量是一个类型的数组其具体形状取决于传入的参数和如果则为一个一维数组如果则为一个二维数组我们通过数组的索引方式即可得到对应的每一张子图如果我们想把某张图像填入子图中在绘制目标图像时设置其参数为对应的元素即可展示如下配对图通过调用传入某个该方法会把中所有数值变量两两之间的关系都进行绘制假设中有个数值类型的变量则会得到张图作为输出结果该方法支持以下参数支持以某个分类变量进行分类展示非对角线图类型可以绘制直方图散点图核密度图等默认为散点图对角线图类型可选参数同上默认为直方图其中对角线图描述的是单个变量的分布情况即某个变量和它分布位置之间的关系而非对角线图描述的是两个不同变量之间的关系网页数据爬虫基本概念网页数据爬虫的基本步骤获取网页内容通过代码给网站服务器发送请求返回网页上的内容解析网页内容提取目标数据储存或分析数据请求又称为超文本传输协议是一种客户端和服务器之间的请求响应协议常见的请求分为和两种其中方法用于获得数据方法用于创建数据一个完整的请求由请求行请求头请求体三部分所组成而响应由状态行响应头响应体三部分所组成需要注意的是状态码如果返回开头表示请求成功返回开头表示需要重定向返回开头表示客户端发生错误比如返回开头表示服务器发生错误获取网页数据我们一般使用模块进行网页数据的获取在使用时需要执行进行模块导入在网页数据获取时我们可以调用方法传入一个代表网站地址的字符串即可获得请求响应的实例该方法会返回一个类型的实例这里我们使用的网站是一个专门用于爬虫数据训练的网站此时响应体中就会存储我们想要的网页数据通过输出参数我们可以判断网页请求是否得到正确响应如果值为则说明正确响应此外我们也可以通过是否为进行判断有时候一些网站只希望服务于正常的浏览器同时忽略所有爬虫程序的请求此时我们请求返回的状态码为对于这种情况我们可以通过设置请求头中的用户请求表伪装正常的浏览器来避免此问题对于的设置我们只关心其格式而不关心其具体内容因此我们可以从浏览器上任意获取一个码这里以浏览器为例进行演示进入任意一个网页右键选择检查进入到网页源码选择网络一栏找到请求标头找到一栏复制其内容即可这里给出一个可用的有了这个我们就可以自定义一个请求头并且把它传入到的参数中即可把我们的程序伪装成一个正常的浏览器使得它能够正常访问网页下面我们以豆瓣电影网页的访问为例进行演示此时我们通过调用即可获得网页的源码补充内容函数该函数来自库调用时需要先引入用于在一维信号中寻找局部最大值也就是所谓的峰值该函数通常接受以下几个参数参数类型作用示例光谱分析场景输入信号反射率数据反射率峰值最小高度忽略反射率的峰相邻峰最小间隔避免密集峰峰的最小突出度过滤噪声峰峰的最小宽度忽略窄峰计算突出度的窗口长度局部窗口波数范围该函数有两个返回值分别为其中存储函数找到的每个波峰在原数组中的索引即下标索引数组为一个字典当上文中制定了对应的参数时字典中会包含参数关键字键和每个波峰对应该参数值所构成的列表值对应的键值对函数该函数用于求一个数组相邻两个元素的差值也就是差分函数比如某数组为则得到的差分数组为函数该函数用于把数据框的当前列转化为数值类型其中表示遇到无法转换的值时设为而不是报错',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-09-09 19:56:52',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.4/img/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">MyBlog</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)" rel="external nofollow noreferrer">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><span> 分类</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/tags/"><span> 标签</span></a></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/LLM%E4%B8%8E%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/" style="font-size: 1.05rem;">LLM与强化学习<sup>1</sup></a><a href="/tags/Python%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="font-size: 1.05rem;">Python与机器学习<sup>35</sup></a><a href="/tags/editing/" style="font-size: 1.05rem;">editing<sup>1</sup></a><a href="/tags/%E4%B8%93%E4%B8%9A%E8%AF%BE/" style="font-size: 1.05rem;">专业课<sup>14</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 1.05rem;">算法<sup>29</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/10/"><span class="card-archive-list-date">十月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">10</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/09/"><span class="card-archive-list-date">九月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">21</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/08/"><span class="card-archive-list-date">八月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">30</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/07/"><span class="card-archive-list-date">七月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">24</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);" rel="external nofollow noreferrer"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/Python%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" itemprop="url">Python与机器学习</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/Python%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>Python与机器学习</span></a></span></div></div><h1 class="post-title" itemprop="name headline">数据分析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2025-09-06T08:17:15.000Z" title="发表于 2025-09-06 16:17:15">2025-09-06</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2025-09-09T11:56:52.853Z" title="更新于 2025-09-09 19:56:52">2025-09-09</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为香波地群岛"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>香波地群岛</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="/../images/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A272.jpg"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://example.com/2025/09/06/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"><header><a class="post-meta-categories" href="/categories/Python%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" itemprop="url">Python与机器学习</a><a href="/tags/Python%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" tabindex="-1" itemprop="url">Python与机器学习</a><h1 id="CrawlerTitle" itemprop="name headline">数据分析</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">Destiny</span><time itemprop="dateCreated datePublished" datetime="2025-09-06T08:17:15.000Z" title="发表于 2025-09-06 16:17:15">2025-09-06</time><time itemprop="dateCreated datePublished" datetime="2025-09-09T11:56:52.853Z" title="更新于 2025-09-09 19:56:52">2025-09-09</time></header><h1 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a><strong>数据分析</strong></h1><p>通过阅读本文，您可以大致了解基于 DataFrame 数据框实现的基本数据分析方法</p>
<h2 id="DataFrame用法"><a href="#DataFrame用法" class="headerlink" title="DataFrame用法"></a><strong>DataFrame用法</strong></h2><p>DataFrame 可以看成是一个二维数组，既有行索引（index）又有列索引（columns），通常来讲（对于大部分数据而言），DataFrame 的每一行代表一个数据实例（一个学生，一个城市…），每一列则代表数据实例的一个特征（身高，体重，人口…）</p>
<h3 id="创建-DataFrame"><a href="#创建-DataFrame" class="headerlink" title="创建 DataFrame"></a><strong>创建 DataFrame</strong></h3><p>（1）传入一个字典，利用字典进行初始化，则列索引就是字典的<strong>键</strong>，行索引默认从 0 开始</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">&quot;A&quot;</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],<span class="string">&quot;B&quot;</span>:[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],<span class="string">&quot;C&quot;</span>:[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]&#125;)</span><br></pre></td></tr></table></figure>

<p>（2）传入一个二维列表，利用二维列表进行初始化，则列索引和行索引都默认从 0 开始</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> ps</span><br><span class="line">df = pd.DataFrame([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]])</span><br></pre></td></tr></table></figure>

<p>如果使用现有的二维列表进行创建，同时想指定列索引和列索引，可以使用<code>index</code>和<code>colums</code>参数分别进行设置</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">a = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]]</span><br><span class="line">df = np.DataFrame(a, index=[<span class="string">&quot;行0&quot;</span>, <span class="string">&quot;行1&quot;</span>, <span class="string">&quot;行2&quot;</span>], columns=[<span class="string">&quot;列0&quot;</span>, <span class="string">&quot;列1&quot;</span>, <span class="string">&quot;列2&quot;</span>])</span><br></pre></td></tr></table></figure>

<p>通过上述代码，则行索引和列索引都从默认的 0 1 2 … 变成我们所设置的索引值，需要注意这里行列索引的数目需要和二维列表 a 的形状一一对应</p>
<h3 id="获取值，行索引，列索引"><a href="#获取值，行索引，列索引" class="headerlink" title="获取值，行索引，列索引"></a><strong>获取值，行索引，列索引</strong></h3><p>通过调用<code>values</code>，<code>index</code>，<code>columns</code>方法可以分别获取 DataFrame 的值，行索引名和列索引名</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df.values</span><br><span class="line">df.index</span><br><span class="line">df.columns</span><br></pre></td></tr></table></figure>

<h3 id="修改行列名称"><a href="#修改行列名称" class="headerlink" title="修改行列名称"></a><strong>修改行列名称</strong></h3><p>通过对<code>colunms</code>和<code>index</code>重新赋值，可以对行列索引重新命名，但是需要注意，每次都必须给出全部行或者全部列的名称，不能只修改其中几个</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.columns = [<span class="string">&quot;列0&quot;</span>, <span class="string">&quot;列1&quot;</span>, <span class="string">&quot;列2&quot;</span>]</span><br><span class="line">df.index = [<span class="string">&quot;行0&quot;</span>, <span class="string">&quot;行1&quot;</span>, <span class="string">&quot;行2&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>如果我们只想修改<strong>其中几个</strong>行索引名或列索引名，我们可以通过调用<code>rename</code>方法进行实现</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改指定列名（保持其他列不变）</span></span><br><span class="line">df = df.rename(columns=&#123;<span class="string">&#x27;旧列名1&#x27;</span>: <span class="string">&#x27;新列名1&#x27;</span>, <span class="string">&#x27;旧列名2&#x27;</span>: <span class="string">&#x27;新列名2&#x27;</span>&#125;)</span><br><span class="line"><span class="comment"># 示例：将&quot;波数&quot;改为&quot;Wavenumber&quot;</span></span><br><span class="line">df = df.rename(columns=&#123;<span class="string">&#x27;波数&#x27;</span>: <span class="string">&#x27;Wavenumber&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改指定行索引（保持其他行不变）</span></span><br><span class="line">df = df.rename(index=&#123;<span class="string">&#x27;旧行名1&#x27;</span>: <span class="string">&#x27;新行名1&#x27;</span>, <span class="string">&#x27;旧行名2&#x27;</span>: <span class="string">&#x27;新行名2&#x27;</span>&#125;)</span><br><span class="line"><span class="comment"># 示例：将第0行索引从0改为&#x27;Sample1&#x27;</span></span><br><span class="line">df = df.rename(index=&#123;<span class="number">0</span>: <span class="string">&#x27;Sample1&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="重置索引"><a href="#重置索引" class="headerlink" title="重置索引"></a><strong>重置索引</strong></h3><p>当我们对 DataFrame 的行进行删除或增加操作以后，或者修改了行索引，如果我们想按照从上到下的顺序对每一行回复 0 1 2 … 这样顺序递增的行索引，则通过<code>reset_index</code>方法可以实现</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.reset_index()</span><br></pre></td></tr></table></figure>

<p>其中有两个比较重要的参数，<code>drop=True</code>表示舍弃掉原本的行索引，<code>inplace=True</code>表示在当前数据框本身上做修改</p>
<h3 id="设置某一列作为索引"><a href="#设置某一列作为索引" class="headerlink" title="设置某一列作为索引"></a><strong>设置某一列作为索引</strong></h3><p>通过调用<code>set_index(想作为索引的列的列名)</code>可以实现以某一列作为索行索引而不使用默认的行索引</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.set_index(<span class="string">&quot;列0&quot;</span>) </span><br></pre></td></tr></table></figure>

<h3 id="行列转置"><a href="#行列转置" class="headerlink" title="行列转置"></a><strong>行列转置</strong></h3><p>直接把 DataFrame 等价看成二维矩阵，使用<code>T</code>即可实现转置</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.T</span><br></pre></td></tr></table></figure>

<h3 id="展示样本数据"><a href="#展示样本数据" class="headerlink" title="展示样本数据"></a><strong>展示样本数据</strong></h3><p>通过调用<code>head(N)</code>或<code>tail(N)</code>可以分别查看对应的 DataFrame 的前 N 条和后 N 条数据</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.head(<span class="number">5</span>)</span><br><span class="line">df.tail(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p>通过调用<code>sample(N)</code>可以随机返回 DataFrame 中的 N 行数据进行展示</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.sample(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<h3 id="提取某一列"><a href="#提取某一列" class="headerlink" title="提取某一列"></a><strong>提取某一列</strong></h3><p>通过<code>df[待提取列名]</code>可以提取目标列，返回的结果是一个 series 类型的对象，包括当前列每一个元素的<strong>行索引</strong>以及这个元素的<strong>元素值</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">&#x27;列1&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>我们也可以在方括号中传入一个列表，列表中加入我们想提取列的列名，这样即可得到一个新的 Dataframe，行索引不变，列索引变成目标列</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[[<span class="string">&#x27;列0&#x27;</span>, <span class="string">&#x27;列1&#x27;</span>, <span class="string">&#x27;列2&#x27;</span>]]</span><br></pre></td></tr></table></figure>

<h3 id="提取某一行"><a href="#提取某一行" class="headerlink" title="提取某一行"></a><strong>提取某一行</strong></h3><p>通过<code>loc[标签索引]</code>或者<code>iloc[下标索引]</code>的方式，可以从 DataFrame 中提取出目标行，对应的返回值是这一行的所有元素，和每个元素对应的列索引</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.loc[<span class="string">&#x27;行0&#x27;</span>] <span class="comment"># 标签索引</span></span><br><span class="line">df.iloc[<span class="number">0</span>] <span class="comment"># 下标索引</span></span><br></pre></td></tr></table></figure>

<p>DataFrame 也支持通过切片的方式，取一段连续的行范围，但是需要<strong>注意</strong>的是，使用<code>loc[::]</code>标签索引时，范围是<strong>左闭右闭</strong>，包含最后一个元素，使用<code>iloc[::]</code>下标索引时，范围是左闭右开，不包含最后一个元素</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.loc[<span class="string">&#x27;行0&#x27;</span>:<span class="string">&#x27;行2&#x27;</span>] <span class="comment"># 实则为行0,1,2</span></span><br><span class="line">df.iloc[<span class="number">0</span>:<span class="number">3</span>] <span class="comment"># 实则为行0,1,2</span></span><br></pre></td></tr></table></figure>

<p>我们也可以通过在<code>loc[]</code>或者<code>iloc[]</code>中传入一个行索引列表，取出我们想要的特定的几行</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.loc[[<span class="string">&#x27;行0&#x27;</span>,<span class="string">&#x27;行2&#x27;</span>]]</span><br></pre></td></tr></table></figure>

<h3 id="提取子表格"><a href="#提取子表格" class="headerlink" title="提取子表格"></a><strong>提取子表格</strong></h3><p>通过调用<code>loc[行标签,列标签]</code>或者<code>iloc[行下标,列下标]</code>，我们可以提取出 DataFrame 中某行某列具体的元素</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.loc[<span class="string">&#x27;行0&#x27;</span>,<span class="string">&#x27;列1&#x27;</span>]</span><br><span class="line">df.iloc[<span class="number">0</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>也可以分别传入两个切片，获取 DataFrame 中的一个子表格，同样需要<strong>注意</strong>的是，标签切片包含最后一个元素，但下标切片不包含最后一个元素</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.loc[<span class="string">&#x27;行0&#x27;</span>:<span class="string">&#x27;行1&#x27;</span>, <span class="string">&#x27;列0&#x27;</span>:<span class="string">&#x27;列1&#x27;</span>]</span><br><span class="line">df.iloc[<span class="number">0</span>:<span class="number">2</span>, <span class="number">0</span>:<span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<p>此外我们还有更多灵活的子表格提取方式，简单展示如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df.loc[:, <span class="string">&#x27;列0&#x27;</span>, <span class="string">&#x27;列1&#x27;</span>] <span class="comment"># 提取所有行，以及0-1列</span></span><br><span class="line">df.loc[[<span class="number">1</span>, <span class="number">2</span>], ] <span class="comment"># 提取第1,2行，记忆所有列</span></span><br><span class="line">df.loc[:, :] <span class="comment"># 提取所有行和所有列</span></span><br></pre></td></tr></table></figure>

<h3 id="筛选符合条件的行"><a href="#筛选符合条件的行" class="headerlink" title="筛选符合条件的行"></a><strong>筛选符合条件的行</strong></h3><p>通过判定某一列是否满足某个条件，我们可以从 DataFrame 中筛选出满足这个判定条件的所有行，值得<strong>注意</strong>的是，这里我们不再通过<code>iloc()</code>或者<code>loc()</code>进行筛选，而是通过<code>[]</code>进行筛选，<code>[]</code>中传入筛选条件</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[df[<span class="string">&#x27;列0&#x27;</span>]&gt;<span class="number">10</span>]</span><br></pre></td></tr></table></figure>

<p>我们可以通过 and（&amp;），or（|），not（~）来完成复合条件的筛选</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[(df[<span class="string">&#x27;grade&#x27;</span>]&gt;<span class="number">80</span>) &amp; (df[<span class="string">&#x27;class&#x27;</span>]=<span class="string">&#x27;Three&#x27;</span>)]</span><br></pre></td></tr></table></figure>

<h3 id="修改或新增某一列"><a href="#修改或新增某一列" class="headerlink" title="修改或新增某一列"></a><strong>修改或新增某一列</strong></h3><p>通过直接对<code>df[&#39;待修改/增加的列名&#39;] = series</code>即可完成对已有列的修改或新列的生成，需要注意的是，如果 DataFrame 中存在行的标签索引，我们修改 &#x2F; 新增的列也需要加上对应的标签索引，才能和 DataFrame 中原有的行索引对齐，否则标签无法对齐的位置会产生缺失值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">&#x27;列0&#x27;</span>] = pd.Series([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], index=[<span class="string">&#x27;行0&#x27;</span>, <span class="string">&#x27;行1&#x27;</span>, <span class="string">&#x27;行2&#x27;</span>]) <span class="comment"># 正确操作</span></span><br><span class="line">df[<span class="string">&#x27;列0&#x27;</span>] = pd.Series([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) <span class="comment"># 对应列会全变成 NaN</span></span><br></pre></td></tr></table></figure>

<p>我们也可以用列表进行赋值，此时不需要额外指明标签索引，会自动按照从上到下的顺序用列表元素对每一行进行填充，前提是列表长度和 DataFrame 行数相同</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">&#x27;列0&#x27;</span>] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<h3 id="修改或更新某一行"><a href="#修改或更新某一行" class="headerlink" title="修改或更新某一行"></a><strong>修改或更新某一行</strong></h3><p>对于行的修改，我们只能使用<code>loc</code>，而不能使用<code>iloc</code>，后者会直接报错，同时使用 Series 需要给出列索引，使用列表需要保证列表长度和列数相同</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.loc[<span class="string">&#x27;行0&#x27;</span>] = pd.Series([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], index=[<span class="string">&#x27;列0&#x27;</span>, <span class="string">&#x27;列1&#x27;</span>, <span class="string">&#x27;列2&#x27;</span>])</span><br><span class="line">df.loc[<span class="string">&#x27;行0&#x27;</span>] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<h3 id="删除某一行或某一列"><a href="#删除某一行或某一列" class="headerlink" title="删除某一行或某一列"></a><strong>删除某一行或某一列</strong></h3><p>通过调用<code>drop()</code>方法实现对某一列或某一行的删除，如果要删除行，只需要传入待删除的行名即可，如果要删除列，则需要传入待删除的列名以及设置<code>axis=1</code>表示<strong>对列</strong>进行操作</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df1 = df.drop(<span class="string">&#x27;行0&#x27;</span>)</span><br><span class="line">df2 = df.drop(<span class="string">&#x27;列0&#x27;</span>, axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>需要注意的是，<code>drop()</code>方法不会对原始的 DataFrame 进行修改，因此我们需要把修改的结果返回给一个新的 DataFrame</p>
<p>如果我们想删除多行或者多列，只需要把传入行名和列名的地方替换成一个列表即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df1 = df.drop([<span class="string">&#x27;行0&#x27;</span>,<span class="string">&#x27;行1&#x27;</span>])</span><br><span class="line">df2 = df.drop([<span class="string">&#x27;列0&#x27;</span>, <span class="string">&#x27;列1&#x27;</span>], axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h3 id="axis轴线"><a href="#axis轴线" class="headerlink" title="axis轴线"></a><strong>axis轴线</strong></h3><p>这里 axis 表示对 DataFrame 操作的轴线，axis &#x3D; 1 表示以列为轴线，对每一行进行操作，aixs &#x3D; 0 表示以行为轴线，对每一列进行操作</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/image-20250907002828090.png" alt="image-20250907002828090"></p>
<h3 id="DataFrame-的运算"><a href="#DataFrame-的运算" class="headerlink" title="DataFrame 的运算"></a><strong>DataFrame 的运算</strong></h3><p>我们以两个 DataFrame 的相加为例进行演示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/image-20250907003141599.png" alt="image-20250907003141599"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/image-20250907003210719.png" alt="image-20250907003210719"></p>
<p>我们通过观察这两组加法可以发现，只有当被相加的两个 DataFrame 的行索引和列索引都能<strong>对应</strong>得上的时候，对应行列所确定的位置上的元素才会进行相应的运算，否则结果中会保留原始 DataFrame 中的行和列，并且对应的元素值设为 NaN</p>
<p>通过调用<code>df.add()</code>方法并且设置<code>fill_value</code>参数，我们可以把只在某一个 DataFrame 中出现过的行或者列设成默认值，也就是<code>fill_value</code>的值：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/image-20250907003441343.png" alt="image-20250907003441343"></p>
<p>这里之所以 006 行 d 列对应的值还是 0，是因为在被相加的两个 DataFrame 中，都不存在 006 行和 d 列这样一个格子，对于这种根本就不存在于任何一个原始的 DataFrame 中的位置，即便设置了 fill_value 最后的结果还是 NaN</p>
<p>其余减法，乘法，除法的运算类似：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/image-20250907003605396.png" alt="image-20250907003605396"></p>
<h3 id="广播机制"><a href="#广播机制" class="headerlink" title="广播机制"></a><strong>广播机制</strong></h3><p>如果把 DataFrame 和某个常数进行四则运算，那么这个四则运算会被映射到 DataFrame 中的每一个元素上，这种机制称为<strong>广播机制</strong>，但前提是需要保证 DataFrame 中的元素支持这种运算：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/image-20250907003732274.png" alt="image-20250907003732274"></p>
<h3 id="行列统计"><a href="#行列统计" class="headerlink" title="行列统计"></a><strong>行列统计</strong></h3><p>再对 DataFrame 进行统计的时候，我们需要指定是对某一列进行统计（axis&#x3D;0）还是对某一行进行统计（axis&#x3D;1），值得注意的是，这里和<code>drop()</code>中的直观感觉是<strong>相反</strong>的，在删除操作中，删除行时 axis&#x3D;0，删除列时 axis&#x3D;1；数据统计时，对行统计时 axis&#x3D;1，对列统计时 axis&#x3D;0</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/image-20250907003941000.png" alt="image-20250907003941000"></p>
<p>在行列统计时，我们会用到 pandas 库中的若干<strong>聚合函数</strong>，所谓聚合函数，就是那些能够根据给定的若干个数据，加工出一个数据的函数</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0.png" alt="image-20250908210851894"></p>
<h3 id="descirbe方法"><a href="#descirbe方法" class="headerlink" title="descirbe方法"></a><strong>descirbe方法</strong></h3><p>通过调用<code>describe()</code>方法，可以得到 DataFrame 每一列的常见统计信息（行数，均值，标准差等），默认是对每一列进行统计，如果额外设置<code>axis=1</code>可以对行进行统计，同时该方法会<strong>自动忽略非数字信息</strong>（如名字等），只对数字信息进行统计：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/image-20250907004406616.png" alt="image-20250907004406616"></p>
<h3 id="apply方法"><a href="#apply方法" class="headerlink" title="apply方法"></a><strong>apply方法</strong></h3><p><code>apply()</code>方法用于把某个函数（多为统计函数）应用到 DataFrame 的每一行或每一列，实现对每一行或每一列的某种操作</p>
<p>设想如下的场景，对于每个选手，我们在统计其平均分时都要去掉一个最高分和一个最低分以后再统计，当前我们得到若干个选手（列索引）和若干个评分（行索引）所组成的 DataFrame，要求我们按列进行均分统计</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cal_mean</span>(<span class="params">data</span>):</span><br><span class="line">  data_len = <span class="built_in">len</span>(data)</span><br><span class="line">  data_sum = data.<span class="built_in">sum</span>()</span><br><span class="line">  data_max = data.<span class="built_in">max</span>()</span><br><span class="line">  data_min = data.<span class="built_in">min</span>()</span><br><span class="line">  <span class="keyword">return</span> (data_sum - data_max - data_min) / (data_len - <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">res = df.apply(cal_mean)</span><br></pre></td></tr></table></figure>

<p>具体实现效果如下（这里是默认按列统计，如果想对每一行进行统计，则可以传入<code>axis=1</code>参数）：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/image-20250907004831974.png" alt="image-20250907004831974"></p>
<h3 id="apply-map方法"><a href="#apply-map方法" class="headerlink" title="apply_map方法"></a><strong>apply_map方法</strong></h3><p>该方法的使用格式和<code>apply()</code>方法类似，只不过该方法会把传入的函数作用到 DataFrame 的<strong>每一个</strong>元素上，可以看成是广播机制的另一种实现方式，只不过它可以实现更加灵活的操作</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.apply_map(<span class="keyword">lambda</span> x: x+<span class="number">5</span>) <span class="comment"># 对 DataFrame 每个元素加 5</span></span><br></pre></td></tr></table></figure>

<h3 id="value-counts方法"><a href="#value-counts方法" class="headerlink" title="value_counts方法"></a><strong>value_counts方法</strong></h3><p>该方法<code>value_counts()</code>本质上是对 Series 的统计方法，该方法会统计 Series 中每个字段出现的次数，返回一个字典结构，同时我们知道，DataFrame 的每一列为一个 Series 结构，因此我们对 DataFrame 也可以按列使用该统计方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">&#x27;列0&#x27;</span>].value_counts()</span><br></pre></td></tr></table></figure>

<h3 id="sort-values方法"><a href="#sort-values方法" class="headerlink" title="sort_values方法"></a><strong>sort_values方法</strong></h3><p>该方法用于对 Series 进行排序，我们可以对 DataFrame 按列进行排序</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">&#x27;列0&#x27;</span>].sirt_values()</span><br></pre></td></tr></table></figure>

<h2 id="Excel数据读取"><a href="#Excel数据读取" class="headerlink" title="Excel数据读取"></a><strong>Excel数据读取</strong></h2><p>通过 pandas 库的<code>read_excel</code>和<code>read_csv</code>函数可以分别读取 xlsx 和 csv 格式的文件，二者都会对应返回一个 DataFrame 结构</p>
<h3 id="xlsx文件读取"><a href="#xlsx文件读取" class="headerlink" title="xlsx文件读取"></a><strong>xlsx文件读取</strong></h3><p>使用<code>read_excel()</code>函数：该函数用于读取 Excel 文件（xlsx 和 xls），接受以下几个参数：</p>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">作用</th>
<th align="center">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>io</code></td>
<td align="center">待读取表格文件的路径</td>
<td align="center"><code>io=&quot;data.xlsx&quot;</code></td>
</tr>
<tr>
<td align="center"><code>sheet_name</code></td>
<td align="center">指定工作表</td>
<td align="center"><code>sheet_name=0</code>（第一张表）</td>
</tr>
<tr>
<td align="center"><code>header</code></td>
<td align="center">列名所在行</td>
<td align="center"><code>header=0</code>（首行为列名）</td>
</tr>
<tr>
<td align="center"><code>skiprows</code></td>
<td align="center">跳过的行数</td>
<td align="center"><code>skiprows=1</code>（跳过标题行）</td>
</tr>
<tr>
<td align="center"><code>usecols</code></td>
<td align="center">读取的列范围</td>
<td align="center"><code>usecols=&quot;A:C&quot;</code>（A到C列）</td>
</tr>
<tr>
<td align="center"><code>dtype</code></td>
<td align="center">列数据类型</td>
<td align="center"><code>dtype=&#123;&quot;列名&quot;: float&#125;</code></td>
</tr>
<tr>
<td align="center"><code>na_values</code></td>
<td align="center">自定义缺失值标记</td>
<td align="center"><code>na_values=[&quot;NA&quot;, &quot;NULL&quot;]</code></td>
</tr>
</tbody></table>
<p>值得注意的是，我们的表格一般都是第一行为列名（str 类型），因此在读取时我们通常要跳过列名所占的一行，也就是<code>skiprows=1</code>，这里注意参数代表的是<strong>行数</strong>，此外如果表格没有表头，即第一行就是数据，我们需要设置<code>header=None</code></p>
<h3 id="csv文件读取"><a href="#csv文件读取" class="headerlink" title="csv文件读取"></a><strong>csv文件读取</strong></h3><p>使用<code>read_csv()</code>函数：该函数用于读取结构化文本文件（csv 和 tsv），通常来讲性能优于<code>read_excel()</code>，接受以下几个参数：</p>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">作用</th>
<th align="center">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>filepath_or_buffer</code></td>
<td align="center">文件路径&#x2F;URL&#x2F;缓冲区</td>
<td align="center"><code>filepath_or_buffer=&quot;data.csv&quot;</code></td>
</tr>
<tr>
<td align="center"><code>sep</code></td>
<td align="center">分隔符</td>
<td align="center"><code>sep=&quot;;&quot;</code>（默认<code>,</code>）</td>
</tr>
<tr>
<td align="center"><code>header</code></td>
<td align="center">设置某一行作为列索引</td>
<td align="center"><code>header=0</code></td>
</tr>
<tr>
<td align="center"><code>index_col</code></td>
<td align="center">设置某一列作为行索引</td>
<td align="center"><code>index_col=0</code></td>
</tr>
<tr>
<td align="center"><code>encoding</code></td>
<td align="center">文件编码</td>
<td align="center"><code>encoding=&quot;utf-8&quot;</code></td>
</tr>
<tr>
<td align="center"><code>parse_dates</code></td>
<td align="center">日期解析列</td>
<td align="center"><code>parse_dates=[&quot;日期&quot;]</code></td>
</tr>
<tr>
<td align="center"><code>chunksize</code></td>
<td align="center">分块读取行数</td>
<td align="center"><code>chunksize=1000</code></td>
</tr>
</tbody></table>
<p>对于<code>header</code>参数，如果我们的 csv 文件没有表头，即第 0 行就是数据本身，我们可以设置<code>header=None</code>，此时得到的 DataFrame 的列索引会默认为 0 1 2… 的递增索引，而如果我们不特殊指明，默认会以文件中第 0 行的内容作为列索引</p>
<p>对于<code>index_col</code>参数，如果我们不进行设置，则返回的 DataFrame 的行索引默认是 0 1 2… 的递增索引，假设我们想选取原 csv 文件中的某一列作为行索引，我们只需要设置<code>index_col=列名</code>即可，注意这里我们取的是<strong>列名</strong>，比如<code>‘列0’</code>而不是列号</p>
<h3 id="读取结果展示"><a href="#读取结果展示" class="headerlink" title="读取结果展示"></a><strong>读取结果展示</strong></h3><p>如果我们待读取的表格包含非常多的列，或者某一个单元格内的文字内容非常多，加载出的 DataFrame 在编辑器中无法完整展示，此时我们可以调用<code>pd.set_option()</code>方法</p>
<p><code>pd.set_option()</code>是 Pandas 库中用于设置<strong>全局显示选项</strong>的方法，它可以控制 Pandas 在显示数据时的各种格式和行为，这个方法非常有用，特别是在处理大型数据集或需要特定显示格式时：</p>
<ul>
<li><code>pd.set_option(&quot;display.max_colimns&quot;, max_num)</code>：设置最多显示的列数为 max_num</li>
<li><code>pd.set_option(&quot;display.max_dolwidth&quot;, max_num)</code>：设置显示的每一列的列宽为 max_num</li>
<li><code>pd.set_option(&quot;display.max_rows&quot;, max_num)</code>：设置最多显示的行数为 max_num</li>
<li><code>pd.set_option(&quot;display.max_precision&quot;, max_num)</code>：设置显示的浮点数据保留到小数点后的位数为 max_num</li>
</ul>
<p>如果想大致了解某个 DataFrame 结构的概况，我们可以考虑使用<code>df.info()</code>方法或者<code>df.describe()</code>方法进行展示</p>
<p><code>df.info()</code>效果：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/info%E7%94%A8%E6%B3%95.png" alt="image-20250907225733339"></p>
<p><code>df.describe()</code>效果：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/describe%E8%AE%B2%E8%A7%A3.png" alt="image-20250907225829230"></p>
<h3 id="xlsx和csv相互转换"><a href="#xlsx和csv相互转换" class="headerlink" title="xlsx和csv相互转换"></a><strong>xlsx和csv相互转换</strong></h3><p>使用 pandas 还可以把 xlsx 和 csv 文件进行相互转化，二者可以分别通过<code>pd.to_csv()</code>和<code>pd.to_excel()</code>函数实现：</p>
<p>Excel_to_Csv用法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">xlsx_to_csv</span>(<span class="params">xlsx_path, csv_path, sheet_name=<span class="number">0</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span></span>):</span><br><span class="line">  <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    将Excel文件转换为CSV</span></span><br><span class="line"><span class="string">    :param xlsx_path: 输入的Excel文件路径</span></span><br><span class="line"><span class="string">    :param csv_path: 输出的CSV文件路径</span></span><br><span class="line"><span class="string">    :param sheet_name: 工作表名/索引（默认第一个表）</span></span><br><span class="line"><span class="string">    :param encoding: 输出编码（默认utf-8）</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">  df = pd.read_excel(xlsx_path, sheet_name=sheet_name)</span><br><span class="line">  df.to_csv(csv_path, index=<span class="literal">False</span>, encoding=encoding)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">f&quot;转换成功！CSV 已保存到: <span class="subst">&#123;csv_path&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例用法</span></span><br><span class="line">xlsx_to_csv(<span class="string">&quot;input.xlsx&quot;</span>, <span class="string">&quot;output.csv&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>Csv_to_Excel用法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">csv_to_xlsx</span>(<span class="params">csv_path, xlsx_path, sheet_name=<span class="string">&#x27;Sheet1&#x27;</span></span>):</span><br><span class="line">  <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    将CSV文件转换为Excel</span></span><br><span class="line"><span class="string">    :param csv_path: 输入的CSV文件路径</span></span><br><span class="line"><span class="string">    :param xlsx_path: 输出的Excel文件路径</span></span><br><span class="line"><span class="string">    :param sheet_name: 工作表名称（默认Sheet1）</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">  df = pd.read_csv(csv_path)</span><br><span class="line">  df.to_excel(xlsx_path, index=<span class="literal">False</span>, sheet_name=sheet_name)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">f&quot;转换成功！Excel 已保存到: <span class="subst">&#123;xlsx_path&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例用法</span></span><br><span class="line">csv_to_xlsx(<span class="string">&quot;input.csv&quot;</span>, <span class="string">&quot;output.xlsx&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="数据保存"><a href="#数据保存" class="headerlink" title="数据保存"></a><strong>数据保存</strong></h3><p>我们先前介绍的<code>to_csv()</code>和<code>to_xlsx()</code>方法不仅能够实现两种数据格式的相互转换，其还可以实现 Python 中的数据以 csv 或 xlsx 格式进行本地保存，我们以<code>to_csv()</code>为例进行介绍</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.to_csv(<span class="string">&quot;待保存的路径&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>如果保存的目标文件已经存在，则会用本次保存的内容<strong>覆盖</strong>其原有的内容</p>
<p>值得注意的是，<code>to_csv()</code>方法会默认把原始数据的列名和索引全部写入到生成的 csv 文件中，这就会导致下面的问题：<code>to_csv()</code>方法会把行索引保存到 csv 文件中，但是再次读取时，<code>read_csv()</code>方法并不知道那是行索引，而是会将其当成表格的第一列数据进行读取，因此会额外生成 0 1 2… 的默认行索引，同时读取得到的 DataFrame 中会多一列 Unnamed: 0</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E5%B0%8F%E9%97%AE%E9%A2%98.png" alt="image-20250908001042835"></p>
<p>对于这个问题的解决，我们可以像调用<code>df.rename()</code>方法把 Unnamed: 0 列进行重新命名，换成一个<strong>有意义</strong>的名字，接着调用<code>df.set_index()</code>方法把这一列重新设置回行索引即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.rename(columns=&#123;<span class="string">&#x27;Unnamed: 0&#x27;</span>, <span class="string">&#x27;Name&#x27;</span>&#125;, inplace=<span class="literal">True</span>)</span><br><span class="line">df.set_index(index=<span class="string">&#x27;Name&#x27;</span>, inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>有时候我们的 DataFrame 中行索引就是默认的 0 1 2… 的递增序列，而不存在额外索引，我们在保存为 csv 文件时不希望额外保存行索引，可以通过设置<code>index=False</code>实现，此时我们重新读取时，就不会出现上面的问题</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.to_csv(<span class="string">&quot;保存路径&quot;</span>, index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<h2 id="数据评估与清洗"><a href="#数据评估与清洗" class="headerlink" title="数据评估与清洗"></a><strong>数据评估与清洗</strong></h2><h3 id="数据评估依据"><a href="#数据评估依据" class="headerlink" title="数据评估依据"></a><strong>数据评估依据</strong></h3><p>我们对一份数据的评估往往可以从格式和内容两个角度进行考量：</p>
<ul>
<li><p>乱数据 - 整洁数据（从格式上评估）</p>
</li>
<li><p>脏数据 - 干净数据（从内容上评估）</p>
</li>
</ul>
<p>整洁数据的三大特征（数据的整洁度）：</p>
<ul>
<li>每列是一个变量</li>
<li>每行是一个观察值</li>
<li>每个单元格中只能存在一个值</li>
</ul>
<p>脏数据的四大特征（数据的干净程度）：</p>
<ul>
<li>存在缺失数据（所谓的 NaN）</li>
<li>存在重复数据，信息冗余</li>
<li>存在不一致数据（不同数据值实际指代同一目标，如中文数字和阿拉伯数字混用，数字单位不一致，全程和简写混用等）</li>
<li>存在错误数据（复合规则但不准确的数据，如负数的身高）</li>
</ul>
<h3 id="评估丢失数据"><a href="#评估丢失数据" class="headerlink" title="评估丢失数据"></a><strong>评估丢失数据</strong></h3><p><strong>统计缺失值个数</strong></p>
<p>如果我们想检查某个 DatFrame 中每一列中缺失值的个数，我们可以先调用<code>df.isnull()</code>方法，该方法会返回一个与原 DataFrame 大小形状完全相同的 DataFrame，为 True 的位置表示原 DataFrame 在该位置为缺失值（NaN），为 False 的位置表示原 DatFrame 在该位置不是缺失值</p>
<p>接着我们对统计得到的 bool 类型的 DataFrame 进行<code>df.sum()</code>统计，也就是<strong>按列求和</strong>（sum 是统计方法，默认会按列进行统计，如果想按行进行统计，可以设置轴 axis&#x3D;1），即可得到原 DataFrame 每一列缺失值的个数</p>
<p>此外，我们也可以只对 DataFrame 中的某一列或某几列统计缺失值，我们只需要使用<code>[列名]</code>把对应列提取出来以后，再调用<code>df.isnull()</code>和<code>df.sum()</code>方法即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.isnull().<span class="built_in">sum</span>() <span class="comment"># 返回 df 中每一列缺失值的数量</span></span><br><span class="line">df[<span class="string">&#x27;列0&#x27;</span>].isnull().<span class="built_in">sum</span>() <span class="comment"># 返回 df 列0中缺失值的数量</span></span><br></pre></td></tr></table></figure>

<p>实现效果：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E7%BC%BA%E5%A4%B1%E5%80%BC%E7%BB%9F%E8%AE%A1.png" alt="image-20250907231621237"></p>
<p><strong>提取存在缺失值的行</strong></p>
<p>如果我们先从 DataFrame 中提取出某一列（以列0为例）存在缺失值的行，我们可以先对该列进行<code>df.isnull()</code>得到一个与该列形状相同的 bool 列表，再用这个 bool 列表作为条件，提取所有列表位置为 True 的行，即为存在缺失值的行</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df1 = df[<span class="string">&#x27;列0&#x27;</span>].isnull() <span class="comment"># 列0对应的bool数组</span></span><br><span class="line">df[df1] <span class="comment"># 提取出所有列0缺失的行</span></span><br></pre></td></tr></table></figure>

<p>实现效果：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E6%8F%90%E5%8F%96%E4%B8%A2%E5%A4%B1%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%8C.png" alt="image-20250907232323200"></p>
<h3 id="评估重复数据"><a href="#评估重复数据" class="headerlink" title="评估重复数据"></a><strong>评估重复数据</strong></h3><p>通过调用<code>df.duplicated()</code>方法，我们可以找到 Series 或者 DataFrame 中的重复数据，对于 Series 而言，该方法返回一个和原 Series 形状相同的 Series，如果原 Series 中某个位置的元素<strong>在它前面的位置</strong>中出现过，则对应这个位置就会为 True，反之则为 False</p>
<p>而如果是对 DataFrame 而言，该方法会返回一个以 DataFrame 的行数为长度的 Series，如果 DataFrame 中的某一行在它前面的行中出现过（这里要求在这一行之前存在<strong>与它的每一列都完全相同</strong>的一行），则对应 Series 位置为 True，反之则为 False</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.duplicated()</span><br></pre></td></tr></table></figure>

<p>效果展示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E9%87%8D%E5%A4%8D%E5%80%BC.png" alt="image-20250907233234142"></p>
<p>有些时候，我们认定某一行重复，可能不需要所有列都相同，比如对于上例中的学生信息而言，可能姓名和性别相同时，我们就认为这个学生信息是重复的，此时我们可以在<code>df.duplicated()</code>中传入<code>dubset=[&#39;姓名&#39;,&#39;性别&#39;]</code>，也就是传入一个列表，列表中传入待比较的<strong>列</strong>即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.duplicated(subset=[<span class="string">&#x27;姓名&#x27;</span>, <span class="string">&#x27;性别&#x27;</span>])</span><br></pre></td></tr></table></figure>

<p>效果展示</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E6%9C%89%E6%9D%A1%E4%BB%B6%E7%9A%84%E9%87%8D%E5%A4%8D%E5%80%BC.png" alt="image-20250907234207437"></p>
<p>最后，我们可以仿照上面的行提取思路，提取所有存在<strong>特定列</strong>重复的行</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[df.duplicated[subset=[<span class="string">&#x27;姓名&#x27;</span>, <span class="string">&#x27;性别&#x27;</span>]]]</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E6%8F%90%E5%8F%96%E7%89%B9%E6%AE%8A%E8%A1%8C.png" alt="image-20250907234449435"></p>
<h3 id="行列索引修改"><a href="#行列索引修改" class="headerlink" title="行列索引修改"></a><strong>行列索引修改</strong></h3><p><strong>单个修改</strong></p>
<p>通过<code>df.rename()</code>方法，可以修改 DataFrame 的行索引或列索引，如果想修改行索引，则传入<code>index=[]</code>参数，如果想修改列索引，则传入<code>columns=[]</code>参数，传入的参数都是第一个字典，字典中的键是<strong>待修改的老索引</strong>，值是<strong>想修改成的新索引</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.rename(index=&#123;<span class="string">&#x27;旧行索引1&#x27;</span>:<span class="string">&#x27;新行索引1&#x27;</span>, <span class="string">&#x27;旧行索引2&#x27;</span>:<span class="string">&#x27;新行索引2&#x27;</span>&#125;)</span><br><span class="line">df.rename(columns=&#123;<span class="string">&#x27;旧列索引1&#x27;</span>:<span class="string">&#x27;新列索引1&#x27;</span>, <span class="string">&#x27;旧列索引2&#x27;</span>:<span class="string">&#x27;新列索引2&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>用法示例：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/rename%E7%94%A8%E6%B3%95.png" alt="image-20250908080104338"></p>
<p>对列名的修改同理，只是传入的是<code>colunms</code>参数</p>
<p>此外，<code>df.rename()</code>方法会返回修改后的新的 DataFrame，如果想对原本的 DataFrame 进行修改，我们可以通过设置<code>inplace=True</code>实现</p>
<p><strong>批量修改</strong></p>
<p>Pandas 也支持向<code>df.rename()</code>中的<code>index</code>和<code>colunms</code>参数传入一个<strong>函数</strong>，这个函数会作用到 DataFrame 的每一个行索引或者列索引上，实现对行列索引的<strong>批量修改</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.rename(colunms=<span class="built_in">str</span>.upper) <span class="comment"># 把列名一致变成大写</span></span><br></pre></td></tr></table></figure>

<p>实现效果：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/rename%E5%87%BD%E6%95%B0%E4%BC%A0%E5%85%A5.png" alt="image-20250908080658862"></p>
<h3 id="设置行索引"><a href="#设置行索引" class="headerlink" title="设置行索引"></a><strong>设置行索引</strong></h3><p>通过调用<code>df.set_index(“列名)</code>可以把某一列的内容设置为新的行索引，我们传入待设为行索引的那一列的列名即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.set_index(<span class="string">&#x27;列0&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="重置行索引"><a href="#重置行索引" class="headerlink" title="重置行索引"></a><strong>重置行索引</strong></h3><p>通过调用<code>df.rset_index()</code>可以实现把行索引重新设置为 0 1 2… 这种顺序排列的情况，至于原本作为行索引的列是否保留，我们可以通过设置<code>drop</code>参数实现，人为设置为 True 则选择舍弃，默认设置为 False 则为保留</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.reset_index(drop=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<h3 id="索引排序"><a href="#索引排序" class="headerlink" title="索引排序"></a><strong>索引排序</strong></h3><p>通过调用<code>df.sort_index()</code>可以实现对行或列索引的排序，默认参数<code>axis=0</code>表示对行索引排序，如果人为设置<code>axis=1</code>则表示对列索引排序</p>
<p>（默认 axis&#x3D;0 时，沿着索引纵向操作，设置 axis&#x3D;1 时，沿着索引横向操作）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.sort_index()</span><br></pre></td></tr></table></figure>

<h3 id="按列拆分"><a href="#按列拆分" class="headerlink" title="按列拆分"></a><strong>按列拆分</strong></h3><p>假设对于下面的模型，我们希望把人口密度这一列按照 &#x2F; 的分隔，拆分成人口数量和占地面积这两部分：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E5%BE%85%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98.png" alt="image-20250908082314968"></p>
<p>通过调用<code>df[&quot;待拆分的列&quot;].str.split(&quot;待使用的分隔字符&quot;)</code>可以实现对 DataFrame 的某一列按照某个分隔符进行拆分的效果，拆分的结果会以一个列表的形式返回：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E5%8D%95%E7%BA%AF%E6%8B%86%E5%88%86.png" alt="image-20250908082352831"></p>
<p>但是这样拆分，拆分后的两列以列表的形式给出，我们通过设置<code>expend=True</code>这个参数，表示拆分结果以<strong>Series</strong>的形式返回即可：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E4%BB%A5Series%E8%BF%94%E5%9B%9E.png" alt="image-20250908082459917"></p>
<p>接着我们需要把新得到的两列加入到原始的 DataFrame 中，这里可以通过<code>df[[&#39;列名1&#39;, &#39;列名2&#39;,...]]=series</code>的形式，把待加入的新列逐个加入：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df2[[<span class="string">&#x27;人口&#x27;</span>, <span class="string">&#x27;面积&#x27;</span>]] = df2[<span class="string">&#x27;人口密度&#x27;</span>].<span class="built_in">str</span>.split(<span class="string">&quot;/&quot;</span>, expend=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>实现效果：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E5%AE%9E%E7%8E%B0%E6%95%88%E6%9E%9C%E7%9A%84%E5%88%86%E9%9A%94.png" alt="image-20250908082804753"></p>
<p>最后我们只需要删除 DataFrame 中原有的人口密度这一列即可，可以通过<code>df.drop(&#39;待删除列名&#39;, axis=1)</code>实现对这一列的删除：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E6%9C%80%E5%90%8E%E7%9A%84%E5%88%A0%E9%99%A4.png" alt="image-20250908082922359"></p>
<h3 id="按列合并"><a href="#按列合并" class="headerlink" title="按列合并"></a><strong>按列合并</strong></h3><p>假设对于下面的模型，我们想把原始 DataFrame 中 “姓” 这一列和 “名” 这一列进行合并，通过调用<code>df[&#39;列A&#39;].str.cat(&#39;列B&#39;)</code>方法即可实现把 A 和 B 列名对应的两列内容的拼接：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E6%8B%BC%E6%8E%A5%E6%93%8D%E4%BD%9C.png" alt="image-20250908083136624"></p>
<p>此外，我们可以通过或设置<code>sep</code>参数，指定拼接时的分隔符，比如在上例中我们如果指定<code>sep=&#39;-&#39;</code>就会得到<code>张-三, 李-四, 王-五</code>这样的拼接结果</p>
<p>之后我们只需要把拼接得到的新列进行添加，原始列进行删除即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df3[<span class="string">&#x27;姓名&#x27;</span>] = df3[<span class="string">&#x27;姓&#x27;</span>].<span class="built_in">str</span>.cat(df3[<span class="string">&#x27;名&#x27;</span>])</span><br><span class="line">df3.drop([<span class="string">&#x27;姓&#x27;</span>, <span class="string">&#x27;名&#x27;</span>], axis=<span class="number">1</span>) </span><br></pre></td></tr></table></figure>

<h3 id="宽数据转长数据"><a href="#宽数据转长数据" class="headerlink" title="宽数据转长数据"></a><strong>宽数据转长数据</strong></h3><p>所谓的宽数据转长数据，即为把一部分列名的值，转换为变量的值，比如对于下面的例子来说，我们设置<strong>年龄组</strong>为新的一列，把列名中男性和女性的各个年龄组都作为这一列中的变量：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E5%AE%BD%E8%BD%AC%E9%95%BF.png" alt="image-20250908083856753"></p>
<p>通过调用<code>df.melt()</code>即可实现宽数据向长数据的转化，该方法接受四个参数：</p>
<ul>
<li><code>df</code>：待转化的 DataFrame</li>
<li><code>id_vars=[]</code>：要保留的列的列名构成的列表（其余的列名都会作为新列的变量）</li>
<li><code>var_name=&quot;&quot;</code>：新生成列的列名</li>
<li><code>value_name=&quot;&quot;</code>：被转化为变量的那些列名在原 DataFrame 中对应的值所构成的新列的列名</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.melt(df, id_vars=[<span class="string">&#x27;国家代码&#x27;</span>, <span class="string">&#x27;年份&#x27;</span>], var_name=<span class="string">&quot;年龄组&quot;</span>, value_name=<span class="string">&quot;肺结核病例数&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="按行拆分"><a href="#按行拆分" class="headerlink" title="按行拆分"></a><strong>按行拆分</strong></h3><p>假设对于下面的例子，我们先把每个学生所在的行，按照它所选修的课程进行再次拆分：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E6%8C%89%E8%A1%8C%E6%8B%86%E5%88%86.png" alt="image-20250908084604624"></p>
<p>可以通过调用<code>df.exploe(&#39;待拆分列名&#39;)</code>，传入待拆分的列名，即可把该列中的每个元素拆分成为单独的一行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.explode(<span class="string">&#x27;课程列表&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="缺失值填充"><a href="#缺失值填充" class="headerlink" title="缺失值填充"></a><strong>缺失值填充</strong></h3><p>通过调用<code>df.fillna()</code>方法，可以实现对 DataFrame 中缺失值的填充，我们既可以实现对整个 DataFrame 缺失值的统一填充，也可以只针对其中某些列分别进行填充，还支持传入一个字典分别指出每一列的填充值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df.fillna(<span class="number">0</span>) <span class="comment"># 全局用 0 填充 </span></span><br><span class="line">df[<span class="string">&#x27;列0&#x27;</span>].fillna(df[<span class="string">&#x27;列0&#x27;</span>].mean()) <span class="comment"># 只对列0用这一列的平均值填充</span></span><br><span class="line">df.fillna(&#123;<span class="string">&#x27;列0&#x27;</span><span class="number">0</span>:, <span class="string">&#x27;列1&#x27;</span>:<span class="number">1</span>, <span class="string">&#x27;列2&#x27;</span>:<span class="number">2</span>&#125;) <span class="comment"># 对每一列用不同值填充</span></span><br></pre></td></tr></table></figure>

<h3 id="缺失值删除"><a href="#缺失值删除" class="headerlink" title="缺失值删除"></a><strong>缺失值删除</strong></h3><p>如果有时候缺失的不是关键信息，或者缺失的信息难以补全 &#x2F; 补全的价值也不大，我们可以考虑使用<code>df.dropna()</code>方法直接把信息缺失的行进行删除</p>
<p>如果单纯调用<code>df.dropna()</code>方法而不传入任何参数，该方法会删除原 DataFrame 中所有有缺失信息的行（对于某一行而言，只要存在一列信息是缺失的，这一行就会被删除）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E5%85%A8%E5%B1%80%E5%88%A0%E9%99%A4.png" alt="image-20250908090836970"></p>
<p>而实际上，对于上面的例子而言，如果我们想统计员工的工资问题，那么年龄值的缺失其实并不总要，所以我们只需要删除工资值有缺失的行即可，可以通过对<code>df.dropna()</code>中传入<code>subset=[]</code>参数，列表中放上想要判定的列，只有这些列存在缺失的行才会被删除，其余列缺失的行会被保留</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.dropna(subset=[<span class="string">&#x27;工资&#x27;</span>])</span><br></pre></td></tr></table></figure>

<p>我们可以通过指定<code>axis=1</code>来全局删除有缺失值的列</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.dropna(axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h3 id="重复数据删除"><a href="#重复数据删除" class="headerlink" title="重复数据删除"></a><strong>重复数据删除</strong></h3><p>通过调用<code>df.drop_duplicates()</code>方法，我们可以删除掉 DataFrame 中重复的行，具体判定结果为：对于当前的一行，如果有和它完全相同（每一列内容都相同）的行在它之前出现过，我们就把这一行删除；反之这一行就保留</p>
<p>实现效果：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E8%A1%8C.png" alt="image-20250908091352312"></p>
<p>和缺失值删除同理，如果我们希望在<strong>部分列</strong>重复的时候（比如上例中的姓名和性别）就可以删除这些行，而不是比较这一行的所有列，此时也可以通过传入<code>subset=[]</code>参数，列表中写待比较的列名即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.drop_duplicates(subset=[<span class="string">&#x27;姓名&#x27;</span>, <span class="string">&#x27;性别&#x27;</span>])</span><br></pre></td></tr></table></figure>

<p>一般而言，如果两行或多行出现重复时，<code>drop_duplicates()</code>会保留第一行而删除后面的行，我们也可以设置<code>keep=last</code>来保留最后一行</p>
<h3 id="列值进行替换"><a href="#列值进行替换" class="headerlink" title="列值进行替换"></a><strong>列值进行替换</strong></h3><p>假设我们想对 DataFrame 中某一列的值进行整体替换，可以使用<code>df.replace()</code>实现替换功能，该方法的常见用法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把学校这一列的 buaa 全替换为 cvbb</span></span><br><span class="line">df[<span class="string">&#x27;学校&#x27;</span>].replace(<span class="string">&#x27;buaa&#x27;</span>, <span class="string">&#x27;cvbb&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把 DataFrame 中所有的 buaa 替换为 cvbb</span></span><br><span class="line">df.replace(<span class="string">&#x27;buaa&#x27;</span>, <span class="string">&#x27;cvbb&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把学校这一列的 buaa uaab aabu 全替换为 cvbb</span></span><br><span class="line">df[<span class="string">&#x27;学校&#x27;</span>].replace([<span class="string">&#x27;buaa&#x27;</span>, <span class="string">&#x27;uaab&#x27;</span>, <span class="string">&#x27;aabu&#x27;</span>], <span class="string">&#x27;cvbb&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 传入字典完成多组替换</span></span><br><span class="line">df.replace(&#123;<span class="string">&#x27;buaa&#x27;</span>:<span class="string">&#x27;cvbb&#x27;</span>, <span class="string">&#x27;uaab&#x27;</span>:<span class="string">&#x27;vbbc&#x27;</span>, <span class="string">&#x27;aabu&#x27;</span>:<span class="string">&#x27;bbvc&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a><strong>数据类型转换</strong></h3><p>通过<code>series.astype(待转换的类型)</code>可以实现对 Series 中数据类型的强制转换，对于 DataFrame 而言，我们可以对其按列进行这样的转换操作</p>
<p>值得注意的是，Pandas 中的字符串类型也被表示成为<code>object</code>类型，二者是等价的</p>
<p>Pandas 中还有一类特殊的数据类型称为<strong>分类数据</strong>，用<code>category</code>进行表示，对于 Pandas 而言，数据可以被划分为两种类型：</p>
<ul>
<li>分类数据：取值范围有限，比如性别，国家，省份，一个公司中的部门</li>
<li>数值数据：取值范围无限，比如身高，体重</li>
</ul>
<p>对于类别有限的数据，我们推荐将其转化为 category 类型，既可以节省内存空间，也可以在后续可视化时提供便捷，注意转换时，catrgory 需要加引号，这是因为它不是 Python 本身的数据类型（bool，int，float 等），而是 Pandas 中提供的一种数据类型，不加引号 Python 无法识别：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = pd.Series([<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>. <span class="string">&#x27;blue&#x27;</span>])</span><br><span class="line">s.astype(<span class="string">&quot;category&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="数据整理"><a href="#数据整理" class="headerlink" title="数据整理"></a><strong>数据整理</strong></h2><h3 id="concat拼接"><a href="#concat拼接" class="headerlink" title="concat拼接"></a><strong>concat拼接</strong></h3><p>假设我们现在有两个相同类型的 DataFrame 分别为 df1 和 df2，我们希望把二者<strong>从上到下</strong>拼接为一个完整的 DataFrame，可以通过调用<code>pd.concat([df1, df2])</code>实现，该方法接受一个列表，列表中放入待拼接的 df 即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.concat([df1, df2], ignore_index=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>如果 df1 和 df2 的列名是完全相同的，在拼接时，concat 函数会自动对列进行对齐，其中<code>ignore_index</code>参数设置为 True 时会忽略掉原有 df 的行索引，对拼接后整体的 df 整体从 0 1 2… 进行行索引顺序排序</p>
<p>如果待拼接的 df 之间存在不相同的列（比如 df1 有列 a 而 df2 没有，df2 有列 b 而 df1 没有），拼接时新 df 的列会在所有列之间取并集，不存在的数据就会对应生成 NaN 值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df1 = pd.DataFrame(&#123;<span class="string">&quot;列1&quot;</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], <span class="string">&quot;列2&quot;</span>:[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]&#125;)</span><br><span class="line">df2 = pd.DataFrame(&#123;<span class="string">&quot;列A&quot;</span>:[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], <span class="string">&quot;列B&quot;</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]&#125;)</span><br><span class="line">pd.concat([df1, df2], ignore_index=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E6%9C%89%E7%BC%BA%E5%A4%B1%E5%80%BC%E7%9A%84%E5%90%88%E5%B9%B6.png" alt="image-20250908195814836"></p>
<p>我们也可以把 df 沿着<strong>行</strong>方向进行横向拼接，只需要在调用<code>pd.concat()</code>方法的时候设置<code>axis=1</code>即可，不过不常用</p>
<h3 id="merge合并"><a href="#merge合并" class="headerlink" title="merge合并"></a><strong>merge合并</strong></h3><p><strong>具体的合并实现</strong></p>
<p>假设我们有如下的两个 DataFrame，这两个 DataFrame 中存在某一列是相同的（列名相同），我们想基于这一列把两个 DataFrame 进行合并，可以通过<code>pd.merge()</code>，该方法接受以下几个参数：</p>
<ul>
<li><code>df1</code>：待合并的 DataFrame 之一</li>
<li><code>df2</code>：待合并的 DataFrame 之一</li>
<li><code>on</code>：合并时根据哪一列进行合并</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.merge(df1, df2, on=<span class="string">&quot;合并所依据的列名&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>此外，<code>on</code>参数中也可以传入一个列表，表示依据多个列进行合并，只有某一行对应的这些列值在两个 df 中都出现时，这一行在新的 DataFrame 中才得以保留：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.merge(df1, df2, on=[<span class="string">&quot;参考列1&quot;</span>, <span class="string">&quot;参考列2&quot;</span>])</span><br></pre></td></tr></table></figure>

<p>如果某个变量在 df1 和 df2 中都有出现，但是二者所对应的列名不同（比如订单日期和交易日期，表述不同但含义相同），此时我们仍然想依据这些列进行合并，我们可以分别设置<code>left_on</code>和<code>right_on</code>参数，分别指定 df1 和 df2 在合并时参考的列：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.merge(df1, df2, left_on=<span class="string">&quot;df1的参考列&quot;</span>, right_on=<span class="string">&quot;df2的参考列&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>能这么合并的关键在于，df1 和 df2 的参考列的长度，意义都相同，对应也有重合的变量，只是列名的表述形式不同</p>
<p>在合并时，如果除了我们所指定的用于作为合并参考的列，两个 df 中还有其他的重名列，那么合并以后这两个重名列都会被保留，会默认加上<code>_x</code>和<code>_y</code>的后缀，如果我们想自定义后缀，则可以设置<code>suffixes=[]</code>参数进行修改</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.merge(df1, df2, suffiex=[<span class="string">&#x27;_df1&#x27;</span>, <span class="string">&#x27;_df2&#x27;</span>])</span><br></pre></td></tr></table></figure>

<p><strong>合并后列数的确定</strong></p>
<p>对于合并后新 DataFrame 的列数的确定，实际上是通过合并时的<code>how</code>参数进行确定的，这个参数的值可以为 inner，outer，left，right，如果不指定则默认为 inner，我们以下面这张表为例解释四个参数的含义，假设我们要按照二者<strong>彩色</strong>的列进行合并：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E5%90%88%E5%B9%B6%E5%AE%9E%E4%BE%8B%E5%9B%BE.png" alt="image-20250908203349153"></p>
<p>how&#x3D;’inner’：只保留左右表都有匹配的列值，相当于左右表的列值取交集</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/image-20250908203627523.png" alt="image-20250908203627523"></p>
<p>how&#x3D;’outer’：保留左右表中的所有列值，相当于左右表的列值取并集，如果不存在则设为 NaN</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/image-20250908203728499.png" alt="image-20250908203728499"></p>
<p>how&#x3D;’left’：保留左边表中的所有列值，右边表的每一个列值根据左边表去匹配，相当于 A ∪ (A∩B)，如果匹配不上则设为 NaN</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/image-20250908203852604.png" alt="image-20250908203852604"></p>
<p>how&#x3D;’right’：保留右边表中的所有列值，左边表的每一个列值根据右边表去匹配，相当于 B ∪ (B∩A)，如果匹配不上则设为 NaN</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/image-20250908203945058.png" alt="image-20250908203945058"></p>
<h3 id="join合并"><a href="#join合并" class="headerlink" title="join合并"></a><strong>join合并</strong></h3><p><code>join()</code>也可以用于 DataFrame 的合并，只不过它是基于<strong>索引</strong>去进行合并，注意它是一个内置在 DataFrame 中的方法，需要用一个 DataFrame 实例调用才能实现，其接受以下几个参数：</p>
<ul>
<li><code>how</code>：拼接方式（inner，outer，left，right）</li>
<li><code>lsuffix</code>：有重名列时，左边列的后缀</li>
<li><code>rsuffix</code>：有重名列时，右边列的后缀</li>
</ul>
<p>因为<code>join()</code>方法是按照索引拼接，因此如果当待拼接的两个数据框有重名列的时候，必须指定左右重名列在新 DataFrame 中的后缀，否则会发生列名冗余错误</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df1.join(df2, how=<span class="string">&quot;inner&quot;</span>, lsuffix=<span class="string">&quot;_df1&quot;</span>, rsuffix=<span class="string">&quot;_df2&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="分组聚合"><a href="#分组聚合" class="headerlink" title="分组聚合"></a><strong>分组聚合</strong></h3><p>如果我们想对某个 DataFrame 进行分组，比如对一家超市的三家分店分别进行研究，可以通过调用<code>df.groupby()</code>方法实现相关的功能</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.groupby(<span class="string">&quot;分店名称&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>我们传入作为分类变量的列名，该方法就会这一列中所有列值相同的行划分到一起，组成一个新的 DataFrame 返回，该方法返回的是一个<code>DataFrameGroupBy</code>的实例</p>
<p>这里我们聚合之后，并不能直观的得到分组后的各个 DataFrame，我们通常会直接对分组后得到的实例取某一列或者某几列，然后接着调用一个<strong>聚合方法</strong>，返回某一列或者某几列的聚合值</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8.png" alt="image-20250908211043723"></p>
<p>这里我们只是做逻辑上的演示，实际运行中分组得到的 DataFrameGroupBy 实例和取其中某几列的结果都是不可见的，而最后聚合得到的结果是单个值还是一个 Series，则取决于我们是对单列统计还是对多列统计：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 统计单列的结果</span></span><br><span class="line">df.groupby(<span class="string">&#x27;待分组的列名&#x27;</span>)[<span class="string">&#x27;待统计的列名&#x27;</span>].聚合方法</span><br><span class="line"><span class="comment"># 统计多列的结果</span></span><br><span class="line">df.groupby(<span class="string">&#x27;待分组的列名&#x27;</span>)[[<span class="string">&#x27;待统计的列名1&#x27;</span>,<span class="string">&#x27;待统计的列名2&#x27;</span>,<span class="string">&#x27;待统计的列名3&#x27;</span>]].聚合方法</span><br></pre></td></tr></table></figure>

<p>此外，我们在分组时也可以传入多个列名组成的列表，即可进行多重分组：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.groupby([<span class="string">&#x27;列1&#x27;</span>, <span class="string">&#x27;列2&#x27;</span>])</span><br></pre></td></tr></table></figure>

<p>对于我们所使用的聚合方法，这里我们不一定要调用现有的聚合函数，也可以通过<code>apply()</code>方法，传入一个我们自定义的聚合函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">max_plus_10</span>(<span class="params">nums</span>):</span><br><span class="line">	<span class="keyword">return</span> nums.<span class="built_in">max</span>()+<span class="number">10</span></span><br></pre></td></tr></table></figure>

<h3 id="表格形状重塑"><a href="#表格形状重塑" class="headerlink" title="表格形状重塑"></a><strong>表格形状重塑</strong></h3><p>对于一个 DataFrame，假设我们想改变它的结构，其已有的列中进行选择，指定某些列作为行索引，某些列作为列名，指定某些列作为值并且进行聚合，得到一个新的结构的 DataFrame，这一过程就称为表格形状的<strong>重塑</strong>，可以通过调用<code>pd.pivot_table()</code>实现，也就是 Excel 中类似透视表的功能</p>
<p>该函数接受以下几个参数：</p>
<ul>
<li><code>df</code>：原始的 DataFrame</li>
<li><code>index</code>：作为行索引的原 df 列</li>
<li><code>columns</code>：作为列名的原 df 列</li>
<li><code>values</code>：作为求值的原 df 列</li>
<li><code>aggfunc</code>：选择聚合函数</li>
</ul>
<p>应用实例，对于下面这张表格，我们用<code>pd.pivot_table()</code>分别做不同的处理：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/image-20250908212845642.png" alt="image-20250908212845642"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 处理2要求 : 把分店编号和时间段作为索引，商品类别作为列，计算销售额的总和</span></span><br><span class="line">pd.pivot_table(df, index=[<span class="string">&quot;分店编号&quot;</span>, <span class="string">&quot;时间段&quot;</span>], columns=<span class="string">&quot;商品类别&quot;</span>, values=<span class="string">&quot;销售额&quot;</span>, aggfunc=np.<span class="built_in">sum</span>)</span><br></pre></td></tr></table></figure>

<p>实现效果：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/image-20250908212607700.png" alt="image-20250908212607700"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 处理1要求 : 把商品类别作为索引，分店编号作为列，计算销售额的平均值</span></span><br><span class="line">pd.pivot_table(df, index=<span class="string">&quot;商品类别&quot;</span>, columns=<span class="string">&quot;分店编号&quot;</span>, values=<span class="string">&quot;销售额&quot;</span>, aggfunc=np.<span class="built_in">sum</span>)</span><br></pre></td></tr></table></figure>

<p>实现效果：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/image-20250908212801269.png" alt="image-20250908212801269"></p>
<h3 id="子组合并"><a href="#子组合并" class="headerlink" title="子组合并"></a><strong>子组合并</strong></h3><p>上面我们已经可以通过<code>groupby()</code>方法进行分组划分，假设我们以年龄为例进行划分，那么每个<strong>年龄值</strong>都会被划分为一组，这样就会导致分组过多，假设我们想以每个<strong>年龄段</strong>（年龄的范围区间）作为一组，即可通过<code>df.cut()</code>方法，对聚合后的结果进行进一步处理，达到组数压缩的效果</p>
<p>该方法接受以下几个参数：</p>
<ul>
<li><code>bins</code>：用于分组的边界数组</li>
<li><code>labels</code>：每个分组的命名所组成的数组（长度为 bins 的长度 -1）</li>
</ul>
<p>假设我们要对年龄进行分组：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把年龄分成 (10,20], (20,30], (30,40], (40,50], (50,60], (60,120] 这些年龄段</span></span><br><span class="line">age_bins = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">60</span>,<span class="number">120</span>]</span><br><span class="line"><span class="comment"># 每个年龄段对应的标签</span></span><br><span class="line">age_labels = [<span class="string">&#x27;少年&#x27;</span>, <span class="string">&#x27;青年&#x27;</span>, <span class="string">&#x27;壮年&#x27;</span>, <span class="string">&#x27;中年&#x27;</span>, <span class="string">&#x27;中老年&#x27;</span>, <span class="string">&#x27;老年&#x27;</span>]</span><br><span class="line">pd.cur(df[<span class="string">&#x27;年龄&#x27;</span>], bins=age_bins, labels=age_labels)</span><br></pre></td></tr></table></figure>

<p>这段代码会输出原 df 中年龄一列中每个年龄值所对应的年龄段标签，这些标签整体组成一个 Series，类型为 category，也就是分类变量类型</p>
<p>有了每个年龄值对应的年龄标签以后，我们就可以根据这个年龄标签对原 DataFrame 进行分组聚合：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">&#x27;年龄段&#x27;</span>] = pd.cut(df[<span class="string">&#x27;年龄&#x27;</span>], bins=age_bins, labels=age_labels)</span><br><span class="line">df.groupby(<span class="string">&#x27;年龄组&#x27;</span>)[<span class="string">&#x27;工资&#x27;</span>].mean()</span><br></pre></td></tr></table></figure>

<h3 id="层次化索引展平"><a href="#层次化索引展平" class="headerlink" title="层次化索引展平"></a><strong>层次化索引展平</strong></h3><p>在使用 groupby 分组时，如果使用了不止一个的索引变量，则会得到层次化索引</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E5%B1%82%E6%AC%A1%E5%8C%96%E7%B4%A2%E5%BC%95.png" alt="image-20250908214731796"></p>
<p>针对层次化索引，我们仍然可以通过多次调用<code>loc[]</code>方法<strong>逐层</strong>提取出我们想要的目标元素：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只提取分店编号</span></span><br><span class="line">grouped_df.loc[<span class="string">&#x27;001&#x27;</span>]</span><br><span class="line"><span class="comment"># 同时提取分店编号和时间段</span></span><br><span class="line">grouped_df.loc[<span class="string">&#x27;001&#x27;</span>].loc[<span class="string">&#x27;202201&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>如果我们需要把层次化索引展平成原本的一维行索引，则可以通过调用<code>reset_index()</code>方法，把行索引进行展平，此时原本的层次化索引会重新变回<strong>列值</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grouped_df.reset_index()</span><br></pre></td></tr></table></figure>

<h3 id="query获取满足条件的行"><a href="#query获取满足条件的行" class="headerlink" title="query获取满足条件的行"></a><strong>query获取满足条件的行</strong></h3><p>通过<code>query()</code>方法和在<code>df[]</code>中传入条件表达式都可以获取满足条件的 DataFrame 的行，只是前者书写起来更加美观得体</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query(<span class="string">&#x27;(性别==&quot;男&quot;) &amp; (年龄 &lt;= 20)&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>值得注意的是，query 中传入的本身是一个字符串，这个字符串中再调用列名的时候，不需要使用引号进行包裹，此外该字符串内部的其他字符串需要用与外层字符串<strong>不同</strong>的引号进行包裹</p>
<h2 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a><strong>数据可视化</strong></h2><h3 id="常用图表类型"><a href="#常用图表类型" class="headerlink" title="常用图表类型"></a><strong>常用图表类型</strong></h3><p>根据我们提供的原始数据不同，我们可以绘制不同类型的图表：</p>
<ul>
<li>两个数值变量：散点图，折线图</li>
<li>一个分类变量一个数值变量：条形图，饼图</li>
</ul>
<p>散点图：展示两个数值变量之间的相关性</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E6%95%A3%E7%82%B9%E5%9B%BE.png" alt="image-20250908105200666"></p>
<p>折线图：展示连续间隔或时间跨度上数值的变化，从而反应趋势变化</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E6%8A%98%E7%BA%BF%E5%9B%BE.png" alt="image-20250908105225711"></p>
<p>条形图：展示各个分类变量所对应的数值变量</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E6%9D%A1%E5%BD%A2%E5%9B%BE.png" alt="image-20250908105253574"></p>
<p>饼图：展示各个分类对应的数值之间的比例</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E9%A5%BC%E5%9B%BE.png" alt="image-20250908105323554"></p>
<p><strong>给散点图引入更多变量</strong></p>
<p>如果要引入新的分类变量，我们可以使用不同颜色的散点绘图</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E6%95%A3%E7%82%B9%E5%9B%BE%E5%8A%A0%E5%88%86%E7%B1%BB.png" alt="image-20250908105538477"></p>
<p>如果要引入新的数值变量，我们可以绘制气泡图（改变点的大小，越大的点表示此处对应的数值越大）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E6%B0%94%E6%B3%A1%E5%9B%BE.png" alt="image-20250908105634208"></p>
<p><strong>给折线图引入更多变量</strong></p>
<p>如果要引入新的分类变量，我们可以用不同颜色绘制多条折线</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E6%8A%98%E7%BA%BF%E5%9B%BE%E5%BC%95%E5%85%A5%E5%8F%98%E9%87%8F.png" alt="image-20250908115841118"></p>
<p><strong>给条形图引入更多变量</strong></p>
<p>如果要引入新的分类变量，我们可以绘制<strong>复式条形图</strong>，也就是用不同颜色绘制条形图中的条柱</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E6%9D%A1%E5%BD%A2%E5%9B%BE%E5%BC%95%E5%85%A5%E5%8F%98%E9%87%8F.png" alt="image-20250908120009463"></p>
<p>我们通常使用<code>seaborn</code>和<code>matplotlib</code>这两个库进行数据的可视化，其中前者是基于后者实现的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br></pre></td></tr></table></figure>

<h3 id="单变量图表绘制"><a href="#单变量图表绘制" class="headerlink" title="单变量图表绘制"></a><strong>单变量图表绘制</strong></h3><p>我们通过调用<code>sns.*pot()</code>绘制对应的图表，该函数有两种参数接受形式：</p>
<ul>
<li>直接传入一个 Series</li>
<li>传入一个 DataFrame，同时指定参数 x 为 DataFrame 具体要绘制的某一列</li>
</ul>
<p>通过调用<code>plt.show()</code>可以把绘制好的图表进行展示</p>
<p>直方图（Histogram）的绘制：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sns.hisplot(s) </span><br><span class="line">sns.hisplot(df, x=<span class="string">&#x27;df中待绘图的列&#x27;</span>)</span><br><span class="line">plt.show() </span><br></pre></td></tr></table></figure>

<p>密度图（Kernel Density）的绘制：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sns.kdeplot(s)</span><br><span class="line">sns.kedplot(df, x=<span class="string">&#x27;df中待绘制的列&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>箱型图（Box Plot）的绘制：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sns.boxplot(s)</span><br><span class="line">sns.boxplot(df, x=<span class="string">&#x27;df中待绘制的列&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>小提琴图（Violin Plot）的绘制：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sns.violinplot(s)</span><br><span class="line">sns.violinplot(df, x=<span class="string">&#x27;df中待绘制的列&#x27;</span>)</span><br><span class="line">lpt.show()</span><br></pre></td></tr></table></figure>

<p>设置图表标题与标签：</p>
<p>通过调用<code>plt.title(&quot;图表标题&quot;)</code>即可完成对图表标题的设置，通过调用<code>plt.xlabel(&quot;x轴标签&quot;)</code>即可完成对 x 轴标签的设置，通过调用<code>plt.ylabel(&quot;y轴标签&quot;)</code>即可完成对 y 轴标签的设置</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plt.title(<span class="string">&quot;Adelie企鹅样本的嘴长度分布&quot;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;嘴长度（单位：mm）&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;样本数量&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="双变量图表绘制"><a href="#双变量图表绘制" class="headerlink" title="双变量图表绘制"></a><strong>双变量图表绘制</strong></h3><p>散点图（Scatter Plot）的绘制：</p>
<p>如果图表的自变量和因变量来自于同一个 df，可以用第一种形式实现；如果来自不同的 df，可以用第二种形式实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sns.scatterplot(data=df, x=<span class="string">&#x27;df中作为图表自变量的列&#x27;</span>, y=<span class="string">&#x27;df中作为图表因变量的列&#x27;</span>)</span><br><span class="line">sns.scatterplot(x=df[<span class="string">&#x27;df中作为图表自变量的列&#x27;</span>], y=df[<span class="string">&#x27;df中作为图表因变量的列&#x27;</span>])</span><br></pre></td></tr></table></figure>

<p>折线图（Line Plot）的绘制：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.lineplot(data=df, x=<span class="string">&#x27;df中作为图表自变量的列&#x27;</span>, y=<span class="string">&#x27;df中作为图表因变量的列&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>条形图（Bar Plot）的绘制：</p>
<p>条形图和直方图在形状相近，但是二者有明显区别，条形图的横轴表示的是不同的分类，纵轴表示的是每个分类对应的数值；而直方图的横轴表示的是一维数据的整体数据范围，纵轴表示的是每个数据 &#x2F; 数值范围出现的个数</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E4%BA%8C%E8%80%85%E5%8C%BA%E5%88%AB.png" alt="image-20250908120305489"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.barplot(data=df, x=[<span class="string">&#x27;作为横坐标的列&#x27;</span>], y=[<span class="string">&#x27;作为纵坐标的列&#x27;</span>])</span><br></pre></td></tr></table></figure>

<p>对于条形图而言，默认情况下，条柱的高度对应所属分类下的 y 对应所有值的<strong>平均值</strong>，如果我们想展示其他聚合值，可以设置<code>estimator</code>参数，将其赋值为 Pandas 库中其他常见的聚合函数，如<code>pd.max</code>，<code>pd.min</code>等</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.barplot(data=df, x=[<span class="string">&#x27;列0&#x27;</span>], y=[<span class="string">&#x27;列1&#x27;</span>], estimator=np.<span class="built_in">max</span>)</span><br></pre></td></tr></table></figure>

<p>使用实例：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E6%95%B0%E6%8D%AE%E6%9D%A5%E6%BA%90.png" alt="image-20250908120812507"></p>
<p>比如对于这份数据而言，我们如果要绘制条形图，横轴显然以企鹅种类为分类变量，纵轴则可以从嘴长度，嘴深度，鳍长度，体重这四列重进行选择</p>
<p>计数图（Count Plot）绘制：</p>
<p>计数图和条形图的形状类似，只不过计数图的纵轴表示的是每个分类中元素的个数，因此我们只需要传入横轴，指定作为分类变量的 df 列即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.countplot(data=df, x=[<span class="string">&#x27;作为分类变量的列&#x27;</span>])</span><br></pre></td></tr></table></figure>

<p>饼图（Pie Plot）的绘制：</p>
<p>seaborn 并不支持饼图的绘制，因此我们需要调用 matplotlib 进行绘制</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.pie(df[<span class="string">&#x27;待绘制的列&#x27;</span>])</span><br></pre></td></tr></table></figure>

<p>如果我们在参数中只传入一个要绘制成饼图的 Series（或者是 DataFrame 的一列），我们得到的饼图中是没有任何图标的，以下是对饼图的可视化：</p>
<ul>
<li>要指定每一部分的标签，我们可以设置<code>labels=[&#39;待作为标签的列&#39;]</code>来实现</li>
<li>要显示每一部分的比例，我们可以设置<code>autopct=&#39;%.2f%%&#39;</code>，其中字符串 %.2f%% 表示以百分制形式展示，且显示小数点后两位</li>
</ul>
<h3 id="图表颜色的配置"><a href="#图表颜色的配置" class="headerlink" title="图表颜色的配置"></a><strong>图表颜色的配置</strong></h3><p>对于折线图或散点图这种只有单一颜色的图表，我们可以通过给<code>sns.scatterplot()</code>中传入<code>color</code>参数进行设置，其中参数的值可以是表示颜色的字符串<code>&quot;red&quot;</code>等，也可以是表示颜色的 16 进制数码<code>&quot;#c287c7&quot;</code></p>
<p>对于条形图或饼图这种有多重颜色的图表，我们可以通过调整其<strong>色盘</strong>来实现颜色主题配置，色盘的配置可以通过系统设置函数<code>sns.set_palette()</code>实现，常见的色盘种类如 pastel（清新），creset（山色）等</p>
<h3 id="散点图2数值-1分类"><a href="#散点图2数值-1分类" class="headerlink" title="散点图2数值+1分类"></a><strong>散点图2数值+1分类</strong></h3><p>通过引入颜色代表不同的分类变量，我们可以通过设置<code>hue</code>参数（色调）的值引入不同的<strong>分类变量</strong>，在展示时即可针对不同分类按不同颜色的散点输出</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.scatterplot(data=df, x=<span class="string">&#x27;作为横轴的df列&#x27;</span>, y=<span class="string">&#x27;作为纵轴的df列&#x27;</span>, hue=<span class="string">&#x27;作为分类变量的df列&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>鸢尾花数据加按鸢尾花种类分类：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E8%89%B2%E8%B0%83.png" alt="image-20250908124613866"></p>
<p>我们通常把<code>hue</code>参数设置为<strong>分类变量</strong>，但是也可以将其设置为数值类型的变量，此时会按照不同的数值输出不同颜色的散点，如鸢尾花数据集按花瓣长度分类：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E6%95%B0%E5%80%BC%E5%88%86%E7%B1%BB.png" alt="image-20250908124823819"></p>
<h3 id="散点图3数值-1分类"><a href="#散点图3数值-1分类" class="headerlink" title="散点图3数值+1分类"></a><strong>散点图3数值+1分类</strong></h3><p>如果要在二维图像上分别额外支持一个分类变量和一个数值变量，我们不仅需要用<code>hue</code>参数通过颜色来表示分类变量，还需要设置<code>size</code>参数通过点的大小来表示数值变量</p>
<p>我们把<code>size</code>参数赋值为一个数值变量即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.scatterplot(df, x=<span class="string">&#x27;df作为横轴的列&#x27;</span>, y=<span class="string">&#x27;df作为纵轴的列&#x27;</span>, hue=<span class="string">&#x27;df作为分类变量的列&#x27;</span>, size=<span class="string">&#x27;df作为数值变量的列&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>鸢尾花数据加按鸢尾花种类和花瓣长度分别分类：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E5%A4%A7%E5%B0%8F%E5%92%8C%E8%89%B2%E8%B0%83.png" alt="image-20250908125028011"></p>
<h3 id="图例修改"><a href="#图例修改" class="headerlink" title="图例修改"></a><strong>图例修改</strong></h3><p>在上面的示意图中，图例的位置挡住了图像本身，我们需要调整图例的位置，可以通过<code>plt.legend()</code>中设置<code>bbox_to_anchor</code>实现，我们传入一个元组(a, b) 其中 a 和 b 取 0 或 1：</p>
<ul>
<li>a&#x3D;0 表示图例在图像左侧，a&#x3D;1 表示图例在图像右侧</li>
<li>b&#x3D;0 表示图例和图像偏下对齐，b&#x3D;1 表示图例和图像偏上对齐</li>
</ul>
<p>对下图而言，我们想把图例放在右上角，则可以传入元组 (1, 1)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E5%9B%BE%E4%BE%8B%E8%AE%BE%E7%BD%AE.png" alt="image-20250908125654075"></p>
<h3 id="折线图2数值-1分类"><a href="#折线图2数值-1分类" class="headerlink" title="折线图2数值+1分类"></a><strong>折线图2数值+1分类</strong></h3><p>和散点图处理完全相同，设置<code>hue</code>参数为目标分类变量即可</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E6%8A%98%E7%BA%BF%E5%9B%BE%E5%A4%9A%E5%8F%98%E9%87%8F.png" alt="image-20250908125838774"></p>
<h3 id="热力图"><a href="#热力图" class="headerlink" title="热力图"></a><strong>热力图</strong></h3><p>热力图天然就支持表示两个分类变量和一个数值变量，其中横轴和纵轴分别表示分类变量，数值变量由每个位置格点的<strong>颜色</strong>来表示</p>
<p>热力图（Heat Map）绘制：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.heatmap(data=df, x=[<span class="string">&#x27;df中的分类变量1&#x27;</span>], y=[<span class="string">&#x27;df中的分类变量2&#x27;</span>])</span><br></pre></td></tr></table></figure>

<p>实现如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E7%83%AD%E5%8A%9B%E5%9B%BE.png" alt="image-20250908155419363"></p>
<p>如果我们希望得到更加直观的展示，即每个位置显示具体的数值，可以通过设置<code>annot=True</code>参数实现</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.heatmap(df, x=[<span class="string">&#x27;作为横轴的分类变量&#x27;</span>], y=[<span class="string">&#x27;作为纵轴的分类变量&#x27;</span>], annot=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<h3 id="多张图同图展示"><a href="#多张图同图展示" class="headerlink" title="多张图同图展示"></a><strong>多张图同图展示</strong></h3><p>如果想在一张图表中绘制多张图像，可以通过多次调用<code>sns</code>绘制图像，最后在统一调用<code>plt.show()</code>即可，我们以同时展示鸢尾花数据集三个不同种类（setosa，versicolor，virginica）所对应的花瓣长度的直方图为例，进行展示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sns.hisplot(setosa[<span class="string">&#x27;petal_length&#x27;</span>], binwidth=<span class="number">0.1</span>， label=<span class="string">&quot;Setosa&quot;</span>)</span><br><span class="line">sns.hisplot(versicolor[<span class="string">&#x27;petal_length&#x27;</span>], binwidth=<span class="number">0.1</span>, label=<span class="string">&quot;versicolor&quot;</span>)</span><br><span class="line">sns.hisplot(virginica[<span class="string">&#x27;petal_length&#x27;</span>], binwidth=<span class="number">0.1</span>, label=<span class="string">&quot;virginica&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>多张图同时展示的两个参数：</p>
<ul>
<li>通过设置每张图的<code>binwidth</code>参数统一，我们可以使得三张直方图显示在同一张图表中时条柱的<strong>宽度</strong>相同，使得结果更加统一美观</li>
<li>通过设置每张图的<code>label</code>参数，我们可以为图表加上图例，指明每张图所描述的内容</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E5%A4%9A%E5%9B%BE%E5%B1%95%E7%A4%BA.png" alt="image-20250908160354681"></p>
<p>我们想展示图例（和 label 有关的内容）时，除了常规的<code>plt.show()</code>之外，还需要调用<code>plt.legend()</code>进行图例展示</p>
<p>如果我们想把直方图转化为密度图进行展示，也是同理的，只是密度图不再需要<code>binwidth</code>参数的设置</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sns.kdeplot(setosa[<span class="string">&#x27;petal_length&#x27;</span>], label=<span class="string">&quot;Setosa&quot;</span>)</span><br><span class="line">sns.kdeplot(versicolor[<span class="string">&#x27;petal_length&#x27;</span>], label=<span class="string">&quot;versicolor&quot;</span>)</span><br><span class="line">sns.kdeplot(virginica[<span class="string">&#x27;petal_length&#x27;</span>], label=<span class="string">&quot;virginica&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E5%AF%86%E5%BA%A6%E5%9B%BE.png" alt="image-20250908160659926"></p>
<p>如果我们想在同一张图中展示多张箱型图或者小提琴图，最好把<strong>横轴</strong>设置为分类变量，这样得到的图表美观清晰：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sns.boxplot(df, y=<span class="string">&quot;待展示的列&quot;</span>, x=<span class="string">&quot;分类变量列&quot;</span>)</span><br><span class="line">sns.violinplot(df, y=<span class="string">&quot;待展示的列&quot;</span>, x=<span class="string">&quot;分类变量列&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E5%A4%9A%E5%BC%A0%E5%B1%95%E7%A4%BA1.png" alt="image-20250908160948264"></p>
<h3 id="多张图并列展示"><a href="#多张图并列展示" class="headerlink" title="多张图并列展示"></a><strong>多张图并列展示</strong></h3><p>如果想把多张独立的图并列展示，我们需要调用<code>sns.subllots()</code>绘制子图的方法，先进行子图空间绘制，再进行填充，该函数接受两个参数 a b，分别表示子图的行数和列数，也就是说当前空间中会填入 a 行，每行有 b 张子图</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fig, axes = sns.subplots(<span class="number">1</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>如果我们想额外设置每个子图的宽和高，可以通过设置<code>figsize=(W,H)</code>实现，该参数接受一个元组，分别表示子图的宽度和高度</p>
<p>该函数返回两个值，分别为 fig 和 axes，其中 fig 表示大图整体，axes 表示大图中的每一张子图，我们常用到的返回值是 axes，该变量是一个 ndarray 类型的数组，其具体形状取决于<code>sns.subplots(a, b)</code>传入的参数 a 和 b</p>
<p>如果 a&#x3D;1，则 axes 为一个一维数组，如果 a!&#x3D;1，则 axes 为一个二维数组，我们通过数组的<strong>索引方式</strong>即可得到对应的每一张子图，如果我们想把某张图像填入子图中，在绘制目标图像时，设置其<code>ax</code>参数为对应的 axes 元素即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_, axes = sns.subplots(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">sns.boxplot(iris, x=<span class="string">&#x27;species&#x27;</span>, y=<span class="string">&#x27;speal_length&#x27;</span>, ax=axes[<span class="number">0</span>])</span><br><span class="line">sns.boxplot(iris, x=<span class="string">&#x27;species&#x27;</span>, y=<span class="string">&#x27;speal_width&#x27;</span>, ax=axes[<span class="number">1</span>])</span><br><span class="line">sns.boxplot(iris, x=<span class="string">&#x27;species&#x27;</span>, y=<span class="string">&#x27;petal_length&#x27;</span>, ax=axes[<span class="number">2</span>])</span><br></pre></td></tr></table></figure>

<p>展示如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/axes.png" alt="image-20250908162012682"></p>
<h3 id="配对图"><a href="#配对图" class="headerlink" title="配对图"></a><strong>配对图</strong></h3><p>通过调用<code>ssns.pairplot()</code>，传入某个 df，该方法会把 df 中所有数值变量两两之间的关系都进行绘制，假设 df 中有 N 个<strong>数值类型</strong>的变量，则会得到 N×N 张图作为输出结果</p>
<p>该方法支持以下参数：</p>
<ul>
<li><code>hue</code>：支持以某个分类变量进行分类展示</li>
<li><code>kind</code>：非对角线图类型，可以绘制直方图（hist），散点图（kde），核密度图（scatter）等，默认为散点图</li>
<li><code>diag_kind</code>：对角线图类型，可选参数同上，默认为直方图</li>
</ul>
<p>其中对角线图描述的是单个变量的分布情况，即某个变量和它分布位置之间的关系，而非对角线图描述的是两个不同变量之间的关系</p>
<h2 id="网页数据爬虫"><a href="#网页数据爬虫" class="headerlink" title="网页数据爬虫"></a><strong>网页数据爬虫</strong></h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a><strong>基本概念</strong></h3><p>网页数据爬虫的基本步骤：</p>
<ul>
<li>获取网页内容：通过代码给网站服务器发送请求，返回网页上的内容</li>
<li>解析网页内容：提取目标数据</li>
<li>储存或分析数据</li>
</ul>
<h3 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a><strong>HTTP请求</strong></h3><p>HTTP（Hypertext Transfer Protocol）又称为超文本传输协议，是一种客户端和服务器之间的请求-响应协议</p>
<p>常见的 HTTP 请求分为<code>get</code>和<code>post</code>两种，其中 get 方法用于获得数据，post 方法用于创建数据</p>
<p>一个完整的 HTTP 请求由请求行，请求头，请求体三部分所组成，而 HTTP 响应由状态行，响应头，响应体三部分所组成，需要注意的是状态码，如果返回 2 开头表示请求成功，返回 3 开头表示需要重定向，返回 4 开头表示客户端发生错误（比如 404），返回 5 开头表示服务器发生错误</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E7%8A%B6%E6%80%81%E7%A0%81.png" alt="image-20250908190955670"></p>
<h3 id="获取网页数据"><a href="#获取网页数据" class="headerlink" title="获取网页数据"></a><strong>获取网页数据</strong></h3><p>我们一般使用<code>requests</code>模块进行网页数据的获取，在使用时需要执行<code>import requests</code>进行模块导入</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br></pre></td></tr></table></figure>

<p>在网页数据获取时，我们可以调用<code>requests.get()</code>方法，传入一个代表网站 URL 地址的字符串，即可获得请求响应的实例，该方法会返回一个 Response 类型的实例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response = requests.get(<span class="string">&quot;https://books.toscrape.com/&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这里我们使用的网站<code>https://books.toscrape.com.</code>是一个专门用于爬虫数据训练的网站，此时<strong>响应体</strong> Response 中就会存储我们想要的网页数据</p>
<p>通过输出<code>response.status_code</code>参数，我们可以判断网页请求是否得到正确响应，如果值为 200 则说明正确响应，此外我们也可以通过<code>response.ok</code>是否为 True 进行判断</p>
<p>有时候一些网站只希望服务于正常的浏览器，同时忽略所有爬虫程序的请求，此时我们 HTTP 请求返回的状态码为 418，对于这种情况，我们可以通过设置<strong>请求头</strong>（headers）中的<strong>用户请求表</strong>（User-Agent），伪装正常的浏览器来避免此问题</p>
<p>对于 User-Agent 的设置，我们只关心其格式，而不关心其具体内容，因此我们可以从浏览器上任意获取一个 User-Agent 码，这里以 IE 浏览器为例进行演示：进入任意一个网页，右键选择检查，进入到网页源码，选择 Network(网络) 一栏，找到 Request Headers(请求标头)，找到 User-Agent 一栏，复制其内容即可</p>
<p>这里给出一个可用的 User-Agent：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mozilla/<span class="number">5.0</span> (Windows NT <span class="number">10.0</span>; Win64; x64) AppleWebKit/<span class="number">537.36</span> (KHTML, like Gecko) Chrome/<span class="number">127.0</span><span class="number">.0</span><span class="number">.0</span> Safari/<span class="number">537.36</span> Edg/<span class="number">127.0</span><span class="number">.0</span><span class="number">.0</span></span><br></pre></td></tr></table></figure>

<p>有了这个 User-Agent，我们就可以自定义一个请求头，并且把它传入到<code>requests.get()</code>的<code>headers</code>参数中，即可把我们的程序伪装成一个正常的浏览器，使得它能够正常访问网页</p>
<p>下面我们以豆瓣电影网页的访问为例进行演示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">headers = &#123;</span><br><span class="line">  <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/127.0.0.0 Safari/537.36 Edg/127.0.0.0&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">response = requests.get(<span class="string">&quot;https://movie.douban.com/top250&quot;</span>, headers=headers)</span><br><span class="line"><span class="keyword">if</span> response.ok:</span><br><span class="line">  <span class="built_in">print</span>(response.text)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;No!!!&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>此时我们通过调用<code>response.text</code>即可获得网页的源码</p>
<h3 id=""><a href="#" class="headerlink" title="****"></a>****</h3><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><p><strong>补充内容</strong></p>
<p><code>find_peaks()</code>函数：</p>
<p>该函数来自库<code>scipy.signals</code>，调用时需要先引入<code>from scipy.signals import find_peaks</code>，用于在一维信号中寻找局部最大值，也就是所谓的峰值，该函数通常接受以下几个参数：</p>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">类型</th>
<th align="center">作用</th>
<th align="center">示例（光谱分析场景）</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>x</code></td>
<td align="center">array</td>
<td align="center">输入信号</td>
<td align="center">反射率数据（<code>data[&quot;反射率&quot;].values</code>）</td>
</tr>
<tr>
<td align="center"><code>height</code></td>
<td align="center">float</td>
<td align="center">峰值最小高度</td>
<td align="center"><code>height=10</code>（忽略反射率&lt;10%的峰）</td>
</tr>
<tr>
<td align="center"><code>distance</code></td>
<td align="center">int</td>
<td align="center">相邻峰最小间隔</td>
<td align="center"><code>distance=10</code>（避免密集峰）</td>
</tr>
<tr>
<td align="center"><code>prominence</code></td>
<td align="center">float</td>
<td align="center">峰的最小突出度</td>
<td align="center"><code>prominence=0.5</code>（过滤噪声峰）</td>
</tr>
<tr>
<td align="center"><code>width</code></td>
<td align="center">float</td>
<td align="center">峰的最小宽度</td>
<td align="center"><code>width=3</code>（忽略窄峰）</td>
</tr>
<tr>
<td align="center"><code>wlen</code></td>
<td align="center">int</td>
<td align="center">计算突出度的窗口长度</td>
<td align="center"><code>wlen=50</code>（局部窗口波数范围）</td>
</tr>
</tbody></table>
<p>该函数有两个返回值，分别为 (peaks, properties)，其中 peaks 存储函数找到的每个波峰在原数组中的<strong>索引</strong>，即下标索引数组；properties 为一个字典，当上文中制定了对应的参数时，字典中会包含参数关键字（键）和每个波峰对应该参数值所构成的列表（值）对应的键值对</p>
<p><code>np.diff()</code>函数：该函数用于求一个数组相邻两个元素的差值，也就是差分函数，比如某数组为 [10, 20, 30, 400] 则得到的差分数组为 [20, 20, 370]</p>
<p><code>pd.to_numeric()</code>函数：该函数用于把 df 数据框的当前列转化为数值类型，其中<code>errors=&#39;coerce&#39;</code>表示遇到无法转换的值时设为 NaN，而不是报错</p>
<hr>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images/picture.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images/picture.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">Destiny</div><div class="post-copyright__author_desc">跋涉浮尘烛光灭</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://example.com/2025/09/06/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://example.com/2025/09/06/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/')">数据分析</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://example.com/2025/09/06/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=数据分析&amp;url=http://example.com/2025/09/06/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/&amp;pic=/../images/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A272.jpg" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">MyBlog</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/Python%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>Python与机器学习<span class="tagsPageCount">35</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="/../images/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2105.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/09/06/SQL/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A270.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">SQL</div></div></a></div><div class="next-post pull-right"><a href="/2025/09/10/RQVAE/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A273.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">VAE</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2025/09/24/(ML)%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/" title="聚类算法"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A292.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-09-24</div><div class="title">聚类算法</div></div></a></div><div><a href="/2025/09/15/(CNN)%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/" title="卷积神经网络基础"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A284.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-09-15</div><div class="title">卷积神经网络基础</div></div></a></div><div><a href="/2025/09/14/(NN)%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5%E8%A1%A5%E5%85%85/" title="神经网络补充概念"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A278.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-09-14</div><div class="title">神经网络补充概念</div></div></a></div><div><a href="/2025/09/14/(NN)%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/" title="梯度下降算法"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A277.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-09-14</div><div class="title">梯度下降算法</div></div></a></div><div><a href="/2025/08/11/(NN)%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5%E5%9F%BA%E7%A1%80/" title="神经网络基础概念"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A247.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-08-11</div><div class="title">神经网络基础概念</div></div></a></div><div><a href="/2025/08/20/(RNN)%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/" title="基础循环神经网络"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A256.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-08-20</div><div class="title">基础循环神经网络</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images/picture.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description"></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://bu.dusays.com/2023/05/13/645fa415e8694.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text">数据分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#DataFrame%E7%94%A8%E6%B3%95"><span class="toc-number">1.1.</span> <span class="toc-text">DataFrame用法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-DataFrame"><span class="toc-number">1.1.1.</span> <span class="toc-text">创建 DataFrame</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%80%BC%EF%BC%8C%E8%A1%8C%E7%B4%A2%E5%BC%95%EF%BC%8C%E5%88%97%E7%B4%A2%E5%BC%95"><span class="toc-number">1.1.2.</span> <span class="toc-text">获取值，行索引，列索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E8%A1%8C%E5%88%97%E5%90%8D%E7%A7%B0"><span class="toc-number">1.1.3.</span> <span class="toc-text">修改行列名称</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%BD%AE%E7%B4%A2%E5%BC%95"><span class="toc-number">1.1.4.</span> <span class="toc-text">重置索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E6%9F%90%E4%B8%80%E5%88%97%E4%BD%9C%E4%B8%BA%E7%B4%A2%E5%BC%95"><span class="toc-number">1.1.5.</span> <span class="toc-text">设置某一列作为索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8C%E5%88%97%E8%BD%AC%E7%BD%AE"><span class="toc-number">1.1.6.</span> <span class="toc-text">行列转置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%95%E7%A4%BA%E6%A0%B7%E6%9C%AC%E6%95%B0%E6%8D%AE"><span class="toc-number">1.1.7.</span> <span class="toc-text">展示样本数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E5%8F%96%E6%9F%90%E4%B8%80%E5%88%97"><span class="toc-number">1.1.8.</span> <span class="toc-text">提取某一列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E5%8F%96%E6%9F%90%E4%B8%80%E8%A1%8C"><span class="toc-number">1.1.9.</span> <span class="toc-text">提取某一行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E5%8F%96%E5%AD%90%E8%A1%A8%E6%A0%BC"><span class="toc-number">1.1.10.</span> <span class="toc-text">提取子表格</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%9B%E9%80%89%E7%AC%A6%E5%90%88%E6%9D%A1%E4%BB%B6%E7%9A%84%E8%A1%8C"><span class="toc-number">1.1.11.</span> <span class="toc-text">筛选符合条件的行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E6%88%96%E6%96%B0%E5%A2%9E%E6%9F%90%E4%B8%80%E5%88%97"><span class="toc-number">1.1.12.</span> <span class="toc-text">修改或新增某一列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E6%88%96%E6%9B%B4%E6%96%B0%E6%9F%90%E4%B8%80%E8%A1%8C"><span class="toc-number">1.1.13.</span> <span class="toc-text">修改或更新某一行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%9F%90%E4%B8%80%E8%A1%8C%E6%88%96%E6%9F%90%E4%B8%80%E5%88%97"><span class="toc-number">1.1.14.</span> <span class="toc-text">删除某一行或某一列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#axis%E8%BD%B4%E7%BA%BF"><span class="toc-number">1.1.15.</span> <span class="toc-text">axis轴线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DataFrame-%E7%9A%84%E8%BF%90%E7%AE%97"><span class="toc-number">1.1.16.</span> <span class="toc-text">DataFrame 的运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%BF%E6%92%AD%E6%9C%BA%E5%88%B6"><span class="toc-number">1.1.17.</span> <span class="toc-text">广播机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8C%E5%88%97%E7%BB%9F%E8%AE%A1"><span class="toc-number">1.1.18.</span> <span class="toc-text">行列统计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#descirbe%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.19.</span> <span class="toc-text">descirbe方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#apply%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.20.</span> <span class="toc-text">apply方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#apply-map%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.21.</span> <span class="toc-text">apply_map方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#value-counts%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.22.</span> <span class="toc-text">value_counts方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sort-values%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.23.</span> <span class="toc-text">sort_values方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Excel%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%8F%96"><span class="toc-number">1.2.</span> <span class="toc-text">Excel数据读取</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#xlsx%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96"><span class="toc-number">1.2.1.</span> <span class="toc-text">xlsx文件读取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#csv%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96"><span class="toc-number">1.2.2.</span> <span class="toc-text">csv文件读取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA"><span class="toc-number">1.2.3.</span> <span class="toc-text">读取结果展示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#xlsx%E5%92%8Ccsv%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.2.4.</span> <span class="toc-text">xlsx和csv相互转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BF%9D%E5%AD%98"><span class="toc-number">1.2.5.</span> <span class="toc-text">数据保存</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%AF%84%E4%BC%B0%E4%B8%8E%E6%B8%85%E6%B4%97"><span class="toc-number">1.3.</span> <span class="toc-text">数据评估与清洗</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%AF%84%E4%BC%B0%E4%BE%9D%E6%8D%AE"><span class="toc-number">1.3.1.</span> <span class="toc-text">数据评估依据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%84%E4%BC%B0%E4%B8%A2%E5%A4%B1%E6%95%B0%E6%8D%AE"><span class="toc-number">1.3.2.</span> <span class="toc-text">评估丢失数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%84%E4%BC%B0%E9%87%8D%E5%A4%8D%E6%95%B0%E6%8D%AE"><span class="toc-number">1.3.3.</span> <span class="toc-text">评估重复数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8C%E5%88%97%E7%B4%A2%E5%BC%95%E4%BF%AE%E6%94%B9"><span class="toc-number">1.3.4.</span> <span class="toc-text">行列索引修改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E8%A1%8C%E7%B4%A2%E5%BC%95"><span class="toc-number">1.3.5.</span> <span class="toc-text">设置行索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%BD%AE%E8%A1%8C%E7%B4%A2%E5%BC%95"><span class="toc-number">1.3.6.</span> <span class="toc-text">重置行索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E6%8E%92%E5%BA%8F"><span class="toc-number">1.3.7.</span> <span class="toc-text">索引排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E5%88%97%E6%8B%86%E5%88%86"><span class="toc-number">1.3.8.</span> <span class="toc-text">按列拆分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E5%88%97%E5%90%88%E5%B9%B6"><span class="toc-number">1.3.9.</span> <span class="toc-text">按列合并</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%BD%E6%95%B0%E6%8D%AE%E8%BD%AC%E9%95%BF%E6%95%B0%E6%8D%AE"><span class="toc-number">1.3.10.</span> <span class="toc-text">宽数据转长数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E8%A1%8C%E6%8B%86%E5%88%86"><span class="toc-number">1.3.11.</span> <span class="toc-text">按行拆分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E5%A4%B1%E5%80%BC%E5%A1%AB%E5%85%85"><span class="toc-number">1.3.12.</span> <span class="toc-text">缺失值填充</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E5%A4%B1%E5%80%BC%E5%88%A0%E9%99%A4"><span class="toc-number">1.3.13.</span> <span class="toc-text">缺失值删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%A4%8D%E6%95%B0%E6%8D%AE%E5%88%A0%E9%99%A4"><span class="toc-number">1.3.14.</span> <span class="toc-text">重复数据删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%97%E5%80%BC%E8%BF%9B%E8%A1%8C%E6%9B%BF%E6%8D%A2"><span class="toc-number">1.3.15.</span> <span class="toc-text">列值进行替换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.3.16.</span> <span class="toc-text">数据类型转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%95%B4%E7%90%86"><span class="toc-number">1.4.</span> <span class="toc-text">数据整理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#concat%E6%8B%BC%E6%8E%A5"><span class="toc-number">1.4.1.</span> <span class="toc-text">concat拼接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#merge%E5%90%88%E5%B9%B6"><span class="toc-number">1.4.2.</span> <span class="toc-text">merge合并</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#join%E5%90%88%E5%B9%B6"><span class="toc-number">1.4.3.</span> <span class="toc-text">join合并</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%BB%84%E8%81%9A%E5%90%88"><span class="toc-number">1.4.4.</span> <span class="toc-text">分组聚合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E6%A0%BC%E5%BD%A2%E7%8A%B6%E9%87%8D%E5%A1%91"><span class="toc-number">1.4.5.</span> <span class="toc-text">表格形状重塑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E7%BB%84%E5%90%88%E5%B9%B6"><span class="toc-number">1.4.6.</span> <span class="toc-text">子组合并</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%82%E6%AC%A1%E5%8C%96%E7%B4%A2%E5%BC%95%E5%B1%95%E5%B9%B3"><span class="toc-number">1.4.7.</span> <span class="toc-text">层次化索引展平</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#query%E8%8E%B7%E5%8F%96%E6%BB%A1%E8%B6%B3%E6%9D%A1%E4%BB%B6%E7%9A%84%E8%A1%8C"><span class="toc-number">1.4.8.</span> <span class="toc-text">query获取满足条件的行</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96"><span class="toc-number">1.5.</span> <span class="toc-text">数据可视化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%9B%BE%E8%A1%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.5.1.</span> <span class="toc-text">常用图表类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E5%8F%98%E9%87%8F%E5%9B%BE%E8%A1%A8%E7%BB%98%E5%88%B6"><span class="toc-number">1.5.2.</span> <span class="toc-text">单变量图表绘制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%8F%98%E9%87%8F%E5%9B%BE%E8%A1%A8%E7%BB%98%E5%88%B6"><span class="toc-number">1.5.3.</span> <span class="toc-text">双变量图表绘制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E8%A1%A8%E9%A2%9C%E8%89%B2%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="toc-number">1.5.4.</span> <span class="toc-text">图表颜色的配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%A3%E7%82%B9%E5%9B%BE2%E6%95%B0%E5%80%BC-1%E5%88%86%E7%B1%BB"><span class="toc-number">1.5.5.</span> <span class="toc-text">散点图2数值+1分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%A3%E7%82%B9%E5%9B%BE3%E6%95%B0%E5%80%BC-1%E5%88%86%E7%B1%BB"><span class="toc-number">1.5.6.</span> <span class="toc-text">散点图3数值+1分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E4%BE%8B%E4%BF%AE%E6%94%B9"><span class="toc-number">1.5.7.</span> <span class="toc-text">图例修改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%98%E7%BA%BF%E5%9B%BE2%E6%95%B0%E5%80%BC-1%E5%88%86%E7%B1%BB"><span class="toc-number">1.5.8.</span> <span class="toc-text">折线图2数值+1分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%83%AD%E5%8A%9B%E5%9B%BE"><span class="toc-number">1.5.9.</span> <span class="toc-text">热力图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E5%BC%A0%E5%9B%BE%E5%90%8C%E5%9B%BE%E5%B1%95%E7%A4%BA"><span class="toc-number">1.5.10.</span> <span class="toc-text">多张图同图展示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E5%BC%A0%E5%9B%BE%E5%B9%B6%E5%88%97%E5%B1%95%E7%A4%BA"><span class="toc-number">1.5.11.</span> <span class="toc-text">多张图并列展示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E5%AF%B9%E5%9B%BE"><span class="toc-number">1.5.12.</span> <span class="toc-text">配对图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E9%A1%B5%E6%95%B0%E6%8D%AE%E7%88%AC%E8%99%AB"><span class="toc-number">1.6.</span> <span class="toc-text">网页数据爬虫</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.6.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E8%AF%B7%E6%B1%82"><span class="toc-number">1.6.2.</span> <span class="toc-text">HTTP请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%BD%91%E9%A1%B5%E6%95%B0%E6%8D%AE"><span class="toc-number">1.6.3.</span> <span class="toc-text">获取网页数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.6.4.</span> <span class="toc-text">****</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#-1"><span class="toc-number">1.7.</span> <span class="toc-text"></span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/10/25/RLHF/" title="(一)RLHF_PPO"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2105.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="(一)RLHF_PPO"/></a><div class="content"><a class="title" href="/2025/10/25/RLHF/" title="(一)RLHF_PPO">(一)RLHF_PPO</a><time datetime="2025-10-25T02:45:26.000Z" title="发表于 2025-10-25 10:45:26">2025-10-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/10/23/%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90%E5%92%8C%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/" title="语义分析和代码生成">语义分析和代码生成</a><time datetime="2025-10-23T07:29:17.000Z" title="发表于 2025-10-23 15:29:17">2025-10-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/10/21/%EF%BC%88%E7%BC%96%E8%AF%91%EF%BC%89%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90%E5%92%8C%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/" title="语义分析和代码生成"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2103.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="语义分析和代码生成"/></a><div class="content"><a class="title" href="/2025/10/21/%EF%BC%88%E7%BC%96%E8%AF%91%EF%BC%89%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90%E5%92%8C%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/" title="语义分析和代码生成">语义分析和代码生成</a><time datetime="2025-10-21T08:31:25.000Z" title="发表于 2025-10-21 16:31:25">2025-10-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/10/21/(SQL)%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/" title="数据库设计"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2102.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据库设计"/></a><div class="content"><a class="title" href="/2025/10/21/(SQL)%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/" title="数据库设计">数据库设计</a><time datetime="2025-10-21T01:50:34.000Z" title="发表于 2025-10-21 09:50:34">2025-10-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/10/16/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90Day1/" title="算法设计与分析Day1"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2100.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="算法设计与分析Day1"/></a><div class="content"><a class="title" href="/2025/10/16/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90Day1/" title="算法设计与分析Day1">算法设计与分析Day1</a><time datetime="2025-10-16T14:11:44.000Z" title="发表于 2025-10-16 22:11:44">2025-10-16</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2025 By <a class="footer-bar-link" href="/" title="Destiny" target="_blank">Destiny</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">85</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">4</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" rel="external nofollow noreferrer" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener external nofollow noreferrer" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener external nofollow noreferrer" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><span> 分类</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/tags/"><span> 标签</span></a></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/LLM%E4%B8%8E%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/" style="font-size: 0.88rem;">LLM与强化学习<sup>1</sup></a><a href="/tags/Python%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="font-size: 0.88rem;">Python与机器学习<sup>35</sup></a><a href="/tags/editing/" style="font-size: 0.88rem;">editing<sup>1</sup></a><a href="/tags/%E4%B8%93%E4%B8%9A%E8%AF%BE/" style="font-size: 0.88rem;">专业课<sup>14</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 0.88rem;">算法<sup>29</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.6.14",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 Destiny 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/fireworks.min.js"></script><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>