<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>python-pandas | MyBlog</title><meta name="keywords" content="Python与机器学习"><meta name="author" content="Destiny"><meta name="copyright" content="Destiny"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="python-pandas"><meta name="application-name" content="python-pandas"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="python-pandas"><meta property="og:url" content="http://example.com/2025/07/23/python-pandas/index.html"><meta property="og:site_name" content="MyBlog"><meta property="og:description" content="pandas通过阅读本文，您可以大致了解 python 中有关 pandas 库和数据分析有关的简单用法 基本知识模块介绍这里我们主要用到的是pandas以及它会用到的若干基础库 pandas pandas 是一个用于数据分析和处理的强大 Python 库，它的核心数据结构是 DataFrame 和"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="http://example.com/images/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A221.jpg"><meta property="article:author" content="Destiny"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://example.com/images/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A221.jpg"><meta name="description" content="pandas通过阅读本文，您可以大致了解 python 中有关 pandas 库和数据分析有关的简单用法 基本知识模块介绍这里我们主要用到的是pandas以及它会用到的若干基础库 pandas pandas 是一个用于数据分析和处理的强大 Python 库，它的核心数据结构是 DataFrame 和"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="http://example.com/2025/07/23/python-pandas/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"/images/文章封面48.jpg"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: Destiny","link":"链接: ","source":"来源: MyBlog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'MyBlog',
  title: 'python-pandas',
  postAI: '',
  pageFillDescription: 'pandas, 基本知识, 模块介绍, pandas 读取 Excel 文件, DataFrame 结构, Series 结构, 基础操作, DataFrame 数据处理 amp 行列操作, 数据写入 Excel 文件, 合并多个 Excel 文件, 数据清洗与缺失值处理, 数据筛选与条件过滤, 缺失值处理, 特征工程, 数据标准化与归一化, 特征编码, 新特征的生成, 时序数据处理, 移动窗口和差分分析, 数据增强与生成, 数据增强, SMOTE, 特征选择, 相关性分析, 方差阈值法通过阅读本文您可以大致了解中有关库和数据分析有关的简单用法基本知识模块介绍这里我们主要用到的是以及它会用到的若干基础库是一个用于数据分析和处理的强大库它的核心数据结构是和一个二维矩阵可以类比或者数据库中的二维表格由行和列组成一个一维数组可以看成一个表格中的一个数据列是中专门用于读取格式的的文件依赖完成对类表格文件的读取是中专门用于读取格式的的文件依赖完成对类表格文件的读取读取文件我们可以使用读取文件假设我们有一个名为的文件其内容如下注意如果是使用编译器的话一定不要直接在界面通过创建文件此时创建的文件即便有合法的扩展名但因为不包含的数据结构无法被识别乘有效的文件空文件我们可以通过以下的代码对该文件进行读取使用读取文件显示前行数据该函数是提供的读取文件的函数我们传入文件名和参数其中用于解析较旧格式的文件方法用于显示的前行数据帮助我们快速查看数据内容我们可以传一个进去表示显示前行数据如果不传参数默认为前行而同理如果我们想解析格式较新的文件我们传入中的参数就要改成也就是写成下面的格式结构是中的核心数据结构之一它是一个二维的表格类似于表格每个都有行索引和列标签通过以下代码我们可以创建一个简单的结构定义一个字典表示表格中的数据将字典转换为直接使用的构造方法传入一个字典即可打印内容字典我们创建了一个字典其中每个键如代表一列数据每个键对应的值是一个列表表示这一列的所有数据该函数是提供的构造函数用于将字典转换为结构是中的一维数据结构类似于中的一列每个都有一个索引和一组数据通过以下代码我们可以创建一个简单的结构从中提取列作为一个显示我们使用列标签来提取中的某一列返回一个执行语句的输出结果中显示了的名称和数据类型这里是字符串注意是自带索引的如果我们打印对应的列每一行输出会自带当前行的索引下标从开始基础操作数据处理行列操作增加新列我们可以类似字典键值的形式直接向中添加一列新的数据比如性别增加一列数据表示这些人的性别显示更新后的新添加的一列数据会自动排在最后一列因此我们打印的结果每一列依次是最后才是删除指定列通过调用方法我们可以删除中的一列数据在方法内部我们可以指定来把当前列删除删除列显示更新后的提取指定列直接以列表形式给出我们要提取的列也就是在给出我们要提取的列标签标签之间用逗号分隔即可年龄身高收入元月年龄身高收入元月等价于下面这种写法行操作以下是中有关行的常见操作第一行第到第行不含第行索引为的行如果使用的是自定义索引删除指定行删除索引为的行删除多个行删除前行异常数据清除支持以列表推导式的形式筛选符合条件的行同时限制年龄且收入年龄收入元月找出异常点找出元婴期老祖年龄删除异常数据年龄收入元月身高按照条件删除行年龄删除年龄小于等于的行收入删除收入为的行姓名张三删除姓名为张三的行数据写入文件在中我们处理完数据有可能要把结果写回到一个新的文件中可以通过以下代码实现将保存到新的文件中数据已保存到提供的方法用于将保存到一个文件中这个参数表示不要将行索引保存到文件中也就是说最终的文件中只会有列索引不会有行索引文件内容如下合并多个文件在实际数据分析中有可能我们需要从多个文件中读取数据并且把他们合并到一个中在处理多数据来源的问题时就用到合并读取的功能多个读取能够合并的前提是他们具有相同的结构在此基础上我们才能进行合并假设我们所有的文件都处于路径下我们可以使用通配符来获取所有文件路径读取所有文件并合并为一个打印合并后的使用模块查找目录下的所有后缀为的文件返回一个文件路径的列表使用的函数读取每个文件这里指定引擎来处理文件如果是则同理使用引擎进行处理即可同时这我们遍历中的每一个文件本质上是列表推导式的应用将所有读取的合并为一个大的表示忽略原来的行索引重新生成连续的索引假设我们有三个文件内容分别为那么我们合并后得到的的结构大概如下数据清洗与缺失值处理在数据分析时如果我们获得的数据中含有异常值或者缺失值那么我们需要进行数据清洗以保证数据的质量处理缺失数据缺失值是指在数据集中某些字段没有数据这是常见的问题我们可以选择删除包含缺失值的行或者用其他值来填补缺失值比较常见的缺失值填补方法有平均值插值法牛顿插值法拉格朗日插值法下面我们给出一个平均值插值的例子也就是用已有数据的平均值来填写缺失位置上的数据示例数据假设从读取的查看原始数据原始数据填充缺失值填充缺失值后的数据删除包含缺失值的行删除缺失值后的数据这里我们进行缺失值填充的核心函数是函数我们需要传入一个字典字典的键就是中的键值就是每个键对应的缺失值我们用什么内容来填充其中和没法取平均值缺失的信息我们只能填写而可以通过平均值来填充我们有现成的方法取现有所有项的平均值即方法填充后的大致为我们也可以直接丢弃有缺失值的项也就是调用方法这样我们就只剩下这一列了数据筛选与条件过滤条件过滤有时候我们需要从大数据集中筛选符合特定条件的数据比如从所有人的集合中选出所有年龄岁的人我们可以通过类似容器切片的方式进行筛选示例数据筛选年龄大于岁的数据年龄大于岁的数据这是中常见的条件筛选方法它会返回一个新的其中只包含满足条件的行数据分组与聚合数据分组和聚合是数据分析中非常常见的操作我们用它从大数据集中提取总结性信息代码示例按城市分组并且计算平均年龄示例数据按城市分组并计算平均年龄按城市分组后的平均年龄按列分组然后计算每个组中列的平均值是中常用的函数常用于分组统计其返回新的也就是中只有只有两列每一行分别是城市该城市的平均年龄数据透视表数据透视表是一种将数据重新排列为易于分析的格式的工具常用于数据汇总和分析等领域代码示例创建数据透视表示例数据创建数据透视表按城市和性别汇总平均年龄数据透视表创建一个数据透视表按城市和性别分组计算每组的平均年龄可以和上文的分组进行比较可以认为是一维分组也就是只有一个分组依据而是二维分组通过两个维度的分组限定取交集确定每个组内的元素其分组的结果也是一个二维表格分组输出如下缺失值处理以中位数填充缺失值使用中位数填补异常值其中方法会返回一个和原格式相同的矩阵对应位置如果是缺失值则为如果不是缺失值则为如果再对其调用方法则会进行列求和返回每一个列标签下的缺失值的个数之和我们可以以遍历的方式遍历的每一列如果当前列的类型是整型或浮点型我们就尝试用中位数进行缺失值填写因为字符串或字符没法用中位数填写这里我们还是调用方法第一个参数表示用中位数填写第二个参数表示就填写在原中使用拉格朗日插值法填充缺失值通过构造一个通过所有已知数据点的多项式来估计缺失值拉格朗日插值函数以当前行为中心取前后各个非缺失点插值失败保持原值对每个数值列进行插值处理插值失败时跳过显示结果使用牛顿插值法填充缺失值通过构造差商表来建立插值多项式定义一个近似牛顿插值函数用代替使用低阶多项式进行拟合复制数据避免修改原始对每一列进行插值处理找出其他非缺失值的位置和值至少需要两个点才能插值拟合失败时跳过其中牛顿插值法和拉格朗日插值法的依据都是多项式拟合二者的选择依据如下数据质量高要求精确通过已知点拉格朗日数据有噪声需要平滑处理牛顿多项式拟合特征工程在机器学习中库可以实现特征工程数据清洗时序数据处理等数据增强和特征选择功能帮助我们处理大规模数据提供机器学习的高质量数据输入数据标准化与归一化标准化把数据按照均值为方差为的方式进行缩放可以类比概率论中的处理归一化把数据通过映射函数缩放到或者的范围内创建一个基础的字典并且构造成数据标准化数据归一化首先我们引用了中的两个库用来数据标准化用来数据归一化其中是我们把实例化得到的对象通过调用方法可以把原结构中一列做标准化对应的标准化公式为其中是均值是标准差而是我们把实例化得到的对象通过调用方法可以把原结构中的一列做归一化对应的归一化公式为该函数会先自动计算列的最小值和最大值然后对每个值引用归一化公式放缩到区间中这里我们分别对和进行标准化和归一化得到新列和对应输出结果如下特征编码对于分类变量比如性别中的和城市中的北京上海等机器学习无法直接处理这些以文本形式出现的数据必须转化为数值的形式常用的编码方式有将分类值转换为数字特征编码为每个分类值创建一个新的列独热编码特征编码通过调用把列转化为的类型再通过调用获取每个类别对应的数字编码结果存储在的新列中假设原始数据为转化后的数据会变成简单来讲会把每个类别映射为一个从开始的整数值独热编码通过调用对传入的的指定列进行独热编码其中指明要对列进行编码最后会为每个类别创建一个新的二进制列原始数据映射后的数据独热编码会增加数据的维度如果类别很多的时候会得到一个有列数很大的稀疏矩阵两种编码方式的对比特性编码方式整数编码二进制向量维度变化不增加维度增加维度每类一列序数关系可能引入虚假关系完全消除序数关系适用模型树形模型线性模型类别数量多时推荐使用不推荐使用内存消耗低高类别多时新特征的生成从现有特征中生成新特征可以提升模型的表现例如可以通过现有的日期特征生成年月日等新特征或者通过数值特征生成交互项也就是说我们可以通过中现有的特征进行加工处理的得到一些更有用的特征比如我们有价格列和收益列可以先自己用二者作比得到性价比列时序数据处理时间索引与重采样支持非常灵活的时间索引支持把字符串转换成日期格式并使用函数进行时间重采样时间重采样一般有两个关键操作创建时间索引按照时间频率重采样这里的重采样可以看成是使用时间索引作为的新索引以后再按照某个规则进行分组按天统计或按月统计等创建时间索引按月份重采样并计算平均值首先使用把中的列转化为中的类型可以识别多种日期格式如等转化后该列就变成对象支持时间操作接着使用把上面修改后的列作为的索引表示直接修改原有的而不需要返回新对象修改前格式修改后格式修改后的索引变成时间类型可以支持时间序列操作比如进行时间切片重采样这里我们对时间的重采样可以看成是先把数据以时间作为中的下标索引然后按照不同依据进行分组比如如果我们传入参数表示以月末为分组依据参数表示统计每个月的平均值作为月末的数值那么我们就会对数据按月统计每月的均值原始数据按照重采样后的数据原本我们的数据是按天给出的经过重采样以后变成按月给出相当于我们降低了时间列数据的频率这种重采样方式称为降采样与之对应的升高世界列数据频率的重采样被称为升采样以下是有关重采样的官方定义作为参考即可常用的重采样频率参数说明示例日历日每日每周每周日结束月结束每月最后一天季度结束每季度最后一天年结束每年最后一天每小时每小时每分钟每分钟每秒每秒工作日周一至周五每周工作日除了取平均值的方法我们也可以传入其他的聚合方法用来统计出其他信息方法说明适用场景均值温度价格等连续变量求和销售量访问量等计数数据取组内最后一个值股价收盘价取组内第一个值股价开盘价开高低收金融领域专用股票行情数据分析重采样示例不同起始点使用月初作为标签多种聚合填充缺失值上采样升采样从月数据到日数据移动窗口和差分分析移动窗口和差分分析是处理时序数据的常用方法能够平滑数据并捕捉变化趋势滚动平均滚动平均又称为移动平均用来平滑时间序列数据通过计算指定窗口大小内数据的平均值来消除短期波动突出长期趋势其中用于选择要计算的时间序列列表示创建窗口大小为的滚动窗口对象即使用当前观测值及其前个值共个作为窗口表示对每个窗口计算算术平均值如果原始数据如下所示经过滚动平均以后会得到如下的数据前两个位置窗口大小不足不会生成有效值一阶差分差分是一种将非平稳时间序列转换为平稳序列的方法通过计算当前观测值与前一观测值的差值来消除趋势和季节性其中表示选择要计算的时间序列列表示计算一阶差分不设置参数默认即等价于做操作这里的一阶差分就是我们数据结构与算法中用到的差分处理后数据其中通过向中传入参数为的数值也可以求解高阶差分其中滚动平均和差分这两个操作常结合起来使用先通过差分使序列平稳再通过滚动平均提取主要趋势数据增强与生成在数据不平衡或数据不足的情况下数据增强和生成是提高模型性能的有效手段可以与其他库如结合使用处理不平衡的数据问题数据增强可以通过添加噪声的方式对数据进行增强代码如下所示在数值特征中添加噪声在本段代码中我们尝试对中的收入列添加一个正态分布的随机噪声其中是收入列本身的值而则用于生成正态分布的随机噪声其中的三个参数分别表示均值噪声中心为不改变原始数据的中心趋势标准差噪声的波动幅度表示生成与数据框行数相同的噪声样本量也就是不多不少给列的每一行都加上一个随机噪声把二者直接相加即可把噪声叠加到原始数据上返回一个新列除了可以使用正态分布噪声之外还可以使用以下噪声模型均匀分布噪声泊松噪声适用于计数数据百分比噪声保持原始比例使用噪声一般有以下几个目的提高机器学习训练数据的多样性解决小样本数据不足问题提高模型的鲁棒性和泛化能力数据隐私保护在共享数据的同时保护个人敏感信息模拟现实场景测试算法对噪声的容忍度模拟数据采集过程中的测量误差评估系统在非理想条件下的表现称为合成少数类过采样技术可以用来解决类别不平衡问题的智能过采样技术它通过创造合成样本而非简单复制来增加少数类样本的数量类别不平衡问题当数据集中某些类别的样本数量远少于其他类别时大多数机器学习算法会偏向多数类对少数类的预测性能不佳技术通过在特征空间中少数类样本的近邻之间进行线性插值来创建新的合成样本而不是简单复制现有样本工作流程对于每个少数类样本找到其个近邻通常随机选择一个近邻在两者连线的位置上随机生成新样本重复上述操作直到达到所需的类别平衡代码示例生成模拟不平衡数据特征矩阵标签其中类较少进行过采样创建对象应用过采样原始数据集分布过采样后数据集分布导入库实现数据集分割工具准备数据特征矩阵包含和两列标签数组个类个类明显不平衡应用创建对象设置随机种子确保可复现性执行过采样返回平衡后的特征矩阵和标签输出结果统计原始数据各类别样本数统计过采样后各类别样本数这里我们的数据矩阵和标签之间其实没有特殊的对应关系只是我们为了体现类的不平衡性分配了两个标签个标签把写成或者都是完全可以的以代码中的和为例样本和标签对应的关系为样本索引标签我们执行以后新生成的和仍然保持同样的对应关系只是会增加少数类标签为的数量可能会变成下面的效果原始类样本原始类样本原始类样本生成的合成类样本与一一对应特征选择特征选择是提升模型性能和减少过拟合的重要步骤通过选择最有用的特征可以降低模型的复杂度并提高其泛化能力可以与等库结合进行特征选择相关性分析相关性分析是初步选择特征的重要工具的方法可以轻松计算数值特征之间的相关系数从而帮助我们去除冗余或高度相关的特征计算相关系数矩阵其中是一个类型的结构通过调用它本身的方法我们就可以得到这个中各列之间的相关系数矩阵我们还是以上面的为例假设其包含三列内容那么得到的相关系数矩阵可能如下如果想选择更直观的方式我们可以用热力图进行表示特征相关系数矩阵热力图方差阈值法使用的我们可以去除那些方差过小的特征这些特征通常对模型预测没有帮助换言之就是重复的数据对模型预测效果不大我们希望所有数据都是不同的也就是希望要尽可能大的方差创建方差阈值选择器设置阈值为应用选择器转换数据方差阈值法通过计算各个特征的方差移除方差低于指定阈值的特征基本假设是低方差特征包含的信息量少高方差特征可能包含更多有用信息注意处理后返回的结果会以数组的形式返回不再是的结构同时原始列的顺序会被保留方差受量纲影响大应先标准化数据方差阈值法是一种简单高效的特征初筛方法特别适合作为特征选择流程的第一步快速移除明显无信息的特征',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-07-28 21:57:46',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.4/img/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">MyBlog</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)" rel="external nofollow noreferrer">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><span> 分类</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/tags/"><span> 标签</span></a></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Python%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="font-size: 1.05rem;">Python与机器学习<sup>22</sup></a><a href="/tags/editing/" style="font-size: 1.05rem;">editing<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 1.05rem;">算法<sup>26</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/08/"><span class="card-archive-list-date">八月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">28</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/07/"><span class="card-archive-list-date">七月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">24</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);" rel="external nofollow noreferrer"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/Python%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" itemprop="url">Python与机器学习</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/Python%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>Python与机器学习</span></a></span></div></div><h1 class="post-title" itemprop="name headline">python-pandas</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2025-07-23T13:39:37.000Z" title="发表于 2025-07-23 21:39:37">2025-07-23</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2025-07-28T13:57:46.004Z" title="更新于 2025-07-28 21:57:46">2025-07-28</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为香波地群岛"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>香波地群岛</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="/../images/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A221.jpg"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://example.com/2025/07/23/python-pandas/"><header><a class="post-meta-categories" href="/categories/Python%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" itemprop="url">Python与机器学习</a><a href="/tags/Python%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" tabindex="-1" itemprop="url">Python与机器学习</a><h1 id="CrawlerTitle" itemprop="name headline">python-pandas</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">Destiny</span><time itemprop="dateCreated datePublished" datetime="2025-07-23T13:39:37.000Z" title="发表于 2025-07-23 21:39:37">2025-07-23</time><time itemprop="dateCreated datePublished" datetime="2025-07-28T13:57:46.004Z" title="更新于 2025-07-28 21:57:46">2025-07-28</time></header><h1 id="pandas"><a href="#pandas" class="headerlink" title="pandas"></a><strong>pandas</strong></h1><p>通过阅读本文，您可以大致了解 python 中有关 pandas 库和数据分析有关的简单用法</p>
<h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a><strong>基本知识</strong></h2><h3 id="模块介绍"><a href="#模块介绍" class="headerlink" title="模块介绍"></a><strong>模块介绍</strong></h3><p>这里我们主要用到的是<code>pandas</code>以及它会用到的若干基础库</p>
<p><strong>pandas</strong></p>
<p><code>pandas</code> 是一个用于数据分析和处理的强大 Python 库，它的核心数据结构是 DataFrame 和 Series</p>
<ul>
<li>DataFrame：一个二维矩阵，可以类比 Excel 或者数据库中的二维表格，由行和列组成</li>
<li>Series：一个一维数组，可以看成一个表格中的一个<strong>数据列</strong></li>
</ul>
<p><strong>xlrd</strong></p>
<p><code>xlrd</code>是 python 中专门用于读取 <strong>.xls</strong> 格式的 Excel 的文件，pandas 依赖 xlrd 完成对 .xls 类 Excel 表格文件的读取</p>
<p><strong>openpyxl</strong></p>
<p><code>openpyxl</code>是 python 中专门用于读取 <strong>.xlsx</strong> 格式的 Excel 的文件，pandas 依赖 openpyxl 完成对 .xlsx 类 Excel 表格文件的读取</p>
<h3 id="pandas-读取-Excel-文件"><a href="#pandas-读取-Excel-文件" class="headerlink" title="pandas 读取 Excel 文件"></a><strong>pandas 读取 Excel 文件</strong></h3><p>我们可以使用 pandas 读取 Excel 文件，假设我们有一个名为 eample.xls 的文件，其内容如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    Name  Age         City</span><br><span class="line"><span class="number">0</span>  Alice   <span class="number">25</span>     New York</span><br><span class="line"><span class="number">1</span>    Bob   <span class="number">30</span>  Los Angeles</span><br><span class="line"><span class="number">2</span> Charlie   <span class="number">35</span>     Chicago</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：如果是使用 vscode 编译器的话，一定不要直接在 vscode 界面通过 new file 创建 Excel 文件，此时创建的文件即便有合法的 Excel 扩展名，但因为不包含 Excel 的数据结构，无法被 pandas 识别乘有效的 Excel 文件（空文件）</p>
<p>我们可以通过以下的代码对该文件进行读取：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 pandas 读取 Excel 文件</span></span><br><span class="line">df = pd.read_excel(<span class="string">&#x27;example.xls&#x27;</span>, engine=<span class="string">&#x27;xlrd&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示前 5 行数据</span></span><br><span class="line"><span class="built_in">print</span>(df.head())</span><br></pre></td></tr></table></figure>

<ul>
<li><code>pd.read_excel()</code>：该函数是 pandas 提供的读取 Excel 文件的函数，我们传入文件名 example.xls 和 engine &#x3D; ‘xlrd’ 参数，其中 xlrd 用于解析较旧格式的 .xls 文件</li>
<li><code>df.head()</code>：head() 方法用于显示 DataFrame 的前 5 行数据，帮助我们快速查看数据内容，我们可以传一个 x 进去表示显示前 x 行数据，如果不传参数默认为前 5 行</li>
</ul>
<p>而同理，如果我们想解析格式较新的 .xlsx 文件，我们传入 pandas 中的 engine 参数就要改成 openpyxl，也就是写成下面的格式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df = pd.read_excel(<span class="string">&quot;example.xlsx&quot;</span>, engine=<span class="string">&quot;openpyxl&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(df.head())</span><br></pre></td></tr></table></figure>

<h3 id="DataFrame-结构"><a href="#DataFrame-结构" class="headerlink" title="DataFrame 结构"></a><strong>DataFrame 结构</strong></h3><p>DataFrame 是 <code>pandas</code> 中的核心数据结构之一，它是一个二维的表格，类似于 Excel 表格，每个 DataFrame 都有行索引和列标签</p>
<p>通过以下代码，我们可以创建一个简单的 DataFrame 结构：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个字典，表示表格中的数据</span></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;Name&#x27;</span>: [<span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Charlie&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;Age&#x27;</span>: [<span class="number">25</span>, <span class="number">30</span>, <span class="number">35</span>],</span><br><span class="line">    <span class="string">&#x27;City&#x27;</span>: [<span class="string">&#x27;New York&#x27;</span>, <span class="string">&#x27;Los Angeles&#x27;</span>, <span class="string">&#x27;Chicago&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将字典转换为 DataFrame，直接使用 DataFrame 的构造方法，传入一个字典即可</span></span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印 DataFrame 内容</span></span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure>

<ul>
<li>字典 <code>data</code>：我们创建了一个字典，其中每个键（如 <code>&#39;Name&#39;</code>）代表一列数据，每个键对应的值是一个列表，表示这一列的所有数据</li>
<li><code>pd.DataFrame(data)</code>：该函数是<code>pandas</code> 提供的 <code>DataFrame</code> 构造函数，用于将字典转换为 DataFrame</li>
</ul>
<h3 id="Series-结构"><a href="#Series-结构" class="headerlink" title="Series 结构"></a><strong>Series 结构</strong></h3><p>Series 是 <code>pandas</code> 中的一维数据结构，类似于 Excel 中的一列，每个 Series 都有一个索引和一组数据</p>
<p>通过以下代码，我们可以创建一个简单的 Series 结构：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从 DataFrame 中提取 &#x27;Name&#x27; 列，作为一个 Series</span></span><br><span class="line">names = df[<span class="string">&#x27;Name&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示 Series</span></span><br><span class="line"><span class="built_in">print</span>(names)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>df[&#39;Name&#39;]</code>：我们使用列标签 <code>&#39;Name&#39;</code> 来提取 <code>DataFrame</code> 中的某一列，返回一个 <code>Series</code></li>
<li>执行 print 语句的输出：<code>Name: Name, dtype: object</code>，结果中显示了 <code>Series</code> 的名称和数据类型（这里是字符串 <code>object</code>）</li>
</ul>
<p>注意 series 是自带索引的，如果我们打印 series 对应的列，每一行输出会自带当前行的索引下标（从 0 开始）</p>
<h2 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a><strong>基础操作</strong></h2><h3 id="DataFrame-数据处理-行列操作"><a href="#DataFrame-数据处理-行列操作" class="headerlink" title="DataFrame 数据处理 &amp; 行列操作"></a><strong>DataFrame 数据处理 &amp; 行列操作</strong></h3><p><strong>增加新列</strong></p>
<p>我们可以类似字典键 -&gt; 值的形式，直接向 DataFrame 中添加一列新的数据，比如性别：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 增加一列数据，表示这些人的性别</span></span><br><span class="line">df[<span class="string">&#x27;Gender&#x27;</span>] = [<span class="string">&#x27;Female&#x27;</span>, <span class="string">&#x27;Male&#x27;</span>, <span class="string">&#x27;Male&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示更新后的 DataFrame</span></span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure>

<p>新添加的一列数据会自动排在最后一列，因此我们打印的结果每一列依次是：Name，Age，City，最后才是 Gender</p>
<p><strong>删除指定列</strong></p>
<p>通过调用 drop 方法，我们可以删除 DataFrame 中的一列数据，在 drop 方法内部，我们可以指定 columns &#x3D; [] 来把当前列删除：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除 &#x27;City&#x27; 列</span></span><br><span class="line">df = df.drop(columns=[<span class="string">&#x27;City&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示更新后的 DataFrame</span></span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure>

<p><strong>提取指定列</strong></p>
<p>直接以列表形式给出我们要提取的列，也就是在 [] 给出我们要提取的列标签，标签之间用逗号分隔即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">numerical_columns = [<span class="string">&quot;年龄&quot;</span>, <span class="string">&quot;身高(cm)&quot;</span>, <span class="string">&quot;收入(元/月)&quot;</span>]</span><br><span class="line">df[[<span class="string">&quot;年龄&quot;</span>, <span class="string">&quot;身高(cm)&quot;</span>, <span class="string">&quot;收入(元/月)&quot;</span>]].head()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等价于下面这种写法</span></span><br><span class="line">df[numerical_columns].head()</span><br></pre></td></tr></table></figure>

<p><strong>行操作</strong></p>
<p>以下是 DataFrame 中有关行的常见操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">df.iloc[<span class="number">0</span>]           <span class="comment"># 第一行</span></span><br><span class="line">df.iloc[<span class="number">0</span>:<span class="number">3</span>]         <span class="comment"># 第1到第3行（不含第4行）</span></span><br><span class="line">df.loc[<span class="number">3</span>]            <span class="comment"># 索引为3的行（如果DataFrame使用的是自定义索引）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定行</span></span><br><span class="line">df = df.drop(index=<span class="number">3</span>)          <span class="comment"># 删除索引为3的行</span></span><br><span class="line">df = df.drop([<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>])        <span class="comment"># 删除多个行</span></span><br><span class="line">df = df.drop(df.index[<span class="number">0</span>:<span class="number">3</span>])    <span class="comment"># 删除前3行</span></span><br></pre></td></tr></table></figure>

<p><strong>异常数据清除</strong></p>
<p>DataFrame 支持以列表推导式的形式，筛选符合条件的行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 同时限制年龄 ≤ 100 且 收入 ≤ 20000</span></span><br><span class="line">df_filtered = df[(df[<span class="string">&quot;年龄&quot;</span>] &lt;= <span class="number">100</span>) &amp; (df[<span class="string">&quot;收入(元/月)&quot;</span>] &lt;= <span class="number">20000</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找出异常点(找出元婴期老祖)</span></span><br><span class="line">outliers = df[df[<span class="string">&quot;年龄&quot;</span>] &gt; <span class="number">100</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除异常数据</span></span><br><span class="line">df_filtered = df[</span><br><span class="line">    (df[<span class="string">&quot;年龄&quot;</span>] &lt;= <span class="number">100</span>) &amp;</span><br><span class="line">    (df[<span class="string">&quot;收入(元/月)&quot;</span>] &lt;= <span class="number">50000</span>) &amp;</span><br><span class="line">    (df[<span class="string">&quot;身高(cm)&quot;</span>] &gt;= <span class="number">100</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照条件删除行</span></span><br><span class="line">df = df[df[<span class="string">&#x27;年龄&#x27;</span>] &gt; <span class="number">20</span>]             <span class="comment"># 删除“年龄”小于等于20的行</span></span><br><span class="line">df = df[df[<span class="string">&#x27;收入&#x27;</span>] != <span class="number">0</span>]             <span class="comment"># 删除“收入”为0的行</span></span><br><span class="line">df = df[~df[<span class="string">&#x27;姓名&#x27;</span>].isin([<span class="string">&#x27;张三&#x27;</span>])]  <span class="comment"># 删除姓名为张三的行</span></span><br></pre></td></tr></table></figure>

<h3 id="数据写入-Excel-文件"><a href="#数据写入-Excel-文件" class="headerlink" title="数据写入 Excel 文件"></a><strong>数据写入 Excel 文件</strong></h3><p>在 python 中我们处理完数据，有可能要把结果写回到一个新的 Excel 文件中，可以通过以下代码实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将 DataFrame 保存到新的 Excel 文件中</span></span><br><span class="line">df.to_excel(<span class="string">&#x27;output.xlsx&#x27;</span>, index=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;数据已保存到 output.xlsx&quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>to_excel()</code>：<code>pandas</code> 提供的 <code>to_excel()</code> 方法用于将 DataFrame 保存到一个 Excel 文件中</li>
<li><code>index = False</code>：这个参数表示不要将行索引保存到文件中，也就是说，最终的 output.xlsx 文件中只会有列索引，不会有行索引，文件内容如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">     Name  Age  Gender</span><br><span class="line"><span class="number">0</span>     Alice   <span class="number">25</span>  Female</span><br><span class="line"><span class="number">1</span>       Bob   <span class="number">30</span>    Male</span><br><span class="line"><span class="number">2</span>   Charlie   <span class="number">35</span>    Male</span><br></pre></td></tr></table></figure>

<h3 id="合并多个-Excel-文件"><a href="#合并多个-Excel-文件" class="headerlink" title="合并多个 Excel 文件"></a><strong>合并多个 Excel 文件</strong></h3><p>在实际数据分析中，有可能我们需要从多个 Excel 文件中读取数据，并且把他们合并到一个 DataFrame 中，在处理多数据来源的问题时，就用到<strong>合并读取</strong>的功能</p>
<p>多个 Excel 读取能够合并的前提是他们具有<strong>相同的结构</strong>，在此基础上我们才能进行合并：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设我们所有的 Excel 文件都处于 data 路径下，我们可以使用通配符 * 来获取所有 .xls 文件路径</span></span><br><span class="line">file_list = glob.glob(<span class="string">&#x27;data/*.xls&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取所有文件并合并为一个 DataFrame</span></span><br><span class="line">df_list = [pd.read_excel(file, engine=<span class="string">&#x27;xlrd&#x27;</span>) <span class="keyword">for</span> file <span class="keyword">in</span> file_list]</span><br><span class="line">combined_df = pd.concat(df_list, ignore_index=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印合并后的 DataFrame</span></span><br><span class="line"><span class="built_in">print</span>(combined_df.head())</span><br></pre></td></tr></table></figure>

<ul>
<li><code>glob.glob(&#39;data/*.xls&#39;)</code>：使用 glob 模块查找 data 目录下的所有 后缀为 .xls 的文件，返回一个文件路径的列表</li>
<li><code>pd.read_excel(file, engine=&#39;xlrd&#39;)</code>：使用 pandas 的 read_excel 函数读取每个 Excel 文件，这里指定 xlrd 引擎来处理 .xls 文件，如果是 .xlsx 则同理使用 openpyxl 引擎进行处理即可，同时这我们遍历 file_list 中的每一个文件，本质上是<strong>列表推导式</strong>的应用</li>
<li><code>pd.concat(df_list, ignore_index=True)</code>：将所有读取的 DataFrame 合并为一个大的 DataFrame，ignore_index&#x3D;True 表示忽略原来的行索引，重新生成连续的索引</li>
</ul>
<p>假设我们有三个 Excel 文件，内容分别为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">File <span class="number">1</span>:</span><br><span class="line">    Name  Age         City</span><br><span class="line"><span class="number">0</span>  Alice   <span class="number">25</span>     New York</span><br><span class="line"></span><br><span class="line">File <span class="number">2</span>:</span><br><span class="line">    Name  Age         City</span><br><span class="line"><span class="number">0</span>    Bob   <span class="number">30</span>  Los Angeles</span><br><span class="line"></span><br><span class="line">File <span class="number">3</span>:</span><br><span class="line">    Name  Age         City</span><br><span class="line"><span class="number">0</span> Charlie   <span class="number">35</span>     Chicago</span><br></pre></td></tr></table></figure>

<p>那么我们合并后得到的 DataFrame 的结构大概如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    Name  Age         City</span><br><span class="line"><span class="number">0</span>     Alice   <span class="number">25</span>     New York</span><br><span class="line"><span class="number">1</span>       Bob   <span class="number">30</span>  Los Angeles</span><br><span class="line"><span class="number">2</span>   Charlie   <span class="number">35</span>     Chicago</span><br></pre></td></tr></table></figure>

<h3 id="数据清洗与缺失值处理"><a href="#数据清洗与缺失值处理" class="headerlink" title="数据清洗与缺失值处理"></a><strong>数据清洗与缺失值处理</strong></h3><p>在数据分析时，如果我们获得的数据中含有<strong>异常值</strong>或者<strong>缺失值</strong>，那么我们需要进行数据清洗，以保证数据的质量</p>
<p><strong>处理缺失数据</strong></p>
<p><strong>缺失值</strong>是指在数据集中某些字段没有数据，这是常见的问题，我们可以选择删除包含缺失值的行，或者用其他值来填补缺失值</p>
<p>比较常见的缺失值填补方法有：平均值插值法，牛顿插值法，拉格朗日插值法，下面我们给出一个平均值插值的例子，也就是用已有数据的平均值来填写缺失位置上的数据</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 示例数据，假设从 Excel 读取的 DataFrame</span></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;Name&#x27;</span>: [<span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Charlie&#x27;</span>, <span class="literal">None</span>],</span><br><span class="line">    <span class="string">&#x27;Age&#x27;</span>: [<span class="number">25</span>, <span class="literal">None</span>, <span class="number">35</span>, <span class="number">30</span>],</span><br><span class="line">    <span class="string">&#x27;City&#x27;</span>: [<span class="string">&#x27;New York&#x27;</span>, <span class="string">&#x27;Los Angeles&#x27;</span>, <span class="literal">None</span>, <span class="string">&#x27;Chicago&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看原始数据</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;原始数据:\n&quot;</span>, df)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 填充缺失值</span></span><br><span class="line">df_filled = df.fillna(&#123;<span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;unknown&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>: df[<span class="string">&#x27;Age&#x27;</span>].mean(), <span class="string">&#x27;City&#x27;</span>: <span class="string">&#x27;unknown&#x27;</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n填充缺失值后的数据:\n&quot;</span>, df_filled)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除包含缺失值的行</span></span><br><span class="line">df_dropped = df.dropna()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n删除缺失值后的数据:\n&quot;</span>, df_dropped)</span><br></pre></td></tr></table></figure>

<p>这里我们进行缺失值填充的核心函数是<code>df.dillna()</code>函数，我们需要传入一个字典，字典的键就是 DataFrame 中的键，值就是每个键对应的缺失值，我们用什么内容来填充</p>
<p>其中 Name 和 City 没法取平均值，缺失的信息我们只能填写 unknown，而 Age 可以通过平均值来填充，我们有现成的方法取现有 Age 所有项的平均值，即<code>df[&#39;age&#39;].mean()</code>方法</p>
<p>填充后的 df_filled 大致为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">      Name   Age         City</span><br><span class="line"><span class="number">0</span>     Alice  <span class="number">25.0</span>     New York</span><br><span class="line"><span class="number">1</span>       Bob  <span class="number">30.0</span>  Los Angeles</span><br><span class="line"><span class="number">2</span>   Charlie  <span class="number">35.0</span>      unknown</span><br><span class="line"><span class="number">3</span>   unknown  <span class="number">30.0</span>      Chicago</span><br></pre></td></tr></table></figure>

<p>我们也可以直接丢弃有缺失值的项，也就是调用<code>drppna()</code>方法，这样我们就只剩下 Alice 这一列了</p>
<h3 id="数据筛选与条件过滤"><a href="#数据筛选与条件过滤" class="headerlink" title="数据筛选与条件过滤"></a><strong>数据筛选与条件过滤</strong></h3><p><strong>条件过滤</strong></p>
<p>有时候我们需要从大数据集中筛选符合特定条件的数据，比如从所有人的集合中选出所有年龄 &gt; 30 岁的人</p>
<p>我们可以通过类似容器切片的方式进行筛选：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 示例数据</span></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;Name&#x27;</span>: [<span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Charlie&#x27;</span>, <span class="string">&#x27;David&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;Age&#x27;</span>: [<span class="number">25</span>, <span class="number">30</span>, <span class="number">35</span>, <span class="number">28</span>],</span><br><span class="line">    <span class="string">&#x27;City&#x27;</span>: [<span class="string">&#x27;New York&#x27;</span>, <span class="string">&#x27;Los Angeles&#x27;</span>, <span class="string">&#x27;Chicago&#x27;</span>, <span class="string">&#x27;San Francisco&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 筛选年龄大于 30 岁的数据</span></span><br><span class="line">filtered_df = df[df[<span class="string">&#x27;Age&#x27;</span>] &gt; <span class="number">30</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;年龄大于 30 岁的数据:\n&quot;</span>, filtered_df)</span><br></pre></td></tr></table></figure>

<p><code>df[df[‘Age’] &gt; 30]</code>：这是 <code>pandas</code> 中常见的条件筛选方法。它会返回一个新的 DataFrame，其中只包含满足条件（<code>Age &gt; 30</code>）的行</p>
<p><strong>数据分组与聚合</strong></p>
<p>数据分组和聚合是数据分析中非常常见的操作，我们用它从大数据集中提取总结性信息</p>
<p>代码示例：按城市分组，并且计算平均年龄</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 示例数据</span></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;Name&#x27;</span>: [<span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Charlie&#x27;</span>, <span class="string">&#x27;David&#x27;</span>, <span class="string">&#x27;Eva&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;Age&#x27;</span>: [<span class="number">25</span>, <span class="number">30</span>, <span class="number">35</span>, <span class="number">28</span>, <span class="number">40</span>],</span><br><span class="line">    <span class="string">&#x27;City&#x27;</span>: [<span class="string">&#x27;New York&#x27;</span>, <span class="string">&#x27;Los Angeles&#x27;</span>, <span class="string">&#x27;Chicago&#x27;</span>, <span class="string">&#x27;New York&#x27;</span>, <span class="string">&#x27;Chicago&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按城市分组并计算平均年龄</span></span><br><span class="line">grouped_df = df.groupby(<span class="string">&#x27;City&#x27;</span>)[<span class="string">&#x27;Age&#x27;</span>].mean()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;按城市分组后的平均年龄:\n&quot;</span>, grouped_df)</span><br></pre></td></tr></table></figure>

<p><code>df.groupby(‘City’)[‘Age’].mean()</code>：按 <code>City</code> 列分组，然后计算每个组中 <code>Age</code> 列的平均值，<code>groupby</code> 是 <code>pandas</code> 中常用的函数，常用于分组统计，其返回新的 DataFrame 也就是 grouped_df 中只有只有两列，每一行分别是城市 - 该城市的平均年龄：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">City</span><br><span class="line">Chicago         <span class="number">37.5</span></span><br><span class="line">Los Angeles     <span class="number">30.0</span></span><br><span class="line">New York        <span class="number">26.5</span></span><br><span class="line">Name: Age, dtype: float64</span><br></pre></td></tr></table></figure>

<p><strong>数据透视表</strong></p>
<p>数据透视表是一种将数据重新排列为易于分析的格式的工具，常用于数据汇总和分析等领域</p>
<p>代码示例：创建数据透视表</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 示例数据</span></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;Name&#x27;</span>: [<span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Charlie&#x27;</span>, <span class="string">&#x27;David&#x27;</span>, <span class="string">&#x27;Eva&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;Age&#x27;</span>: [<span class="number">25</span>, <span class="number">30</span>, <span class="number">35</span>, <span class="number">28</span>, <span class="number">40</span>],</span><br><span class="line">    <span class="string">&#x27;City&#x27;</span>: [<span class="string">&#x27;New York&#x27;</span>, <span class="string">&#x27;Los Angeles&#x27;</span>, <span class="string">&#x27;Chicago&#x27;</span>, <span class="string">&#x27;New York&#x27;</span>, <span class="string">&#x27;Chicago&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;Gender&#x27;</span>: [<span class="string">&#x27;Female&#x27;</span>, <span class="string">&#x27;Male&#x27;</span>, <span class="string">&#x27;Male&#x27;</span>, <span class="string">&#x27;Male&#x27;</span>, <span class="string">&#x27;Female&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建数据透视表，按城市和性别汇总平均年龄</span></span><br><span class="line">pivot_table = pd.pivot_table(df, values=<span class="string">&#x27;Age&#x27;</span>, index=<span class="string">&#x27;City&#x27;</span>, columns=<span class="string">&#x27;Gender&#x27;</span>, aggfunc=<span class="string">&#x27;mean&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;数据透视表:\n&quot;</span>, pivot_table)</span><br></pre></td></tr></table></figure>

<p><code>pd.pivot_table(df, values=‘Age’, index=‘City’, columns=‘Gender’, aggfunc=‘mean’)</code>：创建一个数据透视表，按城市和性别分组，计算每组的平均年龄</p>
<p>可以和上文的 groupby 分组进行比较，可以认为 groupby 是一维分组，也就是只有一个分组依据，而 pivot_table 是二维分组，通过两个维度的分组限定，取交集确定每个组内的元素，其分组的结果也是一个二维表格，分组输出如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Gender         Female   Male</span><br><span class="line">City                          </span><br><span class="line">Chicago         <span class="number">40.0</span>   <span class="number">35.0</span></span><br><span class="line">Los Angeles      NaN   <span class="number">30.0</span></span><br><span class="line">New York        <span class="number">25.0</span>   <span class="number">28.0</span></span><br></pre></td></tr></table></figure>

<h2 id="缺失值处理"><a href="#缺失值处理" class="headerlink" title="缺失值处理"></a><strong>缺失值处理</strong></h2><p>以中位数填充缺失值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">data = &#123;<span class="string">&#x27;Age&#x27;</span>:[<span class="number">10</span>, <span class="number">20</span>, <span class="literal">None</span>, <span class="number">40</span>], <span class="string">&#x27;Name&#x27;</span>:[<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Jack&quot;</span>, <span class="string">&quot;Anna&quot;</span>, <span class="string">&quot;John&quot;</span>], <span class="string">&#x27;Income&#x27;</span>:[<span class="literal">None</span>, <span class="number">200.00</span>, <span class="number">300.00</span>, <span class="number">500.0</span>]&#125;</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(df.isnull().<span class="built_in">sum</span>())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用中位数填补异常值</span></span><br><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> df.columns:</span><br><span class="line">    <span class="keyword">if</span> df[col].dtype <span class="keyword">in</span> [<span class="string">&#x27;float64&#x27;</span>, <span class="string">&#x27;int64&#x27;</span>]:  </span><br><span class="line">        df[col].fillna(df[col].median(), inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(df.isnull().<span class="built_in">sum</span>())</span><br></pre></td></tr></table></figure>

<p>其中<code>isnull()</code>方法会返回一个和原 DataFrame 格式相同的矩阵，对应 DataFrame 位置如果是缺失值，则为 True，如果不是缺失值，则为 False，如果再对其调用<code>sum()</code>方法则会进行列求和，返回每一个列标签下的缺失值的个数之和</p>
<p>我们可以以遍历<code>df.columns</code>的方式遍历 DataFrame 的每一列，如果当前列的类型是整型或浮点型，我们就尝试用中位数进行缺失值填写（因为字符串或字符没法用中位数填写），这里我们还是调用<code>fillna()</code>方法，第一个参数<code>df[col].median()</code>表示用<strong>中位数</strong>填写，第二个参数<code>inplace=True</code>表示就填写在原 df 中</p>
<p>使用<strong>拉格朗日插值法</strong>填充缺失值：通过构造一个通过所有已知数据点的多项式来估计缺失值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 拉格朗日插值函数（以当前行为中心，取前后各3个非缺失点）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lagrange_interp</span>(<span class="params">s, n, k=<span class="number">3</span></span>):</span><br><span class="line">    y = s[<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="built_in">max</span>(<span class="number">0</span>, n - k), n)) + <span class="built_in">list</span>(<span class="built_in">range</span>(n + <span class="number">1</span>, <span class="built_in">min</span>(<span class="built_in">len</span>(s), n + <span class="number">1</span> + k)))]</span><br><span class="line">    y = y[y.notnull()]</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(y) &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> lagrange(y.index, y.values)(n)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> s[n]  <span class="comment"># 插值失败，保持原值</span></span><br><span class="line"></span><br><span class="line">data = &#123;<span class="string">&#x27;Age&#x27;</span>:[<span class="number">10</span>, <span class="number">20</span>, <span class="literal">None</span>, <span class="number">40</span>], <span class="string">&#x27;Name&#x27;</span>:[<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Jack&quot;</span>, <span class="string">&quot;Anna&quot;</span>, <span class="string">&quot;John&quot;</span>], <span class="string">&#x27;Income&#x27;</span>:[<span class="literal">None</span>, <span class="number">200.00</span>, <span class="number">300.00</span>, <span class="number">500.0</span>]&#125;</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line">df_lagrange = df.copy()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对每个数值列进行插值处理</span></span><br><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> df_lagrange.columns:</span><br><span class="line">    <span class="keyword">if</span> df_lagrange[col].dtype <span class="keyword">in</span> [<span class="string">&#x27;float64&#x27;</span>, <span class="string">&#x27;int64&#x27;</span>]:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(df_lagrange)):</span><br><span class="line">            <span class="keyword">if</span> pd.isna(df_lagrange.loc[i, col]):</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    df_lagrange.loc[i, col] = lagrange_interp(df_lagrange[col], i)</span><br><span class="line">                <span class="keyword">except</span>:</span><br><span class="line">                    <span class="keyword">pass</span>  <span class="comment"># 插值失败时跳过</span></span><br><span class="line"><span class="comment"># 显示结果</span></span><br><span class="line"><span class="built_in">print</span>(df_lagrange.head())</span><br></pre></td></tr></table></figure>

<p>使用<strong>牛顿插值法</strong>填充缺失值：通过构造差商表来建立插值多项式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个近似牛顿插值函数（用 polyfit 代替）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">newton_interp</span>(<span class="params">x_known, y_known, x_target</span>):</span><br><span class="line">    <span class="comment"># 使用低阶多项式进行拟合（deg=3）</span></span><br><span class="line">    deg = <span class="built_in">min</span>(<span class="built_in">len</span>(x_known) - <span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">    coeffs = np.polyfit(x_known, y_known, deg)</span><br><span class="line">    poly = np.poly1d(coeffs)</span><br><span class="line">    <span class="keyword">return</span> poly(x_target)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制数据，避免修改原始 df</span></span><br><span class="line">data = &#123;<span class="string">&#x27;Age&#x27;</span>:[<span class="number">10</span>, <span class="number">20</span>, <span class="literal">None</span>, <span class="number">40</span>], <span class="string">&#x27;Name&#x27;</span>:[<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Jack&quot;</span>, <span class="string">&quot;Anna&quot;</span>, <span class="string">&quot;John&quot;</span>], <span class="string">&#x27;Income&#x27;</span>:[<span class="literal">None</span>, <span class="number">200.00</span>, <span class="number">300.00</span>, <span class="number">500.0</span>]&#125;</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line">df_interp = df.copy()</span><br><span class="line"><span class="comment"># 对每一列进行插值处理</span></span><br><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> df_interp.columns:</span><br><span class="line">    s = df_interp[col]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        <span class="keyword">if</span> pd.isna(s[i]):</span><br><span class="line">            <span class="comment"># 找出其他非缺失值的位置和值</span></span><br><span class="line">            x_known = [j <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)) <span class="keyword">if</span> j != i <span class="keyword">and</span> <span class="keyword">not</span> pd.isna(s[j])]</span><br><span class="line">            y_known = s[x_known]</span><br><span class="line">            <span class="comment"># 至少需要两个点才能插值</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(x_known) &gt; <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    s[i] = newton_interp(x_known, y_known, i)</span><br><span class="line">                <span class="keyword">except</span>:</span><br><span class="line">                    <span class="keyword">pass</span>  <span class="comment"># 拟合失败时跳过</span></span><br><span class="line"><span class="built_in">print</span>(df_interp.head())</span><br></pre></td></tr></table></figure>

<p>其中牛顿插值法和拉格朗日插值法的依据都是<strong>多项式拟合</strong>，二者的选择依据如下：</p>
<ul>
<li>数据质量高、要求精确通过已知点：拉格朗日</li>
<li>数据有噪声、需要平滑处理：牛顿（多项式拟合）</li>
</ul>
<h2 id="特征工程"><a href="#特征工程" class="headerlink" title="特征工程"></a><strong>特征工程</strong></h2><p>在机器学习中，pandas 库可以实现特征工程、数据清洗、时序数据处理等数据增强和特征选择功能，帮助我们处理大规模数据，提供机器学习的高质量数据输入</p>
<h3 id="数据标准化与归一化"><a href="#数据标准化与归一化" class="headerlink" title="数据标准化与归一化"></a><strong>数据标准化与归一化</strong></h3><p>标准化：把数据按照均值为 0 方差为 1 的方式进行缩放，可以类比概率论中 x - u &#x2F; σ 的处理</p>
<p>归一化： 把数据通过映射函数缩放到 [0, 1] 或者 [-1, 1] 的范围内</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler, MinMaxScaler</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个基础的字典，并且构造成 DataFrame</span></span><br><span class="line">data = &#123;<span class="string">&#x27;Name&#x27;</span>: [<span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Charlie&#x27;</span>, <span class="string">&#x27;Judy&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;Age&#x27;</span>: [<span class="number">25</span>, <span class="number">28</span>, <span class="number">35</span>, <span class="number">30</span>],</span><br><span class="line">        <span class="string">&#x27;Salary&#x27;</span>: [<span class="number">50000</span>, <span class="number">55000</span>, <span class="number">48000</span>, <span class="number">40000</span>]&#125;</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据标准化</span></span><br><span class="line">scaler = StandardScaler()</span><br><span class="line">df[<span class="string">&#x27;Salary_scaled&#x27;</span>] = scaler.fit_transform(df[[<span class="string">&#x27;Salary&#x27;</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据归一化</span></span><br><span class="line">minmax_scaler = MinMaxScaler()</span><br><span class="line">df[<span class="string">&#x27;Age_normalized&#x27;</span>] = minmax_scaler.fit_transform(df[[<span class="string">&#x27;Age&#x27;</span>]])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure>

<p>首先我们引用了<code>sklearn.processing</code>中的两个库，<code>StandardScaler</code>用来数据标准化，<code>MinMaxScaler</code>用来数据归一化</p>
<p>其中 scaler 是我们把 StandardScaler 实例化得到的对象，通过调用<code>fit_transform()</code>方法，可以把原 df 结构中 Salary 一列做<strong>标准化</strong>，对应的标准化公式为：<code>z = (x - μ) / σ</code>，其中μ是均值，σ是标准差</p>
<p>而 minmax_scaler 是我们把 MinMaxScaler 实例化得到的对象，通过调用<code>fit_transform()</code>方法，可以把原 df 结构中的 Age 一列做<strong>归一化</strong>，对应的归一化公式为：<code>x&#39; = (x - min) / (max - min)</code>，该函数会先自动计算 Age 列的最小值和最大值，然后对每个值引用归一化公式，放缩到 [0, 1] 区间中</p>
<p>这里我们分别对 Salary 和 Age 进行标准化和归一化，得到新列 Salary_scaled 和 Age_normalized，对应输出结果如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">      Name  Age  Salary  Salary_scaled  Age_normalized</span><br><span class="line"><span class="number">0</span>    Alice   <span class="number">25</span>   <span class="number">50000</span>       <span class="number">0.323921</span>             <span class="number">0.0</span></span><br><span class="line"><span class="number">1</span>      Bob   <span class="number">28</span>   <span class="number">55000</span>       <span class="number">1.249411</span>             <span class="number">0.3</span></span><br><span class="line"><span class="number">2</span>  Charlie   <span class="number">35</span>   <span class="number">48000</span>      -<span class="number">0.046274</span>             <span class="number">1.0</span></span><br><span class="line"><span class="number">3</span>     Judy   <span class="number">30</span>   <span class="number">40000</span>      -<span class="number">1.527058</span>             <span class="number">0.5</span></span><br></pre></td></tr></table></figure>

<h3 id="特征编码"><a href="#特征编码" class="headerlink" title="特征编码"></a><strong>特征编码</strong></h3><p>对于<strong>分类变量</strong>（比如性别中的 ♂ 和 ♀，城市中的北京、上海等），机器学习无法直接处理这些以<strong>文本形式</strong>出现的数据，必须转化为数值的形式，常用的编码方式有：</p>
<ol>
<li><strong>Label Encoding</strong>：将分类值转换为数字 - 特征编码</li>
<li><strong>One-Hot Encoding</strong>：为每个分类值创建一个新的列 - 独热编码</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Label Encoding</span></span><br><span class="line">df[<span class="string">&#x27;City_LabelEncoded&#x27;</span>] = df[<span class="string">&#x27;City&#x27;</span>].astype(<span class="string">&#x27;category&#x27;</span>).cat.codes</span><br><span class="line"></span><br><span class="line"><span class="comment"># One-Hot Encoding</span></span><br><span class="line">df_onehot = pd.get_dummies(df, columns=[<span class="string">&#x27;City&#x27;</span>])</span><br></pre></td></tr></table></figure>

<p><strong>特征编码</strong></p>
<p>Label Encoding 通过调用<code>astype(&#39;category&#39;)</code>把 City 列转化为 pandas 的 category 类型，再通过调用<code>cat.codes</code>获取每个类别对应的数字编码，结果存储在 df 的新列 City_LabeEncoded 中</p>
<p>假设原始数据为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   City</span><br><span class="line"><span class="number">0</span>  Beijing</span><br><span class="line"><span class="number">1</span>  Shanghai</span><br><span class="line"><span class="number">2</span>  Guangzhou</span><br><span class="line"><span class="number">3</span>  Beijing</span><br></pre></td></tr></table></figure>

<p>转化后的数据会变成：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   City       City_LabelEncoded</span><br><span class="line"><span class="number">0</span>  Beijing    <span class="number">0</span></span><br><span class="line"><span class="number">1</span>  Shanghai   <span class="number">1</span></span><br><span class="line"><span class="number">2</span>  Guangzhou  <span class="number">2</span></span><br><span class="line"><span class="number">3</span>  Beijing    <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>简单来讲，Label Encoding 会把每个类别映射为一个从 0 开始的整数值</p>
<p><strong>独热编码</strong></p>
<p>One-Hot Encoding 通过调用<code>get_dummies()</code>对传入的 DataFrame 的指定列进行独热编码，其中 columns &#x3D; [ ‘target’ ] 指明要对 target 列进行编码，最后会为每个类别创建一个<strong>新的二进制列</strong></p>
<p>原始数据：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   City</span><br><span class="line"><span class="number">0</span>  Beijing</span><br><span class="line"><span class="number">1</span>  Shanghai</span><br><span class="line"><span class="number">2</span>  Guangzhou</span><br><span class="line"><span class="number">3</span>  Beijing</span><br></pre></td></tr></table></figure>

<p>映射后的数据：独热编码会增加数据的维度，如果类别很多的时候，会得到一个有列数很大的<strong>稀疏矩阵</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   City_Beijing  City_Shanghai  City_Guangzhou</span><br><span class="line"><span class="number">0</span>             <span class="number">1</span>              <span class="number">0</span>               <span class="number">0</span></span><br><span class="line"><span class="number">1</span>             <span class="number">0</span>              <span class="number">1</span>               <span class="number">0</span></span><br><span class="line"><span class="number">2</span>             <span class="number">0</span>              <span class="number">0</span>               <span class="number">1</span></span><br><span class="line"><span class="number">3</span>             <span class="number">1</span>              <span class="number">0</span>               <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>两种编码方式的对比：</p>
<table>
<thead>
<tr>
<th align="center">特性</th>
<th align="center">Label Encoding</th>
<th align="center">One-Hot Encoding</th>
</tr>
</thead>
<tbody><tr>
<td align="center">编码方式</td>
<td align="center">整数编码</td>
<td align="center">二进制向量</td>
</tr>
<tr>
<td align="center">维度变化</td>
<td align="center">不增加维度</td>
<td align="center">增加维度（每类一列）</td>
</tr>
<tr>
<td align="center">序数关系</td>
<td align="center">可能引入虚假关系</td>
<td align="center">完全消除序数关系</td>
</tr>
<tr>
<td align="center">适用模型</td>
<td align="center">树形模型</td>
<td align="center">线性模型</td>
</tr>
<tr>
<td align="center">类别数量多时</td>
<td align="center">推荐使用</td>
<td align="center">不推荐使用</td>
</tr>
<tr>
<td align="center">内存消耗</td>
<td align="center">低</td>
<td align="center">高（类别多时）</td>
</tr>
</tbody></table>
<h3 id="新特征的生成"><a href="#新特征的生成" class="headerlink" title="新特征的生成"></a><strong>新特征的生成</strong></h3><p>从现有特征中生成<strong>新特征</strong>可以提升模型的表现，例如，可以通过现有的日期特征生成 <strong>年</strong>、<strong>月</strong>、<strong>日</strong>等新特征，或者通过数值特征生成交互项</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">&#x27;Income_per_Age&#x27;</span>] = df[<span class="string">&#x27;Salary&#x27;</span>] / df[<span class="string">&#x27;Age&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>也就是说，我们可以通过 DataFrame 中现有的特征，进行加工处理的，得到一些更有用的特征（比如我们有价格列和收益列，可以先自己用二者作比得到性价比列）</p>
<h2 id="时序数据处理"><a href="#时序数据处理" class="headerlink" title="时序数据处理"></a><strong>时序数据处理</strong></h2><p><strong>时间索引与重采样</strong></p>
<p>pandas 支持非常灵活的时间索引，支持把字符串转换成日期格式，并使用<code>resample()</code>函数进行时间重采样，时间重采样一般有两个关键操作：</p>
<ol>
<li>创建时间索引</li>
<li>按照时间频率重采样，这里的重采样可以看成是使用时间索引作为 DataFrame 的新索引以后，再按照某个规则进行分组（按天统计，或按月统计等）</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建时间索引</span></span><br><span class="line">df[<span class="string">&#x27;Date&#x27;</span>] = pd.to_datetime(df[<span class="string">&#x27;Date&#x27;</span>])</span><br><span class="line">df.set_index(<span class="string">&#x27;Date&#x27;</span>, inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按月份重采样并计算平均值</span></span><br><span class="line">df_monthly = df.resample(<span class="string">&#x27;M&#x27;</span>).mean()</span><br></pre></td></tr></table></figure>

<p>首先使用<code>pd.to_datetime(df[&#39;Date&#39;])</code>把 df 中的 Date 列转化为 pandas 中的 datetime 类型，pandas 可以识别多种日期格式（如’2023-01-01’, ‘01&#x2F;01&#x2F;2023’等），转化后该列就变成 Timestamp 对象，支持时间操作</p>
<p>接着使用<code>set_index(df[&#39;Date&#39;], inplace=True)</code>把上面修改后的 Date 列作为 DataFrame 的<strong>索引</strong>，inplace&#x3D;True 表示直接修改原有的 DataFrame，而不需要返回新对象</p>
<p>修改前 df 格式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">        Date  Value</span><br><span class="line"><span class="number">0</span>  <span class="number">2023</span>-01-01    <span class="number">100</span></span><br><span class="line"><span class="number">1</span>  <span class="number">2023</span>-01-02    <span class="number">150</span></span><br><span class="line"><span class="number">2</span>  <span class="number">2023</span>-01-03    <span class="number">200</span></span><br></pre></td></tr></table></figure>

<p>修改后 df 格式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">            Value</span><br><span class="line">Date             </span><br><span class="line"><span class="number">2023</span>-01-01    <span class="number">100</span></span><br><span class="line"><span class="number">2023</span>-01-02    <span class="number">150</span></span><br><span class="line"><span class="number">2023</span>-01-03    <span class="number">200</span></span><br></pre></td></tr></table></figure>

<p>修改后，DataFrame 的索引变成<strong>时间类型</strong>，可以支持时间序列操作（比如进行时间切片）</p>
<p><strong>重采样</strong></p>
<p>这里我们对时间的重采样可以看成是先把数据以时间作为 DataFrame 中的下标索引，然后按照不同依据进行分组，比如如果我们传入 M 参数表示以<strong>月末</strong>为分组依据，mean() 参数表示统计每个月的平均值作为月末的数值，那么我们就会对数据<strong>按月统计每月的均值</strong>：</p>
<p>原始数据：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">            Value</span><br><span class="line">Date             </span><br><span class="line"><span class="number">2023</span>-01-01    <span class="number">100</span></span><br><span class="line"><span class="number">2023</span>-01-02    <span class="number">150</span></span><br><span class="line"><span class="number">2023</span>-01-03    <span class="number">200</span></span><br><span class="line"><span class="number">2023</span>-02-01    <span class="number">120</span></span><br><span class="line"><span class="number">2023</span>-02-02    <span class="number">180</span></span><br></pre></td></tr></table></figure>

<p>按照<code>df_monthly = df.resample(&#39;M&#39;).mean()</code>重采样后的数据：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">            Value</span><br><span class="line">Date             </span><br><span class="line"><span class="number">2023</span>-01-<span class="number">31</span>    <span class="number">150</span>  <span class="comment"># (100+150+200)/3</span></span><br><span class="line"><span class="number">2023</span>-02-<span class="number">28</span>    <span class="number">150</span>  <span class="comment"># (120+180)/2</span></span><br></pre></td></tr></table></figure>

<p>原本我们的数据是<strong>按天</strong>给出的，经过重采样以后变成<strong>按月</strong>给出，相当于我们<strong>降低</strong>了时间列数据的频率，这种重采样方式称为降采样，与之对应的，升高世界列数据频率的重采样，被称为升采样</p>
<p>以下是有关重采样的官方定义，作为参考即可：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E9%87%8D%E9%87%87%E6%A0%B7%E5%AE%9A%E4%B9%89.png" alt="image-20250724160221651"></p>
<p><strong>常用的重采样频率</strong></p>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">说明</th>
<th align="center">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">‘D’</td>
<td align="center">日历日</td>
<td align="center">每日</td>
</tr>
<tr>
<td align="center">‘W’</td>
<td align="center">每周</td>
<td align="center">每周日结束</td>
</tr>
<tr>
<td align="center">‘M’</td>
<td align="center">月结束</td>
<td align="center">每月最后一天</td>
</tr>
<tr>
<td align="center">‘Q’</td>
<td align="center">季度结束</td>
<td align="center">每季度最后一天</td>
</tr>
<tr>
<td align="center">‘A’</td>
<td align="center">年结束</td>
<td align="center">每年最后一天</td>
</tr>
<tr>
<td align="center">‘H’</td>
<td align="center">每小时</td>
<td align="center">每小时</td>
</tr>
<tr>
<td align="center">‘T’</td>
<td align="center">每分钟</td>
<td align="center">每分钟</td>
</tr>
<tr>
<td align="center">‘S’</td>
<td align="center">每秒</td>
<td align="center">每秒</td>
</tr>
<tr>
<td align="center">‘B’</td>
<td align="center">工作日（周一至周五）</td>
<td align="center">每周工作日</td>
</tr>
</tbody></table>
<p>除了取平均值的 means 方法，我们也可以传入其他的<strong>聚合方法</strong>，用来统计出其他信息：</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">说明</th>
<th align="center">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>.mean()</code></td>
<td align="center">均值</td>
<td align="center">温度、价格等连续变量</td>
</tr>
<tr>
<td align="center"><code>.sum()</code></td>
<td align="center">求和</td>
<td align="center">销售量、访问量等计数数据</td>
</tr>
<tr>
<td align="center"><code>.last()</code></td>
<td align="center">取组内最后一个值</td>
<td align="center">股价收盘价</td>
</tr>
<tr>
<td align="center"><code>.first()</code></td>
<td align="center">取组内第一个值</td>
<td align="center">股价开盘价</td>
</tr>
<tr>
<td align="center"><code>.ohlc()</code></td>
<td align="center">开高低收（金融领域专用）</td>
<td align="center">股票行情数据分析</td>
</tr>
</tbody></table>
<p><strong>重采样示例</strong></p>
<ul>
<li>不同起始点：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.resample(<span class="string">&#x27;M&#x27;</span>, label=<span class="string">&#x27;left&#x27;</span>).mean()  <span class="comment"># 使用月初作为标签</span></span><br></pre></td></tr></table></figure>

<ul>
<li>多种聚合：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.resample(<span class="string">&#x27;M&#x27;</span>).agg([<span class="string">&#x27;mean&#x27;</span>, <span class="string">&#x27;sum&#x27;</span>, <span class="string">&#x27;count&#x27;</span>])</span><br></pre></td></tr></table></figure>

<ul>
<li>填充缺失值：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.resample(<span class="string">&#x27;D&#x27;</span>).asfreq().fillna(method=<span class="string">&#x27;ffill&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>上采样（升采样）：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.resample(<span class="string">&#x27;D&#x27;</span>).mean()  <span class="comment"># 从月数据到日数据</span></span><br></pre></td></tr></table></figure>

<h2 id="移动窗口和差分分析"><a href="#移动窗口和差分分析" class="headerlink" title="移动窗口和差分分析"></a><strong>移动窗口和差分分析</strong></h2><p>移动窗口和差分分析是处理时序数据的常用方法，能够平滑数据并捕捉变化趋势</p>
<p><strong>滚动平均</strong></p>
<p>滚动平均又称为移动平均，用来平滑时间序列数据，通过计算指定窗口大小内数据的平均值来消除短期波动，突出长期趋势</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">&#x27;Rolling_Mean&#x27;</span>] = df[<span class="string">&#x27;Value&#x27;</span>].rolling(window=<span class="number">3</span>).mean()</span><br></pre></td></tr></table></figure>

<p>其中<code>df[&#39;Value&#39;]</code>用于选择要计算的时间序列列，<code>.rolling(window=3)</code>表示创建窗口大小为3的滚动窗口对象，即使用当前观测值及其前2个值（共3个）作为窗口，<code>.mean()</code>表示对每个窗口计算算术平均值</p>
<p>如果原始数据如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   Value</span><br><span class="line"><span class="number">0</span>     <span class="number">10</span></span><br><span class="line"><span class="number">1</span>     <span class="number">20</span></span><br><span class="line"><span class="number">2</span>     <span class="number">30</span></span><br><span class="line"><span class="number">3</span>     <span class="number">40</span></span><br><span class="line"><span class="number">4</span>     <span class="number">50</span></span><br></pre></td></tr></table></figure>

<p>经过滚动平均以后会得到如下的数据（前两个位置窗口大小不足 3，不会生成有效值）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   Value  Rolling_Mean</span><br><span class="line"><span class="number">0</span>     <span class="number">10</span>           NaN  </span><br><span class="line"><span class="number">1</span>     <span class="number">20</span>           NaN</span><br><span class="line"><span class="number">2</span>     <span class="number">30</span>          <span class="number">20.0</span></span><br><span class="line"><span class="number">3</span>     <span class="number">40</span>          <span class="number">30.0</span></span><br><span class="line"><span class="number">4</span>     <span class="number">50</span>          <span class="number">40.0</span></span><br></pre></td></tr></table></figure>

<p><strong>一阶差分</strong></p>
<p>差分是一种将非平稳时间序列转换为平稳序列的方法，通过计算当前观测值与前一观测值的差值来消除趋势和季节性</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">&#x27;Diff&#x27;</span>] = df[<span class="string">&#x27;Value&#x27;</span>].diff()</span><br></pre></td></tr></table></figure>

<p>其中<code>df[&#39;Value&#39;]</code>表示选择要计算的时间序列列，&#96;&#96;diff()<code>表示计算一阶差分（不设置 periods 参数默认periods=1），即等价于做</code>df[‘Value’] - df[‘Value’].shift(1)&#96;操作</p>
<p>这里的一阶差分就是我们数据结构与算法中用到的差分：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   Value   </span><br><span class="line"><span class="number">0</span>     <span class="number">10</span></span><br><span class="line"><span class="number">1</span>     <span class="number">20</span></span><br><span class="line"><span class="number">2</span>     <span class="number">30</span></span><br><span class="line"><span class="number">3</span>     <span class="number">40</span></span><br><span class="line"><span class="number">4</span>     <span class="number">50</span></span><br></pre></td></tr></table></figure>

<p>处理后数据：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   Value  Diff</span><br><span class="line"><span class="number">0</span>     <span class="number">10</span>   NaN</span><br><span class="line"><span class="number">1</span>     <span class="number">20</span>  <span class="number">10.0</span></span><br><span class="line"><span class="number">2</span>     <span class="number">30</span>  <span class="number">10.0</span></span><br><span class="line"><span class="number">3</span>     <span class="number">40</span>  <span class="number">10.0</span></span><br><span class="line"><span class="number">4</span>     <span class="number">50</span>  <span class="number">10.0</span></span><br></pre></td></tr></table></figure>

<p>其中通过向 diff() 中传入 periods 参数为 &gt;1 的数值，也可以求解高阶差分</p>
<p>其中滚动平均和差分这两个操作常结合起来使用，先通过差分使序列平稳，再通过滚动平均提取主要趋势</p>
<h2 id="数据增强与生成"><a href="#数据增强与生成" class="headerlink" title="数据增强与生成"></a><strong>数据增强与生成</strong></h2><p>在数据不平衡或数据不足的情况下，<strong>数据增强</strong>和<strong>生成</strong>是提高模型性能的有效手段，Pandas 可以与其他库如 <strong>imbalanced-learn</strong> 结合使用，处理不平衡的数据问题</p>
<h3 id="数据增强"><a href="#数据增强" class="headerlink" title="数据增强"></a><strong>数据增强</strong></h3><p>可以通过添加噪声的方式对数据进行增强，代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在数值特征中添加噪声</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">df[<span class="string">&#x27;Income_with_noise&#x27;</span>] = df[<span class="string">&#x27;Income&#x27;</span>] + np.random.normal(<span class="number">0</span>, <span class="number">1000</span>, <span class="built_in">len</span>(df))</span><br><span class="line"><span class="built_in">print</span>(df)</span><br></pre></td></tr></table></figure>

<p>在本段代码中，我们尝试对 df 中的 <strong>Income 收入</strong>列添加一个正态分布的随机噪声，其中 df [ ‘Income’ ] 是收入列本身的值，而<code>np.random.normal()</code>则用于生成正态分布的随机噪声，其中的三个参数分别表示：</p>
<ol>
<li>0 - 均值（噪声中心为 0，不改变原始数据的中心趋势）</li>
<li>1000 - 标准差（噪声的波动幅度）</li>
<li>len(df) - 表示生成与数据框行数相同的噪声样本量，也就是不多不少给 income 列的每一行都加上一个随机噪声</li>
</ol>
<p>把二者直接<strong>相加</strong>，即可把噪声叠加到原始数据上，返回一个新列 <strong>Income_with_noise</strong></p>
<p>除了可以使用正态分布噪声之外，还可以使用以下噪声模型：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 均匀分布噪声</span></span><br><span class="line">np.random.uniform(-<span class="number">1000</span>, <span class="number">1000</span>, <span class="built_in">len</span>(df))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 泊松噪声（适用于计数数据）</span></span><br><span class="line">np.random.poisson(<span class="number">100</span>, <span class="built_in">len</span>(df))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 百分比噪声（保持原始比例）</span></span><br><span class="line">df[<span class="string">&#x27;Income&#x27;</span>] * (<span class="number">1</span> + np.random.normal(<span class="number">0</span>, <span class="number">0.1</span>, <span class="built_in">len</span>(df)))</span><br></pre></td></tr></table></figure>

<p>使用噪声一般有以下几个目的：</p>
<ol>
<li>提高机器学习训练数据的多样性，解决小样本数据不足问题，提高模型的鲁棒性和泛化能力</li>
<li>数据隐私保护：在共享数据的同时保护个人敏感信息</li>
<li>模拟现实场景：测试算法对噪声的容忍度，模拟数据采集过程中的测量误差，评估系统在非理想条件下的表现</li>
</ol>
<h2 id="SMOTE"><a href="#SMOTE" class="headerlink" title="SMOTE"></a><strong>SMOTE</strong></h2><p>SOMOTE 称为合成少数类过采样技术，可以用来解决<strong>类别不平衡问题</strong>的智能过采样技术，它通过<strong>创造合成样本</strong>而非简单复制来增加少数类样本的数量</p>
<p>类别不平衡问题：当数据集中某些类别的样本数量远少于其他类别时，大多数机器学习算法会偏向多数类，对少数类的预测性能不佳</p>
<p>SMOTE 技术：通过在特征空间中少数类样本的<strong>近邻</strong>之间进行<strong>线性插值</strong>来创建新的合成样本，而不是简单复制现有样本</p>
<p>SMOTE 工作流程：</p>
<ol>
<li>对于每个少数类样本，找到其 k 个近邻，通常 k &#x3D; 5</li>
<li>随机选择一个近邻</li>
<li>在两者连线的位置上随机生成新样本</li>
<li>重复上述操作直到达到所需的类别平衡</li>
</ol>
<p>代码示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> imblearn.over_sampling <span class="keyword">import</span> SMOTE</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成模拟不平衡数据</span></span><br><span class="line">X = df[[<span class="string">&#x27;Income&#x27;</span>, <span class="string">&#x27;After_Tax_Income&#x27;</span>]].values  <span class="comment"># 特征矩阵</span></span><br><span class="line">y = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]  <span class="comment"># 标签，其中 1 类较少</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行 SMOTE 过采样</span></span><br><span class="line">sm = SMOTE(random_state=<span class="number">42</span>)  <span class="comment"># 创建SMOTE对象</span></span><br><span class="line">X_res, y_res = sm.fit_resample(X, y)  <span class="comment"># 应用过采样</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;原始数据集分布:&quot;</span>, np.bincount(y))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;过采样后数据集分布:&quot;</span>, np.bincount(y_res))</span><br></pre></td></tr></table></figure>

<p>导入库：<br>    <code>imblearn.over_sampling.SMOTE</code>：SMOTE实现<br>    <code>sklearn.model_selection.train_test_split</code>：数据集分割工具</p>
<p>准备数据：<br>    <code>X</code>：特征矩阵（包含 ‘Income’ 和 ‘After_Tax_Income’ 两列）<br>    <code>y</code>：标签数组（2个 0 类，1个 1 类，明显不平衡）</p>
<p>应用SMOTE：<br>    <code>SMOTE(random_state=42)</code>：创建 SMOTE 对象，设置随机种子确保可复现性<br>    <code>fit_resample(X, y)</code>：执行过采样，返回平衡后的特征矩阵和标签</p>
<p>输出结果：<br>    <code>np.bincount(y)</code>：统计原始数据各类别样本数<br>    <code>np.bincount(y_res)</code>：统计过采样后各类别样本数</p>
<p>这里我们的数据矩阵 X 和标签 y 之间其实没有特殊的对应关系，只是我们为了体现类的不平衡性，分配了两个 0 标签，1 个 1 标签，把 y 写成 [0 1 0] 或者 [1 0 0] 都是完全可以的</p>
<p>以代码中的 X 和 y 为例，样本和标签对应的关系为：</p>
<table>
<thead>
<tr>
<th align="center">样本索引</th>
<th align="center">X[0] (Income)</th>
<th align="center">X[1] (After_Tax_Income)</th>
<th align="center">y (标签)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">50000</td>
<td align="center">40000</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">80000</td>
<td align="center">60000</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">120000</td>
<td align="center">90000</td>
<td align="center">1</td>
</tr>
</tbody></table>
<p>我们执行<code>X_res, y_res = sm.fit_resample(X, y)</code>以后，新生成的 x_res 和 y_res 仍然保持同样的对应关系，只是会增加少数类（标签为 1）的数量，可能会变成下面的效果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">X_res = [</span><br><span class="line">    [<span class="number">50000</span>, <span class="number">40000</span>],  <span class="comment"># 原始0类样本1</span></span><br><span class="line">    [<span class="number">80000</span>, <span class="number">60000</span>],  <span class="comment"># 原始0类样本2</span></span><br><span class="line">    [<span class="number">120000</span>, <span class="number">90000</span>], <span class="comment"># 原始1类样本</span></span><br><span class="line">    [<span class="number">110000</span>, <span class="number">85000</span>]  <span class="comment"># SMOTE生成的合成1类样本</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">y_res = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]  <span class="comment"># 与X_res一一对应</span></span><br></pre></td></tr></table></figure>

<h2 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a><strong>特征选择</strong></h2><p>特征选择是提升模型性能和减少过拟合的重要步骤，通过选择最有用的特征，可以降低模型的复杂度并提高其泛化能力</p>
<p>Pandas 可以与 <strong>Scikit-learn</strong> 等库结合进行特征选择</p>
<h3 id="相关性分析"><a href="#相关性分析" class="headerlink" title="相关性分析"></a><strong>相关性分析</strong></h3><p><strong>相关性分析</strong>是初步选择特征的重要工具，Pandas 的<code>corr()</code>方法可以轻松计算数值特征之间的相关系数，从而帮助我们去除冗余或高度相关的特征</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算相关系数矩阵</span></span><br><span class="line">corr_matrix = df.corr()</span><br><span class="line"><span class="built_in">print</span>(corr_matrix)</span><br></pre></td></tr></table></figure>

<p>其中 df 是一个 DataFrame 类型的结构，通过调用它本身的 corr() 方法，我们就可以得到这个 DataFrame 中<strong>各列</strong>之间的相关系数矩阵</p>
<p>我们还是以上面的 df 为例，假设其包含三列内容：Age Income Spending，那么得到的相关系数矩阵可能如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">            Age    Income  Spending</span><br><span class="line">Age       <span class="number">1.000</span>     <span class="number">0.250</span>    -<span class="number">0.100</span></span><br><span class="line">Income    <span class="number">0.250</span>     <span class="number">1.000</span>     <span class="number">0.750</span></span><br><span class="line">Spending -<span class="number">0.100</span>     <span class="number">0.750</span>     <span class="number">1.000</span></span><br></pre></td></tr></table></figure>

<p>如果想选择更直观的方式，我们可以用<strong>热力图</strong>进行表示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">8</span>))</span><br><span class="line">sns.heatmap(corr_matrix, annot=<span class="literal">True</span>, cmap=<span class="string">&#x27;coolwarm&#x27;</span>, center=<span class="number">0</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;特征相关系数矩阵热力图&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<h3 id="方差阈值法"><a href="#方差阈值法" class="headerlink" title="方差阈值法"></a><strong>方差阈值法</strong></h3><p>使用<code>Scikit-learn</code>的 <code>VarianceThreshold</code>，我们可以去除那些方差过小的特征，这些特征通常对模型预测没有帮助，换言之，就是重复的数据对模型预测效果不大，我们希望所有数据都是不同的，也就是希望要尽可能大的方差</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> VarianceThreshold</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建方差阈值选择器，设置阈值为 0.1</span></span><br><span class="line">selector = VarianceThreshold(threshold=<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用选择器转换数据</span></span><br><span class="line">df_selected = selector.fit_transform(df[[<span class="string">&#x27;Income&#x27;</span>, <span class="string">&#x27;After_Tax_Income&#x27;</span>]])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(df_selected)</span><br></pre></td></tr></table></figure>

<p>方差阈值法通过计算各个特征的方差，移除方差低于指定阈值的特征。基本假设是：低方差特征包含的信息量少，高方差特征可能包含更多有用信息</p>
<p>注意处理后返回的结果会以 Numpy 数组的形式返回，不再是 DataFrame 的结构，同时原始列的顺序会被保留</p>
<p>方差受量纲影响大，应先标准化数据</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line">df_scaled = StandardScaler().fit_transform(df)</span><br></pre></td></tr></table></figure>

<p>方差阈值法是一种<strong>简单高效</strong>的特征初筛方法，特别适合作为特征选择流程的第一步，快速移除明显无信息的特征</p>
<hr>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images/picture.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images/picture.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">Destiny</div><div class="post-copyright__author_desc">跋涉浮尘烛光灭</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://example.com/2025/07/23/python-pandas/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://example.com/2025/07/23/python-pandas/')">python-pandas</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://example.com/2025/07/23/python-pandas/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=python-pandas&amp;url=http://example.com/2025/07/23/python-pandas/&amp;pic=/../images/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A221.jpg" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">MyBlog</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/Python%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>Python与机器学习<span class="tagsPageCount">22</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="/../images/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A263.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/07/22/DP%E7%BB%83%E4%B9%A01/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A220.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">DP练习1</div></div></a></div><div class="next-post pull-right"><a href="/2025/07/24/splay/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A222.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">splay</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2025/07/19/AI%E5%BA%94%E7%94%A8%E4%B8%8E%E5%BC%80%E5%8F%91/" title="AI应用与开发"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A216.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-07-19</div><div class="title">AI应用与开发</div></div></a></div><div><a href="/2025/08/30/LaTeX/" title="LaTeX"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A263.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-08-30</div><div class="title">LaTeX</div></div></a></div><div><a href="/2025/07/25/KNN%E7%AE%97%E6%B3%95/" title="ML入门-KNN算法"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A224.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-07-25</div><div class="title">ML入门-KNN算法</div></div></a></div><div><a href="/2025/07/31/ML%E4%BB%A3%E7%A0%81/" title="ML代码"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A228.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-07-31</div><div class="title">ML代码</div></div></a></div><div><a href="/2025/07/28/ML%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/" title="ML前置知识"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A226.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-07-28</div><div class="title">ML前置知识</div></div></a></div><div><a href="/2025/07/21/PyQt/" title="PyQt"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A228.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-07-21</div><div class="title">PyQt</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images/picture.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description"></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://bu.dusays.com/2023/05/13/645fa415e8694.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#pandas"><span class="toc-number">1.</span> <span class="toc-text">pandas</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86"><span class="toc-number">1.1.</span> <span class="toc-text">基本知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.1.</span> <span class="toc-text">模块介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pandas-%E8%AF%BB%E5%8F%96-Excel-%E6%96%87%E4%BB%B6"><span class="toc-number">1.1.2.</span> <span class="toc-text">pandas 读取 Excel 文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DataFrame-%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.3.</span> <span class="toc-text">DataFrame 结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Series-%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.4.</span> <span class="toc-text">Series 结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.</span> <span class="toc-text">基础操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DataFrame-%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86-%E8%A1%8C%E5%88%97%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.1.</span> <span class="toc-text">DataFrame 数据处理 &amp; 行列操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5-Excel-%E6%96%87%E4%BB%B6"><span class="toc-number">1.2.2.</span> <span class="toc-text">数据写入 Excel 文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E5%A4%9A%E4%B8%AA-Excel-%E6%96%87%E4%BB%B6"><span class="toc-number">1.2.3.</span> <span class="toc-text">合并多个 Excel 文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97%E4%B8%8E%E7%BC%BA%E5%A4%B1%E5%80%BC%E5%A4%84%E7%90%86"><span class="toc-number">1.2.4.</span> <span class="toc-text">数据清洗与缺失值处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%AD%9B%E9%80%89%E4%B8%8E%E6%9D%A1%E4%BB%B6%E8%BF%87%E6%BB%A4"><span class="toc-number">1.2.5.</span> <span class="toc-text">数据筛选与条件过滤</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%BA%E5%A4%B1%E5%80%BC%E5%A4%84%E7%90%86"><span class="toc-number">1.3.</span> <span class="toc-text">缺失值处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B"><span class="toc-number">1.4.</span> <span class="toc-text">特征工程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%A0%87%E5%87%86%E5%8C%96%E4%B8%8E%E5%BD%92%E4%B8%80%E5%8C%96"><span class="toc-number">1.4.1.</span> <span class="toc-text">数据标准化与归一化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E5%BE%81%E7%BC%96%E7%A0%81"><span class="toc-number">1.4.2.</span> <span class="toc-text">特征编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E7%89%B9%E5%BE%81%E7%9A%84%E7%94%9F%E6%88%90"><span class="toc-number">1.4.3.</span> <span class="toc-text">新特征的生成</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86"><span class="toc-number">1.5.</span> <span class="toc-text">时序数据处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%92%8C%E5%B7%AE%E5%88%86%E5%88%86%E6%9E%90"><span class="toc-number">1.6.</span> <span class="toc-text">移动窗口和差分分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%A2%9E%E5%BC%BA%E4%B8%8E%E7%94%9F%E6%88%90"><span class="toc-number">1.7.</span> <span class="toc-text">数据增强与生成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%A2%9E%E5%BC%BA"><span class="toc-number">1.7.1.</span> <span class="toc-text">数据增强</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SMOTE"><span class="toc-number">1.8.</span> <span class="toc-text">SMOTE</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9"><span class="toc-number">1.9.</span> <span class="toc-text">特征选择</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%80%A7%E5%88%86%E6%9E%90"><span class="toc-number">1.9.1.</span> <span class="toc-text">相关性分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E5%B7%AE%E9%98%88%E5%80%BC%E6%B3%95"><span class="toc-number">1.9.2.</span> <span class="toc-text">方差阈值法</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/08/30/LaTeX/" title="LaTeX"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A263.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="LaTeX"/></a><div class="content"><a class="title" href="/2025/08/30/LaTeX/" title="LaTeX">LaTeX</a><time datetime="2025-08-30T01:47:43.000Z" title="发表于 2025-08-30 09:47:43">2025-08-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/29/%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B/" title="概率与期望"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A262.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="概率与期望"/></a><div class="content"><a class="title" href="/2025/08/29/%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B/" title="概率与期望">概率与期望</a><time datetime="2025-08-29T12:47:37.000Z" title="发表于 2025-08-29 20:47:37">2025-08-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/26/%E6%95%B0%E8%AE%BA%E8%BF%9B%E9%98%B6/" title="数论进阶"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A261.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数论进阶"/></a><div class="content"><a class="title" href="/2025/08/26/%E6%95%B0%E8%AE%BA%E8%BF%9B%E9%98%B6/" title="数论进阶">数论进阶</a><time datetime="2025-08-26T14:56:35.000Z" title="发表于 2025-08-26 22:56:35">2025-08-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/26/%E7%A0%81%E8%B9%84%E6%9D%AF%E5%9B%BD%E8%B5%9B/" title="码蹄杯国赛"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A260.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="码蹄杯国赛"/></a><div class="content"><a class="title" href="/2025/08/26/%E7%A0%81%E8%B9%84%E6%9D%AF%E5%9B%BD%E8%B5%9B/" title="码蹄杯国赛">码蹄杯国赛</a><time datetime="2025-08-26T03:24:24.000Z" title="发表于 2025-08-26 11:24:24">2025-08-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/24/%E5%8F%A6%E4%B8%80%E5%88%99%E5%A5%87%E5%A6%99%E6%95%85%E4%BA%8B/" title="另一则奇妙故事"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A259.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="另一则奇妙故事"/></a><div class="content"><a class="title" href="/2025/08/24/%E5%8F%A6%E4%B8%80%E5%88%99%E5%A5%87%E5%A6%99%E6%95%85%E4%BA%8B/" title="另一则奇妙故事">另一则奇妙故事</a><time datetime="2025-08-24T14:26:30.000Z" title="发表于 2025-08-24 22:26:30">2025-08-24</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2025 By <a class="footer-bar-link" href="/" title="Destiny" target="_blank">Destiny</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">52</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">2</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" rel="external nofollow noreferrer" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener external nofollow noreferrer" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener external nofollow noreferrer" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><span> 分类</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/tags/"><span> 标签</span></a></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Python%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="font-size: 0.88rem;">Python与机器学习<sup>22</sup></a><a href="/tags/editing/" style="font-size: 0.88rem;">editing<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 0.88rem;">算法<sup>26</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.6.14",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 Destiny 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/fireworks.min.js"></script><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>