<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>ML前置知识 | MyBlog</title><meta name="keywords" content="Python与机器学习"><meta name="author" content="Destiny"><meta name="copyright" content="Destiny"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="ML前置知识"><meta name="application-name" content="ML前置知识"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="ML前置知识"><meta property="og:url" content="http://example.com/2025/07/28/ML%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/index.html"><meta property="og:site_name" content="MyBlog"><meta property="og:description" content="ML前置知识通过阅读本文，您可以大致了解机器学习的概念与分类，以及其所用到的工具库与先修知识，完成简单的前期准备 基础技术栈机器学习基础（1）机器学习是什么？ 我们把计算机从数据（图片，文本，音频等）中学习规律（建立模型），并且改善自身进行预测（用已有模型解决新的问题）的过程，称为机器学习 （2）机"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="http://example.com/images/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A226.jpg"><meta property="article:author" content="Destiny"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://example.com/images/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A226.jpg"><meta name="description" content="ML前置知识通过阅读本文，您可以大致了解机器学习的概念与分类，以及其所用到的工具库与先修知识，完成简单的前期准备 基础技术栈机器学习基础（1）机器学习是什么？ 我们把计算机从数据（图片，文本，音频等）中学习规律（建立模型），并且改善自身进行预测（用已有模型解决新的问题）的过程，称为机器学习 （2）机"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="http://example.com/2025/07/28/ML%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"/images/文章封面48.jpg"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: Destiny","link":"链接: ","source":"来源: MyBlog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'MyBlog',
  title: 'ML前置知识',
  postAI: '',
  pageFillDescription: 'ML前置知识, 基础技术栈, 机器学习基础, 数据集, 监督 amp 非监督学习, 机器学习的分类, 机器学习任务, Anaconda环境, 图形化界面, 命令行操作, Jupyter Nodebook, 魔法命令, Numpy数组, 基础知识, Ndarray 对象创建, Numpy 数组创建的便捷方式, 数组的基础索引, 数组的合并与拆分, 矩阵运算, 统计运算, arg运算, 数组排序, 神奇索引, 比较, Matplotlib, plot绘图, scatter绘图前置知识通过阅读本文您可以大致了解机器学习的概念与分类以及其所用到的工具库与先修知识完成简单的前期准备基础技术栈机器学习基础机器学习是什么我们把计算机从数据图片文本音频等中学习规律建立模型并且改善自身进行预测用已有模型解决新的问题的过程称为机器学习机器学习的过程我们通过已有数据经过训练过程得到一个初步的模型然后不断加入新数据用该模型预测得到的输出和真实输出进行对比反复调整模型参数改善模型性能最终得到一个适应性较好预测效果较好的模型这一过程就称为机器学习机器学习的适用条件问题存在某种模式分类回归聚类等问题难以人工总结定义比如图像识别我们很难对一类图像给出严格且形象的定义我们可能轻易识别出来一张图片是猫还是狗但是没办法用准确且形象的描述告诉机器怎么像人一样识别有足够的样本数据进行模型训练技术基础有哪些在正式进入机器学习之前我们需要再次强调下面四部分内容以辅助我们后续更加快速的学习环境的操作的使用数组绘图下面会详细介绍各部分和机器学习中有关的部分数据集在入门阶段我们可以使用一些现有的简单数据集进行模型的训练比较常见的有鸢尾花数据集手写数字数据集波士顿住房数据集身高体重数据集我们以鸢尾花数据集为例分析机器学习中数据的使用鸢尾花数据集中共有三类鸢尾花每一类各有张图片作者为每一张鸢尾花图片都给出了如下特征花萼长度花萼宽度花瓣长度花瓣宽度以及每一类鸢尾花的属种如下图所示我们把前四列的特征成为最后一列的属种成为机器学习要做的事情就是建立一个模型通过输入特征就能够准确判断出当前图片中的鸢尾花所属的类别这个模型就是分类模型监督非监督学习监督学习监督学习的主要特征是训练数据带有标记也就是机器在学习的时候人类会告诉他分类或预测应有的正确结果让它照着一个正确的标准或方向进行学习监督学习的例子分类和回归无监督学习监督学习的主要特征是训练数据不带标记也就是机器在学习的时候我们不会告诉其正确答案需要它自己根据数据的特征和规则找到对应的规律建立模型无监督学习的例子聚类降维关联规则学习半监督学习半监督学习的主要特征是用少量标记数据结合大量无标记数据进行模型训练我们会让模型先从少量标记数据中去学习然后再用大量无标记数据进行模型训练往往会取得较优的效果强化学习强化学习通过使模型观测环境评估状态进而执行相应的操作最后根据模型执行的结果给出相应的回报和惩罚的过程强化学习的例子阿尔法狗机器学习的分类一根据是学习过程中是否有监督可以分为监督学习无监督学习半监督学习强化学习二根据训练数据的使用可以分为批量学习模型先训练再使用训练过程中把所有训练数据一次性全部喂给模型需要大量的时间和计算资源模型训练通常都是离线完成在线学习模型的训练是循序渐进的模型可以边学习边应用每次把训练数据小批量地喂给模型训练一段时间后就加以应用根据模型当前表现再选择新的数据作为增量进行迭代训练三根据模型扩展和泛化的过程可以分为基于实例的学习让模型在学习过程中记住每个训练实例的特征当模型接触新的元素时通过计算它和已经学习过的实例的相似度完成新元素的分类和预测基于模型的学习使用训练实例构建出一个模型在处理新的数据时脱离训练数据本身而是用我们训练好的模型进行分类和预测基于实例的学习只学习每个实例的特征基于模型的学习建立出分类模型机器学习任务机器学习主要用来解决以下几类任务基础任务分类和回归提高任务聚类和降维进阶任务强化学习其中基础任务和提高任务也就是分类回归聚类降维四部分内容是我们当前需要掌握的内容分类任务分类任务是通过已知样本的特征判断一个新的样本是否属于某个类别以实现对样本分类的功能根据类别数量可以把分类任务分成二分类多分类多标签分类三种二分类只需要把数据划分成两类我们一般称为正类和负类和常见模型比如垃圾邮件分类猫和狗图像分类阴性和阳性分类等多分类需要把类别划分成多个类别常见模型比如手写数字分类人脸识别鸢尾花种类分类等多标签分类在二分类或多分类中每个样本只会被分到一个唯一的类别中但多标签分类更倾向于给每个样本打上不同分类的标签比如对人的分类有男生类和女生类学生类和非学生类那么一个样本可能既是学生又是男生也就是此时的类别之间不再是互斥的回归任务回归任务通过研究已有自变量和因变量之间的关系找到二者之间的规律用新的自变量预测未知因变量如果我们找到的变量之间关系是一次函数线性关系此时我们就称该模型为线性回归模型注意线性回归未必是的形式其中和可能都是矩阵也就是多个线性函数的叠加当因变量和自变量之间的关系变得复杂只采用线性模型可能很难描述他们之间的关系此时我们就可能需要多项式回归模型因为任何函数都可以用多项式逼近最后还有一类比较常见的回归模型称为逻辑回归该模型本质上是一个分类模型用于把两类元素进行分类然后预测新的样本属于哪一类即可之所以把该回归和二分类模型进行区分是因为二者找到分界函数的算法和侧重思想不同后续会详细介绍聚类任务非监督模型把样本依据特征划分为不同的类别降维任务非监督模型在不丢失数据主要信息的前提下对数据进行维度压缩和合并环境图形化界面可以通过图形化界面进行操作其中可以在一栏中选择我们想使用的虚拟环境默认环境是环境对应每个环境下的各个图标即为中自带的库显示图标的表示未安装单击即可安装显示图标的表示已安装单击即可打开通过点击左侧的一栏我们可以进入每个虚拟环境的操作界面我们可以选中每个虚拟环境在界面右侧找到它所有的库选择安装或卸载同时也可以在该界面下放创建新的虚拟环境或删除已有的虚拟环境命令行操作的命令行操作可以通过打开命令行进行执行以下是开发中常用的命令查看当前所处虚拟环境的版本更新某个虚拟环境的版本这里表示更新名为的虚拟环境的版本显示所有的环境创建新的环境这里表示创建名为默认语言为的环境其中是命令缩写激活指定的虚拟环境表示激活并切换到这个虚拟环境中执行以后会发现命令行提示最前面括号中的环境名称从变成了表示切换成功退出当前的虚拟环境执行完以后从环境又回到了环境中列出当前环境中所有的安装包在当前环境中安装某个库在当前环境中安装库会自动远程搜索并完成下载这里如果不特殊指定版本默认安装最新版查询某个库的所有版本表示查询这个库当前可供安装的所有版本在当前环境中删除某个库也可以把换成在当前环境下启动启动以后中不能再执行其他命令行如果想关闭可以直接从命令行中关闭删除某个虚拟环境先从当前虚拟环境中退出然后进行删除是命令缩写表示把该环境中安装的所有库也都一并删除魔法命令中的所有魔法命令都是通过开头的我们介绍几个比较常用的魔法命令命令该命令的作用是把当前单元格中所有的代码原样输出到目标文件中这里我们选择输出到中执行以后会在当前目录下自动创建这个文件我们也可以选择其他后缀如等命令该命令的作用是显示目标文件中的代码只是显示代码本身而不会执行类似于中的指令这里执行以后会在当前单元格下方显示文件的内容命令这里命令的方法就相当于命令指在当前单元格中引入文件此时我们即可执行中的函数上面这种写法等价于以下两种写法值得注意的是如果我们使用指令我们需要给出文件的全称包括后缀而如果我们使用指令则我们只需要引用的文件名而不需要再加上后缀和指令其中一个百分号只能评估其后面紧跟的一条指令完成运行所需要的时间而两个百分号则可以用来评估整个单元格运行完成所需要的时间使用指令只会进行一次评估如果想根据程序运行时间动态调整评估次数比如多测几次提高可靠性我们可以使用指令该指令用法和指令完全相同指令该指令用来显示当前单元格及其之前所有的单元格中所有被引入的库调用的函数以及定义过的变量和指令如果想查找更多魔法指令可以通过指令显示所有的魔法指令通过指令详细查看每个魔法指令的用法数组是常用的开源的科学计算库全称为在机器学习中经常使用库中最常用的结构就是其自带的数组相比于中的列表而言支持向量和矩阵运算在操作过程中会更加简单基础知识通过调用方法创建数组可以传入参数表示我们创建的数组长度如果我们创建的就是我们可以对创建出的数组直接做运算对应的运算会作用于数组的每一个元素比如我们可以写则表示把数组的每一个元素都取平方最后我们可以调用方法对数组中每个元素求和返回一个整型值使用数组的效率要比本身的效率高很多且随着数据集规模的增加这种效率的提升会更加明显对象创建通过调用方法并且传入中的列表结构我们即可用已有列表初始化出一个数组在机器学习中我们把一维数组一般称为向量而多维数组一般称为矩阵通过创建出来的数组有一些简单的属性比如可以获知其维数形状大小元素种类等数组维度数组有几行数组形状数组为几行几列数组大小数组内元素个数数组属性数组内元素种类数组创建的便捷方式通过调用方法可以创建全是的数组创建长度为的向量指定元素类型为整型默认为浮点型指定数组形状为行列矩阵也可以创建更高维的矩阵生成形状和数组相同的全数组通过调用方法可以创建全是的数组该构造方式的参数和完全相同只是前者构造全数组后者构造全数组通过调用方法可以创建全是指定值的数组长度填充值全为形状行列填充值全为与形状相同填充值全为通过调用方法可以创建空数组这里的空指的是没有经过初始化的数组通过调用方法可以创建等差数列形成的数组创建长度为的一维数组元素从开始用中的元素步长为构建数组先用中的元素构建一维数组再把形状改为行列的矩阵通过调用方法可以形成和相类似的效果只不过前者的区间是左闭右闭后者的区间是左闭右开注意最后一个参数表示的生成数字的个数在此之间生成个数随机数模块该模块用于生成随机数也可以用来生成元素是随机数的数组通过调用方法或者方法可以生成元素都是中随机数的数组生成的随机数生成长度为的随机数向量生成行列的随机数矩阵生成的随机数生成长度为的随机数向量生成三维数组通过调用方法可以生成元素都是随机整数的数组生成之间的随机数生成之间的随机数用的随机数生成长度为的数组用的随机数生成行列的数组通过在代码中加入方法可以初始化固定的随机种子确保每次运行代码随机数生成函数所生成的随机数都相同确保不会出现随机序列可变的情况不管运行多少次得到的数组内容都是相同的通过调用方法可以生成元素服从标准正态分布的数组生成一个服从标准正态分布的随机数生成长度为的向量其中元素分布服从标准正态分布生成行列的矩阵其中元素分布服从标准正态分布通过调用方法可以生成元素服从均值为标准差为的正态分布的数组这里需要注意的是和限制数组形状的参数名为而和限制数组形状的参数名为不传参数时默认为标准正态分布指定均值标准差形状为行列通过调用方法可以生成元素服从均匀分布的数组不传参数时默认为的均匀分布生成在长度为元素服从均匀分布的向量生成元素服从均匀分布形状为行列的矩阵总结数组的基础索引前期准备工作首先我们创建如下的数组这里小写字母一般表示向量大写字母一般表示矩阵这里对于矩阵我们先生成一维等差序列然后再转成我们想要的二维矩阵这是比较常用的一个初始化方法一维数组切片一维数组切片的实现和的实现方式相同通过的形式实现其中第一个位置填写起点空置则表示从开始第二个位置填写终点开区间取不到终点空置表示到最后一个为止第三个位置填写取数的步长步长可以为负此时起点和终点也要对应交换表示从原序列中倒序取值二维数组切片二维数组切片可以看成是两个一维数组的切片通过逗号形式分隔开完整的实现为行起点索引行终点索引行步长列起点索引列终点索引列步长以下是几个具体的示例矩阵取其中某个单点可以通过形如中二维数组的方式进行选取只是通过逗号把行下标索引和列下标索引进行间隔取矩阵中某一行的所有值可以通过的形式取出只给出要选择的行下标索引列下标索引空置再加一个分号即可后面的可以省略效果完全一样特别的如果想取出的最后一行元素可以填写作为行下标索引而如果想取矩阵某一列的所有值可以通过的形式取出此时需要先写冒号再写逗号最后给出想取出的列的下标索引特别的如果想取出的最后一列元素可以填写作为列下标索引如果想从中取出一个子矩阵则需要填写各个位置的参数表示取出矩阵第行到第行第列到第列的元素组成的一个子矩阵表示把矩阵中的所有的元素都进行倒序处理注意在中对数组切片做修改是会作用到原数组上的这是因为在处理较大数据集合时为了避免内部总是进行数据拷贝对数组进行了引用的处理方式此时数组位置的元素会被修改成如果我们就是想只修改切片但是不修改原数组可以使用切片的方法也就是方法此时再修改数组就不会对数组产生影响了数组的合并与拆分数组的合并假设我们有一个二维数组和一个一维数组如下现在我们想把数组拼在数组后面可以调用方法该方法要求和的维度必须相同现在是二维数组是一维数组因此我们需要先把改成二维数组也就是行列的二维数组才能进行合并该方法支持传入一个元组从前到后把元组中的数组依次合并除此之外还提供了更为方便的和方法分别用来竖直方向合并和水平方向合并这两个方法不再要求合并数组的维度相同可以直接进行合并竖直方向合并把拼接在后面水平方向合并把拼在右边当然也可以使用进行水平方向合并该函数默认的事竖直方向的合并只需要设置参数为即可数组拆分我们可以通过调用方法进行数组的拆分操作如果想对行进行拆分则默认参数为即可如果想对列进行拆分则需要额外设置参数为这里表示对数组的最后一列进行拆分分别得到一个行列的数组一个行列的数组用和两个变量进行接收如果不设置参数则表示对最后一行进行拆分得到一个行列的数组一个行列的数组除此之外和与相对的也提供了和方法分别负责竖直行拆分和水平方向列拆分的拆分这两个函数支持以一个列表的形式传入参数以行拆分为例如果我们传入则表示把原数组拆分为段分别是最后如果加入更多参数则同理换言之我们传进去的就是我们想切割的分点位置按行拆分拆分为和最后两部分按列拆分拆分为和和最后三部分总结矩阵运算一元运算所谓一元运算就是对向量矩阵中的每一个元素进行自运算比如平方开根之类不涉及到其他元素只涉及到每个元素自身数组直接对数组名运算对应的运算就能作用到数组中的每一个元素上如果我们相对数组中每个元素平方在中我们需要而在数组中我们可以直接下面是对于数组常见的一元运算对每个元素取绝对值对每个元素开二次方根对每个元素取平方对每个元素取以为底的指数对每个元素取以为底的对数对每个元素取以为底的对数对每个元素取以为底的对数对每个元素向上取整对每个元素向下取整对每个元素科学取整整数位为奇数四舍五入整数位为偶数四舍六入对每个元素取正弦对每个元素取余弦对每个元素取正切二元运算二元运算指的是对矩阵向量中的每一个元素而言都给出另一个元素与之进行运算比如最常见的四则运算每一个二元运算背后都为我们封装好了底层的实现函数比如对于加法表示对中的每个元素都加上底层其实是调用了方法实现的以下是中常见的二元运算对每个元素都加对每个元素都减对每个元素都乘以对每个元素都除以对每个元素都整除对每个元素都进行次方矩阵运算可以用中的数组实现线性代数中矩阵的运算以下是中常用的矩阵运算假设我们有以下两个的矩阵和对其可以做下面的矩阵运算矩阵加法矩阵减法矩阵哈达玛积对应位置的元素相乘即可矩阵乘法矩阵相除对应位置的元素相除即可矩阵转置二维矩阵的转置矩阵取逆矩阵求特征值特征向量矩阵求行列式需要注意的是只有方阵才可以求行列式和逆矩阵如果对矩阵不太了解可能需要去复习线性代数总结统计运算数组的统计运算不仅比的相同功能更加高效也支持更加灵活的实现方式和功能以下是常用的统计函数统计最大值元素统计最小值元素统计每列最小值元素统计每行最小值元素求所有元素之和求每一列元素之和求每一行元素之和求所有元素均值求所有元素中位数所有元素的标准差求所有元素的方差还有一些不太常用但是比较有用的统计函数下面进行介绍统计矩阵中最大值和最小值的差求矩阵的各个分位数生成这五个常用的分位数分别得到的分位数求矩阵每一行每一列前缀和按列求前缀和按行求前缀和求矩阵每一行每一列差分按列求差分按行求差分把矩阵每一行每一列累乘按列求累乘按行求累乘总结运算是的缩写是机器学习中常见的概念一般用于表示函数取某个特殊值的时候对应的自变量值也就是说此时我们不关注函数值本身而是关心函数取这个值的时候对应的是多少比如该表达式表示当时取到和这两个值对于数组而言其支持和运算分别表示数组中的最大值对应的下标索引以及数组中的最小值对应的下标索引因为我们在算法中接触过数组和函数等价的概念因此这里数组值可以等价为函数值数组下标可以等价为函数自变量中小值的下标最小值本身中最大值的下标最大值本身这里表示表示数组排序方法自带一个用于排序的称为方法其中数组本身也自带一个方法这两个方法的区别在于提供的排序不会对数组本身进行排序而是返回排好序的新数组而数组本身调用会进行原地排序自身顺序会改变使用模块中的方法进行打乱使用排序使用数组自带的排序使用索引假设我们有一个乱序的数组我们可以调用方法对索引大小进行排序也就是输出乱序数组中元素从小到大排序后对应的原始索引值假设原数组为使用排序以后得到的索引数组为分区该方法用于实现类似于快速排序中对元素分区的效果函数接受一个参数表示以有序序列中排名第的元素作为分界线比它小的都在左侧比它大的都在右侧选择有序序列中第个元素作为分界线该方法也支持显示下标的情况如果我们调用传入参数的话则会进行同样的分类只不过每个位置显示的不是元素本身的值而是他们在原序列中的原始下标高维数组高维数组同样可以调用上述所有的排序方法只是默认会对其按列排序如果设置则会按行进行排序以按列排序为例会使得每一行都变成升序以按行排序为例会使得每一列都变成升序按列升序排序按行升序排序神奇索引神奇索引用于快速对数组进行索引访问对于一个一维数组假设我们想获取其位置的值或者想获取其位置的值并且组织成行列的矩阵的形式此时我们都可以用神奇索引实现对应的功能具体来讲我们只需要把想获取的索引位置和格式写进一个数组把这个索引数组整体当成下标喂给原数组即可获取下标位置的元素获取下标位置的元素并且组成行列矩阵也就是说对于一维数组而言我们使用神奇索引的主要目的就是取出若干个离散的下标所对应的数组元素神奇索引同样适用于二维矩阵我们之前说过二维矩阵的切片满足行起始下标行终点下标不包含行步长列起始下标列终点下标不包含列步长我们使用的神奇索引代表行代表列可以分别用来代替逗号前后的内容这里表示从矩阵中取出这三个位置的元素如果我们从取一整行或者一整列去取元素只需要结合二维数组原始的切片即可实现这两例分别表示取矩阵第一行第列的三个元素以及取矩阵第列第行的六个元素最后数组也支持以类型的数组进行数据索引比如我们给出如下的数组则表示从矩阵中取出第行第列的两个元素比较在神奇索引的最后我们发现数组支持以类型的下标进行索引那么我们该如何构造类型的下标索引呢答案是可以使用比较的方法以下是常用的比较逻辑所有比较的结果都是和相同形状的数组对应的每个位置表示这个位置的元素是否满足比较结果是则为否则为小于逻辑等于逻辑不等逻辑简单的方程判定现在我们只是得到了一个数组如果想把满足这些比较条件的元素对应的数值获取到则还需要结合神奇索引才能够实现找到中所有比大的数找到中所有的偶数比较和统计的结合以下是常用的统计函数统计中小于的元素个数统计中小于的元素个数判断中是否存在小于的元素判断中的元素是否全都小于需要说明的是和函数都是统计的对应比较条件所得到的数组中对应的位置的个数函数相当于存在量词命题判断函数相当于全程量词命题判断上述函数加上参数即可作用于二维数组的行和列也就是对每一行或每一列统计统计每一行的偶数个数判断每一列是否有不大于的元素比较运算也可以和逻辑运算符号结合实现相对复杂的比较逻辑是我们机器学习中常用的绘图工具该库中的众多命令和函数和都比较类似这里我们常用的是和其中前者用于绘制连续图后者用于绘制散点图当是数据是观测值的时候我们一般用绘制连续图用于表示数据和观测值之间的关系当和都是数据的维度的时候我们一般用绘制散点图用于表示数据点在二维空间中的分布绘图包的引入绘制简单曲线下面我们绘制一条二次函数的曲线其中用于绘图其接收两个参数分别是数据集合和观测值集合而用于展示已经绘制好的图像由此我们可以得到一张简单的二次函数的图像这里虽然我们传入的和都是散点但是因为点的数量太多因此曲线看起来是光滑的如果我们把点的个数从锐减到个则可较为明显地观察到连点成线的痕迹多个函数的显示下面我们同时绘制正弦和余弦曲线的函数图我们只需要分别绘制正弦和余弦最后一起调用方法显示即可我们也可以给方法中传入参数设置曲线的颜色比如我们可以把默认颜色改成绿色我们也可以给方法中传入参数设置曲线的形状比如我们可以把线形改成虚线其他参数通过调用和我们可以设置轴和轴的坐标范围但是有图像绘制的范围还是由数组的范围所决定的上述两个函数只是设置了坐标轴的最大范围设置轴范围为到设置轴范围为到我们也可以通过参数同时设置轴和轴的范围先传轴后传轴即可通过调用和我们可以设置轴和轴的坐标轴名称通过调用在中传入参数我们可以设置曲线的名称最后如果想显示曲线名称还需要调用方法进行图例显示通过设置以上参数我们的图像则变成了最后我们可以调用方法设置图标的名称绘图和方法的用法和参数设置等完全相同只不过前者绘制的是散点图后者绘制的是连续图我们以标准二维高斯分布为例展示的绘图效果对应的标准二维正态分布示意图如下因为图中的点对数量多达个我们可以通过设置参数来控制图形透明度表示完全透明表示完全不透明我们可以设成修改后的绘图效果如下',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-07-28 21:57:07',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.4/img/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">MyBlog</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)" rel="external nofollow noreferrer">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><span> 分类</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/tags/"><span> 标签</span></a></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Python%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="font-size: 1.05rem;">Python与机器学习<sup>22</sup></a><a href="/tags/editing/" style="font-size: 1.05rem;">editing<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 1.05rem;">算法<sup>26</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/08/"><span class="card-archive-list-date">八月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">28</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/07/"><span class="card-archive-list-date">七月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">24</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);" rel="external nofollow noreferrer"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/Python%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" itemprop="url">Python与机器学习</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/Python%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>Python与机器学习</span></a></span></div></div><h1 class="post-title" itemprop="name headline">ML前置知识</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2025-07-28T02:18:31.000Z" title="发表于 2025-07-28 10:18:31">2025-07-28</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2025-07-28T13:57:07.672Z" title="更新于 2025-07-28 21:57:07">2025-07-28</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为香波地群岛"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>香波地群岛</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="/../images/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A226.jpg"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://example.com/2025/07/28/ML%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/"><header><a class="post-meta-categories" href="/categories/Python%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" itemprop="url">Python与机器学习</a><a href="/tags/Python%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" tabindex="-1" itemprop="url">Python与机器学习</a><h1 id="CrawlerTitle" itemprop="name headline">ML前置知识</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">Destiny</span><time itemprop="dateCreated datePublished" datetime="2025-07-28T02:18:31.000Z" title="发表于 2025-07-28 10:18:31">2025-07-28</time><time itemprop="dateCreated datePublished" datetime="2025-07-28T13:57:07.672Z" title="更新于 2025-07-28 21:57:07">2025-07-28</time></header><h1 id="ML前置知识"><a href="#ML前置知识" class="headerlink" title="ML前置知识"></a><strong>ML前置知识</strong></h1><p>通过阅读本文，您可以大致了解机器学习的概念与分类，以及其所用到的工具库与先修知识，完成简单的前期准备</p>
<h2 id="基础技术栈"><a href="#基础技术栈" class="headerlink" title="基础技术栈"></a><strong>基础技术栈</strong></h2><h3 id="机器学习基础"><a href="#机器学习基础" class="headerlink" title="机器学习基础"></a><strong>机器学习基础</strong></h3><p>（1）机器学习是什么？</p>
<p>我们把计算机从<strong>数据</strong>（图片，文本，音频等）中学习<strong>规律</strong>（建立模型），并且改善自身进行<strong>预测</strong>（用已有模型解决新的问题）的过程，称为机器学习</p>
<p>（2）机器学习的过程？</p>
<p>我们通过已有数据，经过训练过程得到一个初步的模型，然后不断加入新数据，用该模型预测得到的输出和真实输出进行对比，反复调整模型参数，改善模型性能，最终得到一个适应性较好，预测效果较好的模型，这一过程就称为机器学习</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/ML%E8%BF%87%E7%A8%8B.png" alt="image-20250726232804699"></p>
<p>（3）机器学习的适用条件？</p>
<ol>
<li>问题存在某种模式（分类，回归，聚类等） </li>
<li>问题难以人工总结定义（比如图像识别，我们很难对一类图像给出严格且形象的定义，我们可能轻易识别出来一张图片是猫还是狗，但是没办法用准确且形象的描述告诉机器怎么像人一样识别）</li>
<li>有足够的样本数据进行模型训练</li>
</ol>
<p>（4）技术基础有哪些？</p>
<p>在正式进入机器学习之前，我们需要再次强调下面四部分内容，以辅助我们后续更加快速的学习：</p>
<ol>
<li>Anaconda 环境的操作</li>
<li>Jupyter Notebook 的使用</li>
<li>Numpy 数组</li>
<li>Matplotlib 绘图</li>
</ol>
<p>下面会详细介绍各部分和机器学习中<strong>有关</strong>的部分</p>
<h3 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a><strong>数据集</strong></h3><p>在入门阶段，我们可以使用一些现有的简单数据集，进行模型的训练，比较常见的有：IRIS鸢尾花数据集，MNIST手写数字数据集，波士顿住房数据集，SOCR身高体重数据集</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E6%95%B0%E6%8D%AE%E9%9B%86.png" alt="image-20250728102611901"></p>
<p>我们以鸢尾花数据集为例，分析机器学习中数据的使用：鸢尾花数据集中共有三类鸢尾花，每一类各有 50 张图片，作者为每一张鸢尾花图片都给出了如下特征：</p>
<ol>
<li>花萼长度</li>
<li>花萼宽度</li>
<li>花瓣长度</li>
<li>花瓣宽度</li>
</ol>
<p>以及每一类鸢尾花的属种：versicolor，virginica，setosa，如下图所示</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E9%B8%A2%E5%B0%BE%E8%8A%B1.png" alt="image-20250728103014687"></p>
<p>我们把前四列的特征成为 X，最后一列的属种成为 Y，机器学习要做的事情就是建立一个模型，通过输入特征 X 就能够准确判断出当前图片中的鸢尾花所属的类别 Y，这个模型就是<strong>分类</strong>模型</p>
<h3 id="监督-非监督学习"><a href="#监督-非监督学习" class="headerlink" title="监督 &amp; 非监督学习"></a><strong>监督 &amp; 非监督学习</strong></h3><p><strong>监督学习</strong></p>
<p>监督学习（Supervised Learning）的主要特征是<strong>训练数据带有标记</strong>，也就是机器在学习的时候，人类会告诉他分类或预测应有的<strong>正确</strong>结果，让它照着一个正确的标准或方向进行学习</p>
<p>监督学习的例子：分类和回归</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0.png" alt="image-20250728135834709"></p>
<p><strong>无监督学习</strong></p>
<p>监督学习（Unsupervised Learning）的主要特征是<strong>训练数据不带标记</strong>，也就是机器在学习的时候，我们不会告诉其正确答案，需要它自己根据数据的特征和规则，找到对应的规律建立模型</p>
<p>无监督学习的例子：聚类，降维，关联规则学习</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0.png" alt="image-20250728140038104"></p>
<p><strong>半监督学习</strong></p>
<p>半监督学习（Semi-supervised Learning）的主要特征是用少量标记数据，结合大量无标记数据进行模型训练，我们会让模型先从<strong>少量标记数据</strong>中去学习，然后再用<strong>大量无标记数据</strong>进行模型训练，往往会取得较优的效果</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0.png" alt="image-20250728140511724"></p>
<p><strong>强化学习</strong></p>
<p>强化学习（Reinforcement Learning）通过使模型观测环境，评估状态，进而执行相应的操作，最后根据模型执行的结果，给出相应的回报和惩罚的过程</p>
<p>强化学习的例子：阿尔法狗</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0.png" alt="image-20250728140647868"></p>
<h3 id="机器学习的分类"><a href="#机器学习的分类" class="headerlink" title="机器学习的分类"></a><strong>机器学习的分类</strong></h3><p>（一）根据是学习过程中是否有监督，可以分为：</p>
<ol>
<li>监督学习</li>
<li>无监督学习</li>
<li>半监督学习</li>
<li>强化学习</li>
</ol>
<p>（二）根据训练数据的使用，可以分为：</p>
<ol>
<li>批量学习（Batch Learning）：模型先训练再使用，训练过程中把所有训练数据<strong>一次性</strong>全部喂给模型，需要大量的时间和计算资源，模型训练通常都是离线完成</li>
<li>在线学习：模型的训练是循序渐进的，模型可以边学习边应用，每次把训练数据<strong>小批量</strong>地喂给模型，训练一段时间后就加以应用，根据模型当前表现，再选择新的数据作为增量进行迭代训练</li>
</ol>
<p>（三）根据模型扩展和泛化的过程，可以分为：</p>
<ol>
<li>基于实例的学习：让模型在学习过程中，记住每个训练实例的特征，当模型接触新的元素时，通过计算它和已经学习过的实例的<strong>相似度</strong>，完成新元素的分类和预测</li>
<li>基于模型的学习：使用训练实例构建出一个模型，在处理新的数据时，脱离训练数据本身，而是用我们训练好的模型进行分类和预测</li>
</ol>
<p>基于实例的学习：只学习每个实例的特征</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E5%9F%BA%E4%BA%8E%E5%AE%9E%E4%BE%8B.png" alt="image-20250728141314231"></p>
<p>基于模型的学习：建立出分类模型</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E6%A8%A1%E5%9E%8B.png" alt="image-20250728141424852"></p>
<h3 id="机器学习任务"><a href="#机器学习任务" class="headerlink" title="机器学习任务"></a><strong>机器学习任务</strong></h3><p>机器学习主要用来解决以下几类任务：</p>
<ol>
<li>基础任务：分类和回归</li>
<li>提高任务：聚类和降维</li>
<li>进阶任务：强化学习</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E4%BB%BB%E5%8A%A1%E5%9C%B0%E5%9B%BE.png" alt="image-20250728103704613"></p>
<p>其中基础任务和提高任务（也就是分类，回归，聚类，降维）四部分内容是我们当前需要掌握的内容</p>
<p><strong>分类任务</strong></p>
<p>分类任务（Classification）是通过已知样本的特征，判断一个新的样本是否属于某个类别，以实现对样本分类的功能</p>
<p>根据类别数量可以把分类任务分成：二分类，多分类，多标签分类三种</p>
<p>二分类：只需要把数据划分成两类，我们一般称为正类和负类（positive 和 negative），常见模型比如垃圾邮件分类，猫和狗图像分类，阴性和阳性分类等</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E5%A4%9A%E5%88%86%E7%B1%BB.png" alt="image-20250728105026090"></p>
<p>多分类：</p>
<p>需要把类别划分成多个类别，常见模型比如手写数字分类，人脸识别，鸢尾花种类分类等</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E5%A4%9A%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98.png" alt="image-20250728105152496"></p>
<p>多标签分类：</p>
<p>在二分类或多分类中，每个样本只会被分到一个<strong>唯一</strong>的类别中，但多标签分类更倾向于给每个样本打上不同分类的标签，比如对人的分类有男生类和女生类，学生类和非学生类，那么一个样本可能既是学生又是男生，也就是此时的类别之间不再是<strong>互斥</strong>的</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E5%A4%9A%E6%A0%87%E7%AD%BE.png" alt="image-20250728105338684"></p>
<p><strong>回归任务</strong></p>
<p>回归任务（Regression）通过研究已有自变量和因变量之间的关系，找到二者之间的规律，用新的自变量预测未知因变量</p>
<p>如果我们找到的变量之间关系是一次函数（线性关系），此时我们就称该模型为<strong>线性回归</strong>模型</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B.png" alt="image-20250728104353694"></p>
<p>注意：线性回归未必是 y &#x3D; kx+b 的形式，其中 y k 和 x 可能都是矩阵，也就是多个线性函数的叠加</p>
<p>当因变量和自变量之间的关系变得复杂，只采用线性模型可能很难描述他们之间的关系，此时我们就可能需要<strong>多项式回归</strong>模型，因为任何函数都可以用多项式逼近</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%9B%9E%E5%BD%92.png" alt="image-20250728104624094"></p>
<p>最后还有一类比较常见的回归模型，称为<strong>逻辑回归</strong>，该模型本质上是一个分类模型，用于把两类元素进行分类，然后预测新的样本属于哪一类即可，之所以把该回归和<strong>二分类</strong>模型进行区分，是因为二者找到分界函数 y &#x3D; kx+b 的算法和侧重思想不同，后续会详细介绍</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92.png" alt="image-20250728105443916"></p>
<p>聚类任务（非监督模型）：把样本依据特征划分为不同的类别</p>
<p>降维任务（非监督模型）：在不丢失数据主要信息的前提下，对数据进行维度压缩和合并</p>
<h2 id="Anaconda环境"><a href="#Anaconda环境" class="headerlink" title="Anaconda环境"></a><strong>Anaconda环境</strong></h2><h3 id="图形化界面"><a href="#图形化界面" class="headerlink" title="图形化界面"></a><strong>图形化界面</strong></h3><p>Anaconda 可以通过图形化界面进行操作</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/Anaconda%E7%95%8C%E9%9D%A2.png" alt="image-20250727093032276"></p>
<p>其中可以在 Channels 一栏中选择我们想使用的虚拟环境，默认环境是 base 环境，对应每个环境下的各个图标即为 Anaconda 中自带的库，显示 install 图标的表示<strong>未安装</strong>，单击 install 即可安装；显示 launch 图标的表示已安装，单击 launch 即可打开</p>
<p>通过点击左侧的 environment 一栏，我们可以进入每个虚拟环境的操作界面</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/env.png" alt="image-20250727093436713"></p>
<p>我们可以选中每个虚拟环境，在界面右侧找到它所有的库选择安装或卸载，同时也可以在该界面下放创建新的虚拟环境，或删除已有的虚拟环境</p>
<h3 id="命令行操作"><a href="#命令行操作" class="headerlink" title="命令行操作"></a><strong>命令行操作</strong></h3><p>Anaconda 的命令行操作可以通过打开 Anaconda Prompt 命令行进行执行，以下是开发中常用的 conda 命令</p>
<p>（1）查看当前所处 conda 虚拟环境的版本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda -V</span><br></pre></td></tr></table></figure>

<p>（2）更新某个 conda 虚拟环境的版本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2conda update py3<span class="number">.9</span></span><br></pre></td></tr></table></figure>

<p>这里表示更新名为 py3.9 的虚拟环境的 conda 版本</p>
<p>（3）显示所有的 conda 环境：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda <span class="built_in">env</span> list</span><br></pre></td></tr></table></figure>

<p>（4）创建新的 conda 环境</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda cerate -n py3.9 python</span><br></pre></td></tr></table></figure>

<p>这里表示创建名为 py3.9，默认语言为 python 的 conda 环境，其中 -n 是命令缩写</p>
<p>（5）激活指定的 conda 虚拟环境</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda activate py3.9</span><br></pre></td></tr></table></figure>

<p>表示激活并切换到 py3.9 这个虚拟环境中，执行以后会发现命令行提示最前面括号中的环境名称从 base 变成了 py3.9 表示切换成功</p>
<p>（6）退出当前的 conda 虚拟环境</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda deactivate py3.9</span><br></pre></td></tr></table></figure>

<p>执行完以后从 py3.9 环境又回到了 base 环境中</p>
<p>（7）列出当前 conda 环境中所有的安装包</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda list</span><br></pre></td></tr></table></figure>

<p>（8）在当前 conda 环境中安装某个库</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install numpy</span><br></pre></td></tr></table></figure>

<p>在当前 conda 环境中安装 numpy 库，Anaconda 会自动远程搜索并完成下载，这里如果不特殊指定版本，默认安装最新版</p>
<p>（9）查询某个库的所有版本</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda search numpy</span><br></pre></td></tr></table></figure>

<p>表示查询 numpy 这个库当前可供安装的所有版本</p>
<p>（10）在当前 conda 环境中删除某个库</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda uninstall numpy <span class="comment"># 也可以把 uninstall 换成 remove</span></span><br></pre></td></tr></table></figure>

<p>（11）在当前 conda 环境下启动 Jupyter Notebook</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter notebook</span><br></pre></td></tr></table></figure>

<p>启动以后，prompt 中不能再执行其他命令行，如果想关闭 jupyter notebook，可以直接 ctrl+C 从命令行中关闭</p>
<p>（12）删除某个 conda 虚拟环境</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda deactivate py3.9</span><br><span class="line">conda remove -n py3.9 --all</span><br></pre></td></tr></table></figure>

<p>先从当前虚拟环境中退出，然后进行删除，-n 是命令缩写，–all 表示把该环境中安装的所有库也都一并删除 </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E6%80%BB%E7%BB%93%E5%91%BD%E4%BB%A4.png" alt="image-20250727095247790"></p>
<h2 id="Jupyter-Nodebook"><a href="#Jupyter-Nodebook" class="headerlink" title="Jupyter Nodebook"></a><strong>Jupyter Nodebook</strong></h2><h3 id="魔法命令"><a href="#魔法命令" class="headerlink" title="魔法命令"></a><strong>魔法命令</strong></h3><p>Jupyter Notebook 中的所有魔法命令都是通过 % 开头的，我们介绍几个比较常用的魔法命令</p>
<p>（1）<code>%%writefile</code>命令</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%%writefile output.txt</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_hello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello!!!&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>该命令的作用是把当前单元格中所有的代码原样输出到目标文件中，这里我们选择输出到 output.txt 中，执行以后会在当前目录下自动创建 output.txt 这个文件，我们也可以选择其他后缀（如 .py 等）</p>
<p>（2）<code>%pycat</code>命令</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%%writefile tests.py</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">  <span class="keyword">return</span> a+b</span><br><span class="line"><span class="built_in">print</span>(add(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">%pycat tests.py</span><br></pre></td></tr></table></figure>

<p>该命令的作用是显示目标文件中的代码（只是显示代码本身，而不会执行），类似于 Linux 中的 cat 指令，这里执行以后会在当前单元格下方显示 tests.py 文件的内容</p>
<p>（3）<code>%run</code>命令</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%%writefile tests.py</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Test</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;test <span class="subst">&#123;name&#125;</span> successfully&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">%run tests.py</span><br><span class="line">Test(<span class="string">&quot;jupyter&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这里<code>%run</code>命令的方法就相当于 import 命令，指在当前单元格中引入 tests.py 文件，此时我们即可执行 tests.py 中的函数 Test，上面这种写法等价于以下两种写法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># version-1</span></span><br><span class="line"><span class="keyword">from</span> tests <span class="keyword">import</span> Test</span><br><span class="line">Test(<span class="string">&quot;Jupyter&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># version-2</span></span><br><span class="line"><span class="keyword">import</span> tests</span><br><span class="line">test.Test(<span class="string">&quot;Jupyter&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>值得注意的是，如果我们使用 %run 指令，我们需要给出 tests.py 文件的全称，包括后缀；而如果我们使用 import 指令，则我们只需要引用 test 的文件名，而不需要再加上后缀</p>
<p>（4）<code>%time</code>和<code>%%time</code>指令</p>
<p>其中一个百分号+time 只能评估其后面<strong>紧跟</strong>的一条指令完成运行所需要的时间</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%time data = [i*i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>)]</span><br></pre></td></tr></table></figure>

<p>而两个百分号+time 则可以用来评估<strong>整个单元格</strong>运行完成所需要的时间</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%%time</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">time.sleep(<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure>

<p>使用 time 指令只会进行一次评估，如果想根据程序运行时间动态调整评估次数（比如多测几次提高可靠性），我们可以使用 timeit 指令，该指令用法和 time 指令完全相同</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%%timeit</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">time.sleep(<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure>

<p>（4）<code>%whos</code>指令</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">123</span></span><br><span class="line">%whos</span><br></pre></td></tr></table></figure>

<p>该指令用来显示当前单元格及其之前所有的单元格中，所有被引入的库（module），调用的函数（function），以及定义过的变量（var）</p>
<p>（5）<code>%lsmagic</code>和<code>%magic</code>指令</p>
<p>如果想查找更多魔法指令，可以通过 lsmagic 指令显示所有的魔法指令，通过 magic 指令详细查看每个魔法指令的用法</p>
<h2 id="Numpy数组"><a href="#Numpy数组" class="headerlink" title="Numpy数组"></a><strong>Numpy数组</strong></h2><p>Numpy 是常用的 python 开源的科学计算库，全称为 Numerical Python，在机器学习中经常使用，numpy 库中最常用的结构就是其自带的数组 array，相比于 python 中的列表 list 而言，array 支持向量和矩阵运算，在操作过程中会更加简单</p>
<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a><strong>基础知识</strong></h3><p>通过调用<code>np.arange()</code>方法创建数组，可以传入参数表示我们创建的数组长度</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = np.arange(n + <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>如果 n &#x3D; 10，我们创建的 array 就是（0,1,2,3,4,5,6,7,8,9,10）</p>
<p>我们可以对创建出的数组 x 直接做运算，对应的运算会作用于数组的每一个元素，比如我们可以写<code>x**2</code>则表示把数组的每一个元素都取平方</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x_sum = np.<span class="built_in">sum</span>(x**<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>最后我们可以调用<code>np.sum()</code>方法对数组中每个元素求和，返回一个整型值</p>
<p>使用 numpy 数组的效率要比 list 本身的效率高很多，且随着数据集规模的增加，这种效率的提升会更加明显</p>
<h3 id="Ndarray-对象创建"><a href="#Ndarray-对象创建" class="headerlink" title="Ndarray 对象创建"></a><strong>Ndarray 对象创建</strong></h3><p>通过调用<code>np.array()</code>方法，并且传入 python 中的列表结构，我们即可用已有列表初始化出一个 numpy 数组，在机器学习中，我们把一维数组一般称为<strong>向量</strong>，而多维数组一般称为<strong>矩阵</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line">A = np.array([</span><br><span class="line">    [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">    [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">])</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(A)</span><br></pre></td></tr></table></figure>

<p>通过<code>np.array()</code>创建出来的数组，有一些简单的属性，比如可以获知其维数，形状，大小，元素种类等</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数组维度 -&gt; 数组有几行</span></span><br><span class="line">a.ndim</span><br><span class="line">A.ndim</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数组形状 -&gt; 数组为几行几列</span></span><br><span class="line">a.shape</span><br><span class="line">A.shape</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数组大小 -&gt; 数组内元素个数</span></span><br><span class="line">a.size</span><br><span class="line">A.size</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数组属性 -&gt; 数组内元素种类</span></span><br><span class="line">a.dtype</span><br><span class="line">A.dtype</span><br></pre></td></tr></table></figure>

<h3 id="Numpy-数组创建的便捷方式"><a href="#Numpy-数组创建的便捷方式" class="headerlink" title="Numpy 数组创建的便捷方式"></a><strong>Numpy 数组创建的便捷方式</strong></h3><p>通过调用<code>np.ones()</code>方法，可以创建全是 1 的数组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建长度为 10 的向量</span></span><br><span class="line">np.ones(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定元素类型为整型，默认为浮点型</span></span><br><span class="line">np.ones(<span class="number">10</span>, dtype=<span class="string">&#x27;int32&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定数组形状为2行4列矩阵，也可以创建更高维的矩阵</span></span><br><span class="line">np.ones(shape=(<span class="number">2</span>,<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成形状和 A 数组相同的全 1 数组</span></span><br><span class="line">np.ones_like(A)</span><br></pre></td></tr></table></figure>

<p>通过调用<code>np.zeros()</code>方法，可以创建全是 0 的数组，该构造方式的参数和<code>np.ones()</code>完全相同，只是前者构造全 0 数组，后者构造全 1 数组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">np.zeros(<span class="number">8</span>)</span><br><span class="line">np.zeros(shape=(<span class="number">2</span>,<span class="number">4</span>))</span><br><span class="line">np.zeros_like(A)</span><br><span class="line">np.zeros(<span class="number">8</span>, dtype=<span class="string">&quot;int32&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>通过调用<code>np.full()</code>方法，可以创建全是指定值的数组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 长度10， 填充值全为123</span></span><br><span class="line">np.full(<span class="number">10</span>, <span class="number">123</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 形状2行4列， 填充值全为123</span></span><br><span class="line">np.full((<span class="number">2</span>, <span class="number">4</span>), <span class="number">123</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 与 A 形状相同，填充值全为123</span></span><br><span class="line">np.full_like(A, <span class="number">123</span>) </span><br></pre></td></tr></table></figure>

<p>通过调用<code>np.empty()</code>方法，可以创建空数组，这里的空，指的是没有经过初始化的数组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">np.empty(<span class="number">10</span>)</span><br><span class="line">np.empty(shape=(<span class="number">2</span>,<span class="number">4</span>))</span><br><span class="line">np.empty_like(A)</span><br></pre></td></tr></table></figure>

<p>通过调用<code>np.arange()</code>方法，可以创建等差数列形成的数组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建长度为 10 的一维数组，元素从 0 开始</span></span><br><span class="line">np.arange(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用 [1, 10) 中的元素，步长为2，构建数组</span></span><br><span class="line">np.arange(<span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 先用 [0, 10) 中的元素构建一维数组，再把形状改为2行5列的矩阵</span></span><br><span class="line">np.arange(<span class="number">10</span>).reshape(<span class="number">2</span>,<span class="number">5</span>) </span><br></pre></td></tr></table></figure>

<p>通过调用<code>linspace()</code>方法，可以形成和<code>arange()</code>相类似的效果，只不过前者的区间是左闭右闭，后者的区间是左闭右开，注意最后一个参数表示的生成数字的<strong>个数</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># [0, 10] 在此之间生成5个数</span></span><br><span class="line">np.linspace(<span class="number">0</span>, <span class="number">10</span>, <span class="number">5</span>) </span><br></pre></td></tr></table></figure>

<p><strong>随机数模块 random</strong></p>
<p>该模块用于生成随机数，也可以用来生成元素是随机数的数组</p>
<p>通过调用<code>random.random()</code>方法或者<code>random.rand()</code>方法，可以生成元素都是 [0, 1] 中随机数的数组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成[0, 1]的随机数</span></span><br><span class="line">np.random.random() </span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成长度为5的随机数向量</span></span><br><span class="line">np.random.random(<span class="number">5</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成2行4列的随机数矩阵</span></span><br><span class="line">np.random.random((<span class="number">2</span>, <span class="number">4</span>)) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成[0, 1]的随机数</span></span><br><span class="line">np.random.rand()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成长度为5的随机数向量</span></span><br><span class="line">np.random.rand(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成三维数组</span></span><br><span class="line">np.random.rand(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) </span><br></pre></td></tr></table></figure>

<p>通过调用<code>random.randint()</code>方法，可以生成元素都是随机<strong>整数</strong>的数组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成[0,5)之间的随机数</span></span><br><span class="line">np.random.randint(<span class="number">5</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成[5,10)之间的随机数</span></span><br><span class="line">np.random.randint(<span class="number">5</span>, <span class="number">10</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 用[5,10)的随机数生成长度为8的数组</span></span><br><span class="line">np.random.randint(<span class="number">5</span>,<span class="number">10</span>,size=<span class="number">8</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 用[5,10)的随机数生成2行4列的数组</span></span><br><span class="line">np.random.randint(<span class="number">5</span>,<span class="number">10</span>,size=(<span class="number">2</span>,<span class="number">4</span>)) </span><br></pre></td></tr></table></figure>

<p>通过在代码中加入<code>random.seed()</code>方法，可以初始化固定的随机种子，确保每次运行代码，随机数生成函数所生成的随机数都相同，确保不会出现随机序列可变的情况</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不管运行多少次，得到的数组内容都是相同的</span></span><br><span class="line">np.random.randint(<span class="number">5</span>,<span class="number">10</span>,size=(<span class="number">2</span>,<span class="number">4</span>))</span><br></pre></td></tr></table></figure>

<p>通过调用<code>random.randn()</code>方法，可以生成元素服从标准正态分布 N(0,1) 的数组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成一个服从标准正态分布的随机数</span></span><br><span class="line">np.random.randn()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成长度为5的向量，其中元素分布服从标准正态分布</span></span><br><span class="line">np.random.randn(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成2行4列的矩阵，其中元素分布服从标准正态分布</span></span><br><span class="line">np.random.randn(<span class="number">2</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<p>通过调用<code>random.normal()</code>方法，可以生成元素服从均值为 loc，标准差为 scale 的正态分布的数组</p>
<p>这里需要注意的是，normal 和 uniform 限制数组形状的参数名为 size，而 arange 和 linspace 限制数组形状的参数名为 shape</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不传参数时，默认为标准正态分布</span></span><br><span class="line">np.random.normal()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定均值loc=1.5，标准差scale=2.5，形状为2行3列</span></span><br><span class="line">np.random.normal(loc=<span class="number">1.5</span>, scale=<span class="number">2.5</span>, size=(<span class="number">2</span>,<span class="number">3</span>))</span><br></pre></td></tr></table></figure>

<p>通过调用<code>random.uniform()</code>方法，可以生成元素服从均匀分布的数组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不传参数时，默认为[0, 1]的均匀分布</span></span><br><span class="line">np.random.uniform()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成在长度为5，元素服从[1, 5]均匀分布的向量</span></span><br><span class="line">np.random.uniform(<span class="number">1</span>, <span class="number">5</span>, size=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成元素服从[2.5, 10.0]均匀分布，形状为2行4列的矩阵</span></span><br><span class="line">np.random.uniform(low=<span class="number">2.5</span>, high=<span class="number">10.0</span>, size=(<span class="number">2</span>,<span class="number">4</span>))</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/numpy%E5%9F%BA%E7%A1%80.png" alt="image-20250727160510711"></p>
<h3 id="数组的基础索引"><a href="#数组的基础索引" class="headerlink" title="数组的基础索引"></a><strong>数组的基础索引</strong></h3><p>前期准备工作，首先我们创建如下的数组：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.arange(<span class="number">10</span>)</span><br><span class="line">A = np.arange(<span class="number">20</span>).reshape(<span class="number">4</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p>这里小写字母一般表示向量，大写字母一般表示矩阵，这里对于 A 矩阵，我们先生成一维等差序列，然后再转成我们想要的二维矩阵，这是比较常用的一个初始化方法</p>
<p><strong>一维数组切片</strong></p>
<p>一维数组切片的实现和 list 的实现方式相同，通过 [ : : ] 的形式实现，其中第一个位置填写起点，空置则表示从 0 开始，第二个位置填写终点（开区间取不到终点），空置表示到最后一个为止，第三个位置填写取数的步长，步长可以为负，此时起点和终点也要对应交换，表示从原序列中倒序取值</p>
<p><strong>二维数组切片</strong></p>
<p>二维数组切片可以看成是两个一维数组的切片，通过逗号形式分隔开，完整的实现为<code>[行起点索引 : 行终点索引 : 行步长, 列起点索引 : 列终点索引 : 列步长]</code>，以下是几个具体的示例</p>
<p>矩阵取其中某个单点，可以通过形如 C++ 中二维数组的方式进行选取，只是通过<strong>逗号</strong>把行下标索引和列下标索引进行间隔</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A[<span class="number">0</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<p>取矩阵中某一行的所有值，可以通过<code>[index,:]</code>的形式取出，只给出要选择的行下标索引，列下标索引空置，再加一个分号即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A[<span class="number">0</span>,:] <span class="comment"># 后面的 : 可以省略，效果完全一样</span></span><br></pre></td></tr></table></figure>

<p>特别的，如果想取出 A 的最后一行元素，可以填写 -1 作为行下标索引</p>
<p>而如果想取矩阵某一列的所有值，可以通过<code>[:,index]</code>的形式取出，此时需要先写冒号再写逗号，最后给出想取出的列的下标索引</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A[:,<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<p>特别的，如果想取出 A 的最后一列元素，可以填写 -1 作为列下标索引</p>
<p>如果想从 A 中取出一个子矩阵，则需要填写各个位置的参数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A[<span class="number">0</span>:<span class="number">2</span>:, <span class="number">1</span>:<span class="number">3</span>:]</span><br></pre></td></tr></table></figure>

<p>表示取出矩阵第 0 行到第 1 行，第 1 列到第 2 列的元素组成的一个子矩阵</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A[::-<span class="number">1</span>, ::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>表示把矩阵中的所有的元素都进行倒序处理</p>
<p><strong>注意</strong>：在 Numpy 中，对数组切片做修改，是会作用到原数组上的，这是因为 Numpy 在处理较大数据集合时，为了避免内部总是进行数据拷贝，对数组进行了<strong>引用</strong>的处理方式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X = A[:<span class="number">2</span>:, :<span class="number">3</span>:]</span><br><span class="line">X[<span class="number">0</span>, <span class="number">0</span>] = <span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>此时 A 数组（0,0）位置的元素会被修改成 123</p>
<p>如果我们就是想只修改切片，但是不修改原数组，可以使用切片的方法，也就是<code>copy()</code>方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X = A[:<span class="number">2</span>:, :<span class="number">3</span>:].copy()</span><br></pre></td></tr></table></figure>

<p>此时再修改 X 数组，就不会对 A 数组产生影响了</p>
<h3 id="数组的合并与拆分"><a href="#数组的合并与拆分" class="headerlink" title="数组的合并与拆分"></a><strong>数组的合并与拆分</strong></h3><p> <strong>数组的合并</strong></p>
<p>假设我们有一个二维数组 X 和一个一维数组 a 如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">a = np.array([<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>])</span><br></pre></td></tr></table></figure>

<p>现在我们想把 a 数组拼在 X 数组后面，可以调用<code>concatenate()</code>方法，该方法要求 X 和 a 的<strong>维度</strong>必须相同，现在 X 是二维数组，a 是一维数组，因此我们需要先把 a 改成二维数组，也就是1行4列的二维数组才能进行合并</p>
<p>该方法支持传入一个元组，从前到后把元组中的数组依次合并</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A = np.concatenate((X, a.reshape((<span class="number">1</span>, <span class="number">4</span>)))</span><br><span class="line"><span class="built_in">print</span>(A)</span><br></pre></td></tr></table></figure>

<p>除此之外，Numpy 还提供了更为方便的<code>vstack()</code>和<code>hstack()</code>方法，分别用来竖直方向合并和水平方向合并，这两个方法不再要求合并数组的维度相同，可以直接进行合并</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 竖直方向合并，把 a 拼接在 X 后面</span></span><br><span class="line">np.vatsck(X, a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 水平方向合并，把 b 拼在 X 右边</span></span><br><span class="line">b = np.full(shape=(<span class="number">3</span>,<span class="number">1</span>), <span class="number">123</span>)</span><br><span class="line">np.hstack(X, b)</span><br></pre></td></tr></table></figure>

<p>当然也可以使用<code>concatenate()</code>进行水平方向合并（该函数默认的事竖直方向的合并），只需要设置 axis 参数为 1 即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = np.full(shape=(<span class="number">3</span>,<span class="number">1</span>), <span class="number">123</span>)</span><br><span class="line">np.concatenate((X, b), axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p><strong>数组拆分</strong></p>
<p>我们可以通过调用<code>np.split()</code>方法进行数组的拆分操作，如果想对行进行拆分，则默认 axis 参数为 0 即可，如果想对列进行拆分，则需要额外设置 axis 参数为 1</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">X1, X2 = np.split(X, [-<span class="number">1</span>], axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>这里表示对 X 数组的最后一列进行拆分，分别得到一个3行3列的数组，一个3行1列的数组，用 X1 和 X2 两个变量进行接收</p>
<p>如果不设置 axis 参数，则表示对最后一行进行拆分，得到一个2行4列的数组，一个1行4列的数组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X1, X2 = np.split(X, [-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<p>除此之外，和<code>vstack()</code>与<code>hstack()</code>相对的，Numpy 也提供了<code>vsplit()</code>和<code>hsplit()</code>方法，分别负责竖直（行拆分）和水平方向（列拆分）的拆分</p>
<p>这两个函数支持以一个列表的形式传入参数，以行拆分为例，如果我们传入 [x1, x2, x3] 则表示把原数组拆分为 4 段，分别是 [ 0, x1 ), [ x1, x2 ), [ x2, x3 ), [ x3, 最后 )，如果加入更多参数则同理</p>
<p>换言之，我们传进去的就是我们想切割的<strong>分点</strong>位置</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按行拆分，拆分为 [0, 2) 和 [2, 最后) 两部分</span></span><br><span class="line">X1, X2 = np.vsplit(X, [<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按列拆分，拆分为 [0, 1) 和 [1, 2) 和 [2, 最后) 三部分</span></span><br><span class="line">X1, X2, X3 = np.hsplit(X, [<span class="number">1</span>, <span class="number">2</span>])</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E6%80%BB%E7%BB%93%E5%90%88%E5%B9%B6%E6%8B%86%E5%88%86.png" alt="image-20250727232712118"></p>
<h3 id="矩阵运算"><a href="#矩阵运算" class="headerlink" title="矩阵运算"></a><strong>矩阵运算</strong></h3><p><strong>一元运算</strong></p>
<p>所谓一元运算，就是对向量 &#x2F; 矩阵中的每一个元素进行自运算（比如平方，开根之类，不涉及到其他元素，只涉及到每个元素自身），Numpy 数组直接对<strong>数组名</strong>运算，对应的运算就能作用到数组中的每一个元素上</p>
<p>如果我们相对数组中每个元素平方，在 list 中我们需要：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">my_list1 = [i**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> my_list]</span><br></pre></td></tr></table></figure>

<p>而在 Numpy 数组中，我们可以直接：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X = np.arange(<span class="number">5</span>)</span><br><span class="line">X1 = X**<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>下面是对于 Numpy 数组常见的<strong>一元</strong>运算：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对每个元素取绝对值</span></span><br><span class="line">np.<span class="built_in">abs</span>(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对每个元素开二次方根</span></span><br><span class="line">np.sqrt(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对每个元素取平方</span></span><br><span class="line">np.square(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对每个元素取以 e 为底的指数</span></span><br><span class="line">np.exp(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对每个元素取以 e 为底的对数</span></span><br><span class="line">np.log(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对每个元素取以 2 为底的对数</span></span><br><span class="line">np.log2(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对每个元素取以 10 为底的对数</span></span><br><span class="line">np.log10(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对每个元素向上取整</span></span><br><span class="line">np.ceil(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对每个元素向下取整</span></span><br><span class="line">np.floor(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对每个元素科学取整（整数位为奇数四舍五入，整数位为偶数四舍六入）</span></span><br><span class="line">np.<span class="built_in">round</span>(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对每个元素取正弦</span></span><br><span class="line">np.sin(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对每个元素取余弦</span></span><br><span class="line">np.cos(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对每个元素取正切</span></span><br><span class="line">np.tan(X)</span><br></pre></td></tr></table></figure>

<p><strong>二元运算</strong></p>
<p>二元运算指的是对矩阵 &#x2F; 向量中的每一个元素而言，都给出另一个元素与之进行运算（比如最常见的四则运算），每一个二元运算背后，Numpy 都为我们封装好了底层的实现函数，比如对于加法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>表示对 X 中的每个元素都加上 1，底层其实是调用了<code>add()</code>方法实现的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.add(X, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>以下是 Numpy 中常见的二元运算：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对每个元素都加 C</span></span><br><span class="line">X + C</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对每个元素都减 C</span></span><br><span class="line">X - C</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对每个元素都乘以 C</span></span><br><span class="line">X * C</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对每个元素都除以 C</span></span><br><span class="line">X / C</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对每个元素都整除 C</span></span><br><span class="line">X // C</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对每个元素都进行 C 次方</span></span><br><span class="line">X**C</span><br></pre></td></tr></table></figure>

<p><strong>矩阵运算</strong></p>
<p>可以用 Numpy 中的数组实现线性代数中矩阵的运算，以下是 Numpy 中常用的矩阵运算，假设我们有以下两个 2 × 2 的矩阵 X 和 Y</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X = np.arange(<span class="number">10</span>, <span class="number">40</span>, <span class="number">10</span>).reshape(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">Y = np.arange(<span class="number">1</span>, <span class="number">4</span>).reshape(<span class="number">2</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>对其可以做下面的矩阵运算：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 矩阵加法</span></span><br><span class="line">X + Y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 矩阵减法</span></span><br><span class="line">X - Y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 矩阵哈达玛积（对应位置的元素相乘即可）</span></span><br><span class="line">X * Y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 矩阵乘法</span></span><br><span class="line">X.dot(Y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 矩阵相除（对应位置的元素相除即可）</span></span><br><span class="line">X / Y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 矩阵转置</span></span><br><span class="line">X.T</span><br><span class="line">X.transpose(X) <span class="comment"># 二维矩阵的转置</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 矩阵取逆</span></span><br><span class="line">np.linalg.inv(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 矩阵求特征值、特征向量</span></span><br><span class="line">np.linalg.elg(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 矩阵求行列式</span></span><br><span class="line">np.linalg.det(X)</span><br></pre></td></tr></table></figure>

<p>需要注意的是，只有<strong>方阵</strong>才可以求行列式和逆矩阵，如果对矩阵不太了解，可能需要去复习线性代数</p>
<p><strong>总结</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E7%9F%A9%E9%98%B5%E6%80%BB%E7%BB%93.png" alt="image-20250728000013472"></p>
<h3 id="统计运算"><a href="#统计运算" class="headerlink" title="统计运算"></a><strong>统计运算</strong></h3><p>Numpy 数组的统计运算，不仅比 list 的相同功能更加高效，也支持更加灵活的实现方式和功能，以下是常用的统计函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">X = np.linspace(<span class="number">1</span>, <span class="number">20</span>, <span class="number">20</span>).reshapr(<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计最大值元素</span></span><br><span class="line">np.<span class="built_in">max</span>(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计最小值元素</span></span><br><span class="line">np.<span class="built_in">min</span>(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计每列最小值元素</span></span><br><span class="line">np.<span class="built_in">min</span>(X, axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计每行最小值元素</span></span><br><span class="line">np.<span class="built_in">max</span>(X, axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 求所有元素之和</span></span><br><span class="line">np.<span class="built_in">sum</span>(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 求每一列元素之和</span></span><br><span class="line">np.<span class="built_in">sum</span>(X, axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 求每一行元素之和</span></span><br><span class="line">np.<span class="built_in">sum</span>(X, axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 求所有元素均值</span></span><br><span class="line">np.mean(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 求所有元素中位数</span></span><br><span class="line">np.median(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 所有元素的标准差</span></span><br><span class="line">np.std(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 求所有元素的方差</span></span><br><span class="line">np.var(X)</span><br></pre></td></tr></table></figure>

<p>还有一些不太常用，但是比较有用的统计函数，下面进行介绍：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 统计矩阵中最大值和最小值的差</span></span><br><span class="line">np.ptp(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 求矩阵的各个分位数</span></span><br><span class="line">q = np.arange(<span class="number">0</span>, <span class="number">100</span>, <span class="number">5</span>) <span class="comment"># 生成 0 15 50 75 100 这五个常用的分位数</span></span><br><span class="line">np.percentile(X, q) <span class="comment"># 分别得到 X 的 0% 25% 50% 75% 100% 分位数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 求矩阵每一行 / 每一列前缀和</span></span><br><span class="line">np.cumsum(X, axis=<span class="number">0</span>) <span class="comment"># 按列求前缀和</span></span><br><span class="line">np.cumsum(X, axis=<span class="number">1</span>) <span class="comment"># 按行求前缀和</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 求矩阵每一行 / 每一列差分</span></span><br><span class="line">np.diff(X, axis=<span class="number">0</span>) <span class="comment"># 按列求差分</span></span><br><span class="line">np.diff(X, axis=<span class="number">1</span>) <span class="comment"># 按行求差分</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把矩阵每一行 / 每一列累乘</span></span><br><span class="line">np.prod(X, axis=<span class="number">0</span>) <span class="comment"># 按列求累乘</span></span><br><span class="line">np.prod(X, axis=<span class="number">1</span>) <span class="comment"># 按行求累乘</span></span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E7%BB%9F%E8%AE%A1.png" alt="image-20250728001626521"></p>
<h3 id="arg运算"><a href="#arg运算" class="headerlink" title="arg运算"></a><strong>arg运算</strong></h3><p>arg 是 argument 的缩写，是机器学习中常见的概念，一般用于表示<strong>函数取某个特殊值的时候，对应的自变量值</strong>，也就是说此时我们不关注函数值本身，而是关心函数取这个值的时候，对应的 x 是多少，比如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arg f(x) = k -&gt; x = x1, x2</span><br></pre></td></tr></table></figure>

<p>该表达式表示，当 f(x) &#x3D; k 时，x 取到 x1 和 x2 这两个值</p>
<p>对于 Numpy 数组而言，其支持<code>argmax()</code>和<code>argmin()</code>运算，分别表示数组中的最大值对应的<strong>下标索引</strong>，以及数组中的最小值对应的<strong>下标索引</strong>，因为我们在算法中接触过数组和函数等价的概念，因此这里数组值可以等价为函数值，数组下标可以等价为函数自变量</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">X = np.random.random(<span class="number">5</span>, <span class="number">10</span>, size=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># X 中小值的下标</span></span><br><span class="line">np.argmin(X)</span><br><span class="line">X[np.argmin(X)] <span class="comment"># 最小值本身</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># X 中最大值的下标</span></span><br><span class="line">np.argmax(X)</span><br><span class="line">X[np.argmax(X)] <span class="comment"># 最大值本身</span></span><br></pre></td></tr></table></figure>

<p>这里 argmin 表示 arguments of the minimum，argmax 表示 arguments of maximum</p>
<h3 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a><strong>数组排序</strong></h3><p><strong>sort方法</strong></p>
<p>Numpy 自带一个用于排序的 sort，称为<code>np.sort()</code>方法，其中 Numpy 数组本身也自带一个 sort 方法，这两个方法的区别在于，Numpy 提供的排序不会对数组本身进行排序，而是返回排好序的新数组，而数组本身调用 sort 会进行原地排序，自身顺序会改变</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">X = np.arange(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 random 模块中的 shuffle() 方法进行打乱</span></span><br><span class="line">np.random.shuffle(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 np.sort() 排序</span></span><br><span class="line">X1 = np.sort(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用数组自带的 sort() 排序</span></span><br><span class="line">X.sort()</span><br></pre></td></tr></table></figure>

<p><strong>使用索引</strong></p>
<p>假设我们有一个乱序的数组，我们可以调用<code>np.argsort()</code>方法，对索引大小进行排序，也就是输出乱序数组中元素从小到大排序后对应的原始索引值</p>
<p>假设原数组为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">key : <span class="number">5</span> <span class="number">2</span> <span class="number">3</span> <span class="number">1</span> <span class="number">4</span> <span class="number">7</span></span><br><span class="line">ind : <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>使用<code>np.argsort()</code>排序以后，得到的索引数组为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr : <span class="number">3</span> <span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">0</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p><strong>partition分区</strong></p>
<p>该方法用于实现类似于快速排序中对元素分区的效果，<code>np.partition()</code>函数接受一个参数 K，表示以有序序列中排名第 K 的元素作为分界线，比它小的都在左侧，比它大的都在右侧</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X = np.arange(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择有序序列中第 5 个元素作为分界线</span></span><br><span class="line">np.partition(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p>该方法也支持显示下标的情况，如果我们调用<code>np.argpartition()</code>传入参数 5 的话，则会进行同样的分类，只不过每个位置显示的不是元素本身的值，而是他们在原序列中的<strong>原始下标</strong></p>
<p><strong>高维数组</strong></p>
<p>高维数组同样可以调用上述<strong>所有</strong>的排序方法，只是默认会对其按列排序，如果设置 axis&#x3D;1 则会按行进行排序，以按列排序为例，会使得每一行都变成升序；以按行排序为例，会使得每一列都变成升序</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">X = np.arange(<span class="number">12</span>).reshape(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按列升序排序</span></span><br><span class="line">np.sort(X, axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按行升序排序</span></span><br><span class="line">np.sort(X, axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h3 id="神奇索引"><a href="#神奇索引" class="headerlink" title="神奇索引"></a><strong>神奇索引</strong></h3><p>神奇索引用于快速对数组进行索引访问，对于一个一维数组，假设我们想获取其 2 5 8 位置的值，或者想获取其 1 3 5, 2 4 6 位置的值，并且组织成2行3列的矩阵的形式，此时我们都可以用<strong>神奇索引</strong>实现对应的功能</p>
<p>具体来讲，我们只需要把想获取的索引位置和格式写进一个数组，把这个索引数组整体当成下标喂给原数组即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">X = np.arange(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取 X 下标 2 5 8 位置的元素</span></span><br><span class="line">index = np.array([<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>])</span><br><span class="line">X[index]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取 X 下标 1 3 5， 2 4 6 位置的元素，并且组成2行3列矩阵</span></span><br><span class="line">index = np.array([[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>], [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]])</span><br><span class="line">X[index]</span><br></pre></td></tr></table></figure>

<p>也就是说，对于一维数组而言，我们使用<strong>神奇索引</strong>的主要目的就是取出若干个离散的下标所对应的数组元素</p>
<p>神奇索引同样适用于二维矩阵，我们之前说过，二维矩阵的切片满足<code>X[行起始下标:行终点下标(不包含):行步长, 列起始下标:列终点下标(不包含):列步长]</code>，我们使用的神奇索引 row 代表行，col 代表列，可以分别用来代替逗号前后的内容</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">X = np.arange(<span class="number">12</span>),reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">row = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>])</span><br><span class="line">col = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">X[row, col]</span><br></pre></td></tr></table></figure>

<p>这里表示从 X 矩阵中取出（0,0）（1,1）（0,2）这三个位置的元素</p>
<p>如果我们从取一整行或者一整列去取元素，只需要结合二维数组原始的切片即可实现</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X[<span class="number">1</span>:<span class="number">2</span>:, col]</span><br><span class="line">X[row, <span class="number">2</span>:<span class="number">4</span>:]</span><br></pre></td></tr></table></figure>

<p>这两例分别表示取 X 矩阵第一行，第 0 1 2 列的三个元素，以及取 X 矩阵第 2 3 列，第 0 1 0 行的六个元素</p>
<p>最后，Numpy 数组也支持以 bool 类型的数组进行数据索引，比如我们给出如下的 col 数组：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">col = [<span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">True</span>, <span class="literal">False</span>]</span><br><span class="line">X[<span class="number">0</span>:<span class="number">1</span>:, col]</span><br></pre></td></tr></table></figure>

<p>则表示从 X 矩阵中取出第 0 行，第 0 2 列的两个元素</p>
<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a><strong>比较</strong></h3><p>在神奇索引的最后，我们发现 Numpy 数组支持以 bool 类型的下标进行索引，那么我们该如何构造 bool 类型的下标索引呢？答案是可以使用比较的方法</p>
<p>以下是常用的比较逻辑，所有比较的结果都是和 X <strong>相同形状</strong>的 bool 数组，对应的每个位置表示 X 这个位置的元素是否满足比较结果，是则为 True，否则为 False：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 小于逻辑</span></span><br><span class="line">X &lt; <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 等于逻辑</span></span><br><span class="line">X == <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不等逻辑</span></span><br><span class="line">X != <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 简单的方程判定</span></span><br><span class="line">X * X == <span class="number">9</span></span><br></pre></td></tr></table></figure>

<p>现在我们只是得到了一个 bool 数组，如果想把满足这些比较条件的元素对应的数值获取到，则还需要结合神奇索引才能够实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 找到 X 中所有比 3 大的数</span></span><br><span class="line">X[X &gt; <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找到 X 中所有的偶数</span></span><br><span class="line">X[X % <span class="number">2</span> == <span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<p><strong>比较和统计的结合</strong></p>
<p>以下是常用的统计函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 统计 X 中小于 5 的元素个数</span></span><br><span class="line">np.count_nonzero(X &lt; <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计 X 中小于 5 的元素个数</span></span><br><span class="line">np.<span class="built_in">sum</span>(X &lt; <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断 X 中是否存在小于 0 的元素</span></span><br><span class="line">np.<span class="built_in">any</span>(X &lt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断 X 中的元素是否全都小于 0</span></span><br><span class="line">np.<span class="built_in">all</span>(X &lt; <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>需要说明的是，count_nonzero 和 sum 函数都是统计的对应比较条件所得到的 bool 数组中，对应的 True 位置的个数，any 函数相当于存在量词命题判断，all 函数相当于全程量词命题判断</p>
<p>上述函数加上 axis 参数即可作用于二维数组的行和列，也就是对每一行或每一列统计：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 统计每一行的偶数个数</span></span><br><span class="line">np.<span class="built_in">sum</span>(X%<span class="number">2</span>==<span class="number">0</span>, axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断每一列是否有不大于 2 的元素</span></span><br><span class="line">np.<span class="built_in">all</span>(X&gt;<span class="number">2</span>, axis=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>比较运算也可以和逻辑运算符号（&amp; | ~）结合，实现相对复杂的比较逻辑：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">np.<span class="built_in">sum</span>((X&lt;<span class="number">5</span>)&amp;(X&gt;<span class="number">3</span>))</span><br><span class="line">np.<span class="built_in">sum</span>((X&lt;<span class="number">1</span>)|(X&gt;<span class="number">6</span>))</span><br><span class="line">np.<span class="built_in">sum</span>(~(X==<span class="number">0</span>))</span><br></pre></td></tr></table></figure>

<h2 id="Matplotlib"><a href="#Matplotlib" class="headerlink" title="Matplotlib"></a><strong>Matplotlib</strong></h2><p>Matplotlib 是我们机器学习中常用的<strong>绘图工具</strong>，该库中的众多命令和函数和 Matlab 都比较类似，这里我们常用的是<code>plot</code>和<code>scatter</code>，其中前者用于绘制<strong>连续图</strong>，后者用于绘制<strong>散点图</strong></p>
<p>当 X 是数据，Y 是观测值的时候，我们一般用 plot 绘制连续图，用于表示数据和观测值之间的关系；当 X 和 Y 都是数据的维度的时候，我们一般用 scatter 绘制散点图，用于表示数据点在二维空间中的分布</p>
<h3 id="plot绘图"><a href="#plot绘图" class="headerlink" title="plot绘图"></a><strong>plot绘图</strong></h3><p><strong>包的引入</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure>

<p><strong>绘制简单曲线</strong></p>
<p>下面我们绘制一条二次函数的曲线：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X = np.arange(-<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>)</span><br><span class="line">Y = X * X</span><br><span class="line">plt.plot(X, Y)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>其中<code>plt.plot()</code>用于绘图，其接收两个参数，分别是数据集合 X 和观测值集合 Y，而<code>plt.show()</code>用于展示已经绘制好的图像，由此我们可以得到一张简单的二次函数的图像：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E4%BA%8C%E6%AC%A1%E5%87%BD%E6%95%B0%E8%BF%9E%E7%BB%AD.png" alt="image-20250728093139947"></p>
<p>这里虽然我们传入的 X 和 Y 都是散点，但是因为点的数量太多，因此曲线看起来是<strong>光滑</strong>的，如果我们把点的个数从 100 锐减到 5 个，则可较为明显地观察到连点成线的痕迹</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E6%A3%B1%E8%A7%92.png" alt="image-20250728093513659"></p>
<p><strong>多个函数的显示</strong></p>
<p>下面我们同时绘制正弦和余弦曲线的函数图：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">X = np.linspace(-<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>)</span><br><span class="line">Y1 = np.sin(X)</span><br><span class="line">Y2 = np.cos(X)</span><br><span class="line">plt.plot(X, Y1)</span><br><span class="line">plt.plot(X, Y2)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>我们只需要分别绘制正弦和余弦，最后一起调用 show 方法显示即可</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E6%AD%A3%E5%BC%A6%E4%BD%99%E5%BC%A6.png" alt="image-20250728093704730"></p>
<p>我们也可以给 plot 方法中传入<code>color</code>参数设置曲线的颜色，比如我们可以把默认颜色改成绿色：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(X, Y1, color=<span class="string">&#x27;green&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>我们也可以给 plot 方法中传入<code>linestyle</code>参数设置曲线的形状，比如我们可以把线形改成虚线：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(X, Y1, linestyle=<span class="string">&#x27;:&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>其他参数</strong></p>
<p>通过调用<code>plt.xlim()</code>和<code>plt.ylim()</code>，我们可以设置 X 轴和 Y 轴的坐标范围，但是有图像绘制的范围还是由 X 数组的范围所决定的，上述两个函数只是设置了坐标轴的最大范围</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plit.xlim(-<span class="number">5</span>, <span class="number">15</span>) <span class="comment"># 设置 x 轴范围为 -5 到 15</span></span><br><span class="line">plit.ylim(-<span class="number">15</span>, <span class="number">5</span>) <span class="comment"># 设置 y 轴范围为 -15 到 5</span></span><br></pre></td></tr></table></figure>

<p>我们也可以通过<code>plt.axis()</code>参数同时设置 X 轴和 Y 轴的范围，先传 X 轴后传 Y 轴即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.axis([-<span class="number">5</span>, <span class="number">15</span>], [-<span class="number">2</span>, <span class="number">2</span>])</span><br></pre></td></tr></table></figure>

<p>通过调用<code>plt.xlabel()</code>和<code>plt.ylabel()</code>，我们可以设置 X 轴和 Y 轴的坐标轴名称</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.xlabel(<span class="string">&#x27;x axis&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;y axis&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>通过调用在 plot 中传入<code>label</code>参数，我们可以设置曲线的名称，最后如果想显示曲线名称，还需要调用<code>plt.legend()</code>方法进行图例显示</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(X, Y1, label=<span class="string">&#x27;sin(x)&#x27;</span>, color=<span class="string">&#x27;green&#x27;</span>)</span><br><span class="line">plt.plot(X, Y2, label=<span class="string">&#x27;cos(x)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>通过设置以上参数，我们的图像则变成了：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E7%BB%98%E5%9B%BE%E5%AE%8C%E5%96%84.png" alt="image-20250728101041394"></p>
<p>最后，我们可以调用<code>plt.title()</code>方法设置图标的名称</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.title(<span class="string">&#x27;my first title&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="scatter绘图"><a href="#scatter绘图" class="headerlink" title="scatter绘图"></a><strong>scatter绘图</strong></h3><p>scatter 和 plot 方法的用法和参数设置等完全相同，只不过前者绘制的是散点图，后者绘制的是连续图，我们以标准二维高斯分布为例，展示 scatter 的绘图效果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X = np.random.normal(<span class="number">0</span>, <span class="number">1</span>, <span class="number">10000</span>)</span><br><span class="line">Y = np.random.normal(<span class="number">0</span>, <span class="number">1</span>, <span class="number">10000</span>)</span><br><span class="line">plt.scatter(X, Y)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>对应的标准二维正态分布示意图如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E9%AB%98%E6%96%AF%E5%88%86%E5%B8%83%E6%95%A3%E7%82%B9.png" alt="image-20250728101422064"></p>
<p>因为图中的点对数量多达 10000 个，我们可以通过设置<code>alpha</code>参数来控制图形透明度，0 表示完全透明，1 表示完全不透明，我们可以设成 0.1</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.scatter(X, Y, alpha=<span class="number">0.1</span>)</span><br></pre></td></tr></table></figure>

<p>修改后的绘图效果如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E9%80%8F%E6%98%8E.png" alt="image-20250728101620410"></p>
<hr>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images/picture.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images/picture.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">Destiny</div><div class="post-copyright__author_desc">跋涉浮尘烛光灭</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://example.com/2025/07/28/ML%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://example.com/2025/07/28/ML%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/')">ML前置知识</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://example.com/2025/07/28/ML%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=ML前置知识&amp;url=http://example.com/2025/07/28/ML%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/&amp;pic=/../images/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A226.jpg" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">MyBlog</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/Python%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>Python与机器学习<span class="tagsPageCount">22</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="/../images/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A263.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/07/25/KNN%E7%AE%97%E6%B3%95/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A224.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">ML入门-KNN算法</div></div></a></div><div class="next-post pull-right"><a href="/2025/07/31/ML%E4%BB%A3%E7%A0%81/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A228.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">ML代码</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2025/07/19/AI%E5%BA%94%E7%94%A8%E4%B8%8E%E5%BC%80%E5%8F%91/" title="AI应用与开发"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A216.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-07-19</div><div class="title">AI应用与开发</div></div></a></div><div><a href="/2025/07/25/KNN%E7%AE%97%E6%B3%95/" title="ML入门-KNN算法"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A224.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-07-25</div><div class="title">ML入门-KNN算法</div></div></a></div><div><a href="/2025/07/31/ML%E4%BB%A3%E7%A0%81/" title="ML代码"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A228.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-07-31</div><div class="title">ML代码</div></div></a></div><div><a href="/2025/07/21/PyQt/" title="PyQt"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A228.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-07-21</div><div class="title">PyQt</div></div></a></div><div><a href="/2025/08/30/LaTeX/" title="LaTeX"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A263.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-08-30</div><div class="title">LaTeX</div></div></a></div><div><a href="/2025/08/04/Transformer/" title="Transformer"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A235.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-08-04</div><div class="title">Transformer</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images/picture.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description"></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://bu.dusays.com/2023/05/13/645fa415e8694.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#ML%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="toc-number">1.</span> <span class="toc-text">ML前置知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%8A%80%E6%9C%AF%E6%A0%88"><span class="toc-number">1.1.</span> <span class="toc-text">基础技术栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80"><span class="toc-number">1.1.1.</span> <span class="toc-text">机器学习基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%9B%86"><span class="toc-number">1.1.2.</span> <span class="toc-text">数据集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%91%E7%9D%A3-%E9%9D%9E%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0"><span class="toc-number">1.1.3.</span> <span class="toc-text">监督 &amp; 非监督学习</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.1.4.</span> <span class="toc-text">机器学习的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%BB%BB%E5%8A%A1"><span class="toc-number">1.1.5.</span> <span class="toc-text">机器学习任务</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Anaconda%E7%8E%AF%E5%A2%83"><span class="toc-number">1.2.</span> <span class="toc-text">Anaconda环境</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2"><span class="toc-number">1.2.1.</span> <span class="toc-text">图形化界面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.2.</span> <span class="toc-text">命令行操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Jupyter-Nodebook"><span class="toc-number">1.3.</span> <span class="toc-text">Jupyter Nodebook</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AD%94%E6%B3%95%E5%91%BD%E4%BB%A4"><span class="toc-number">1.3.1.</span> <span class="toc-text">魔法命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Numpy%E6%95%B0%E7%BB%84"><span class="toc-number">1.4.</span> <span class="toc-text">Numpy数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">1.4.1.</span> <span class="toc-text">基础知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Ndarray-%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA"><span class="toc-number">1.4.2.</span> <span class="toc-text">Ndarray 对象创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Numpy-%E6%95%B0%E7%BB%84%E5%88%9B%E5%BB%BA%E7%9A%84%E4%BE%BF%E6%8D%B7%E6%96%B9%E5%BC%8F"><span class="toc-number">1.4.3.</span> <span class="toc-text">Numpy 数组创建的便捷方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%9F%BA%E7%A1%80%E7%B4%A2%E5%BC%95"><span class="toc-number">1.4.4.</span> <span class="toc-text">数组的基础索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%90%88%E5%B9%B6%E4%B8%8E%E6%8B%86%E5%88%86"><span class="toc-number">1.4.5.</span> <span class="toc-text">数组的合并与拆分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E8%BF%90%E7%AE%97"><span class="toc-number">1.4.6.</span> <span class="toc-text">矩阵运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E8%BF%90%E7%AE%97"><span class="toc-number">1.4.7.</span> <span class="toc-text">统计运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#arg%E8%BF%90%E7%AE%97"><span class="toc-number">1.4.8.</span> <span class="toc-text">arg运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F"><span class="toc-number">1.4.9.</span> <span class="toc-text">数组排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A5%9E%E5%A5%87%E7%B4%A2%E5%BC%95"><span class="toc-number">1.4.10.</span> <span class="toc-text">神奇索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E8%BE%83"><span class="toc-number">1.4.11.</span> <span class="toc-text">比较</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Matplotlib"><span class="toc-number">1.5.</span> <span class="toc-text">Matplotlib</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#plot%E7%BB%98%E5%9B%BE"><span class="toc-number">1.5.1.</span> <span class="toc-text">plot绘图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#scatter%E7%BB%98%E5%9B%BE"><span class="toc-number">1.5.2.</span> <span class="toc-text">scatter绘图</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/08/30/LaTeX/" title="LaTeX"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A263.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="LaTeX"/></a><div class="content"><a class="title" href="/2025/08/30/LaTeX/" title="LaTeX">LaTeX</a><time datetime="2025-08-30T01:47:43.000Z" title="发表于 2025-08-30 09:47:43">2025-08-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/29/%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B/" title="概率与期望"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A262.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="概率与期望"/></a><div class="content"><a class="title" href="/2025/08/29/%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B/" title="概率与期望">概率与期望</a><time datetime="2025-08-29T12:47:37.000Z" title="发表于 2025-08-29 20:47:37">2025-08-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/26/%E6%95%B0%E8%AE%BA%E8%BF%9B%E9%98%B6/" title="数论进阶"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A261.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数论进阶"/></a><div class="content"><a class="title" href="/2025/08/26/%E6%95%B0%E8%AE%BA%E8%BF%9B%E9%98%B6/" title="数论进阶">数论进阶</a><time datetime="2025-08-26T14:56:35.000Z" title="发表于 2025-08-26 22:56:35">2025-08-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/26/%E7%A0%81%E8%B9%84%E6%9D%AF%E5%9B%BD%E8%B5%9B/" title="码蹄杯国赛"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A260.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="码蹄杯国赛"/></a><div class="content"><a class="title" href="/2025/08/26/%E7%A0%81%E8%B9%84%E6%9D%AF%E5%9B%BD%E8%B5%9B/" title="码蹄杯国赛">码蹄杯国赛</a><time datetime="2025-08-26T03:24:24.000Z" title="发表于 2025-08-26 11:24:24">2025-08-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/08/24/%E5%8F%A6%E4%B8%80%E5%88%99%E5%A5%87%E5%A6%99%E6%95%85%E4%BA%8B/" title="另一则奇妙故事"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A259.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="另一则奇妙故事"/></a><div class="content"><a class="title" href="/2025/08/24/%E5%8F%A6%E4%B8%80%E5%88%99%E5%A5%87%E5%A6%99%E6%95%85%E4%BA%8B/" title="另一则奇妙故事">另一则奇妙故事</a><time datetime="2025-08-24T14:26:30.000Z" title="发表于 2025-08-24 22:26:30">2025-08-24</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2025 By <a class="footer-bar-link" href="/" title="Destiny" target="_blank">Destiny</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">52</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">2</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" rel="external nofollow noreferrer" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener external nofollow noreferrer" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener external nofollow noreferrer" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><span> 分类</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/tags/"><span> 标签</span></a></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Python%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="font-size: 0.88rem;">Python与机器学习<sup>22</sup></a><a href="/tags/editing/" style="font-size: 0.88rem;">editing<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 0.88rem;">算法<sup>26</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.6.14",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 Destiny 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/fireworks.min.js"></script><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>