<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>Destiny's Blog | Destiny's Blog</title><meta name="author" content="Destiny"><meta name="copyright" content="Destiny"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="Destiny's Blog"><meta name="application-name" content="Destiny's Blog"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="Destiny's Blog"><meta property="og:url" content="https://agilawood4.github.io/2026/01/17/%E4%B8%8A%E6%9C%BA%E9%A2%98%E7%9B%AE/index.html"><meta property="og:site_name" content="Destiny's Blog"><meta property="og:description" content="llvm 文法规则 5.1 LLVM IR 文件的基本结构 一个 .ll 文件大概分三层：  模块级（Module）：全局变量、字符串常量、函数声明&amp;#x2F;定义 函数级（Function）：define ... &amp;#123; ... &amp;#125; 基本块级（BasicBlock）：label: 开头的一段"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://agilawood4.github.io/images/picture.jpg"><meta property="article:author" content="Destiny"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://agilawood4.github.io/images/picture.jpg"><meta name="description" content="llvm 文法规则 5.1 LLVM IR 文件的基本结构 一个 .ll 文件大概分三层：  模块级（Module）：全局变量、字符串常量、函数声明&amp;#x2F;定义 函数级（Function）：define ... &amp;#123; ... &amp;#125; 基本块级（BasicBlock）：label: 开头的一段"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://agilawood4.github.io/2026/01/17/%E4%B8%8A%E6%9C%BA%E9%A2%98%E7%9B%AE/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"/images/文章封面48.jpg"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: Destiny","link":"链接: ","source":"来源: Destiny's Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'Destiny's Blog',
  title: 'Destiny\'s Blog',
  postAI: '',
  pageFillDescription: 'llvm 文法规则, 5.1 LLVM IR 文件的基本结构, 5.2 指令系统, 5.2.1 Alloca（栈上分配局部变量）, 5.5.2 Load（从内存读）, 5.2.3 Store（写入内存）, 5.2.4 GEP（地址偏移计算）, 5.2.5 Phi（SSA 合流：来自不同前驱块取不同值）, 5.2.6 Zext / Trunc（整数位宽转换）, 5.2.7 Cmp（比较：icmp）, 5.2.8 Branch / Jump（控制流跳转）, 5.2.9 二元运算指令（Add/Sub/Mul/Div/Rem/And/Or/Xor/Shl/…）, 5.3 LLVM 控制流实现, 5.3.1 if (cond) A else B, 5.3.2 while (cond) { body }, 5.3.3 for (init cond step) { body }, llvm 实现思路, 6.1 变量符号介绍, 6.2 中间代码节点实现, 6.2.1 函数内建和预声明, 6.2.2 基本块, 6.2.3 指令插入, 6.2.4 函数定义, 6.2.5 语句块 / 作用域切换, 6.2.6 语句 Stmt 解析, 6.2.7 常变量解析, 6.2.8 初始化值 / 列表解析, 6.2.9 左值 LVal 的两种解析, 6.2.A 短路求值, 6.2.B 表达式链, 符号表 amp 语义分析扩展, 7.1 Stmt 分发, 7.2 Stmt 处理, 7.3 Exp 处理, 上机题目, 8.1 for + decl, 8.2 while + decl, 8.3 PowExp, 8.4 新增内建函数, 8.5 新建内建函数, 8.6 后缀++（困难）, 8.7 ShiftExp, 8.8 TernaryStmt, 8.9 repeat-cond, 8.A TernaryExp, 8.B switch-case, 8.C match-case, 8.D 后缀++, 8.E ForStmt → BType VarDef, 8.F (a+b)^b, 8.G if-elif-else, 优化简答, 9.1 CFG（控制流图）构建, 9.2 分支优化（Branch Simplify）, 9.3 基本块合并（Block Merge）, 9.3 函数内联（Inlining）, 常量函数编译期计算（Compile-time evaluation / ConstFold Call）, 9.4 循环优化（Loop Optimizations）, 9.5 Mem2Reg（内存提升到 SSA）, 9.6 死代码删除（DCE）, 9.7 公共子表达式消除（CSE）, 9.8 常量传播（Constant Propagation）, 9.9 常量合并（Constant Merge / Pooling）, 9.A 代数强度削弱（Strength Reduction）, 9.C 窥孔优化（Peephole）文法规则文件的基本结构一个文件大概分三层模块级全局变量字符串常量函数声明定义函数级基本块级开头的一段指令序列以终结指令结束典型骨架注释用分号中两个重要的文法规则每条有结果的指令都长得像一次定义多次使用每个基本块必须以终结指令结束或指令本质就是指令系统常见类型整数布尔浮点指针数组结构体函数类型几个直觉内存里存的是某个类型的对象指针类型就是指向那个对象的指针的结果是的结果是没有结果栈上分配局部变量格式含义在当前函数的栈帧上分配一块大小的内存返回一个指向这块内存的指针例子分配的是内存不是值要配合用在生成时为每个局部变量的的符号所绑定的即为这个局部变量在内存中的地址即只要我们能找到变量的即可得到其对应的地址从内存读格式含义从指向的内存里读一个出来例子的第一个类型必须和指针指向的类型匹配不能除非先或到合适类型写入内存格式含义把写到指向的内存里例子没有因为它没结果在实现时可以直接类型也必须匹配地址偏移计算指令是中最特殊的一条指令它只负责做地址偏移计算不会发生实际的内存读写操作相当于它会为指令提前计算好访存需要的地址后面的实际访存不由它负责基本格式数组例子如果那么解释第一个从指向数组的指针进入数组本体不偏移第二个选第个元素每个元素指针数组退化如果是更直观坑的第一个类型参数很关键它告诉如何按元素大小做步进数组指针的索引层数不同通常需要直接合流来自不同前驱块取不同值只会出现在基本块开头逻辑上用于把控制流合流点的变量合并格式直观含义如果当前基本块是从块跳来的那如果从块跳来的那依次类推例子合流的每个必须覆盖所有前驱值类型必须一致如果后期要做做活跃变量寄存器分配优化会引入边上的不是块内这里需要特殊处理不能简单套课上讲的和公式整数位宽转换零扩展小大高位补格式常见用途把条件变成参与算术截断大小砍高位格式这些是纯数值转换不是指针转换有符号扩展是如果考试提到可以仿照进行扩展比较格式常见等于不等有符号无符号例子结果类型永远是可以直接作为指令的条件控制流跳转里没有单独的指令名无条件跳转就是无条件条件是基本块终结指令写了就结束这个块了后面不能再跟普通指令条件必须是不是要用或比较转出来二元运算指令它们的文法基本一致格式常见算术除法取模有符号无符号位运算移位逻辑右移算术右移例子的默认不溢出检查有些可带可以先不管除法请注意否则跟语义可能不一致控制流实现的控制流是基本块跳转需要变量合流时后续如果里产生了一个值用于后面就在用合并模板经典三块循环体后续如果循环中更新变量并在下一轮用到形式通常要如果做了的优化你会发现循环变量的当前值在块用合并来自初值和迭代值本质就是把放到然后做的结构只是多了块或把放在尾部常见四块版本可能含带循环变量非常典型用做事实现思路变量符号介绍因为中间代码生成需要依赖符号表中维护的信息因此这里我们对符号表中维护的等类所拥有的字段再进行一个详细的介绍和说明只列出了和代码生成有关的字段基本符号类符号名与之绑定的函数符号描述类返回值基本类型经过得到和函数名形参类型列表形参名列表形参节点列表函数体节点函数体对应的作用域变量符号描述类变量基本类型经过得到和数组各个维度长度信息是否为数组是否为常量是否为静态变量变量符号变量符号描述如果本身是常量编译期求值用于局部常量初始化值求解如果是有初始化值的变量初始化值值列表用于局部数组初始化值求解函数符号函数符号描述直接返回返回值类型对于函数而言需要先根据查找强转为从中拿到函数签名结合可得到函数返回值类型在提前声明函数时使用得到参数类型或在解析的形参列表时使用得到参数名对于变量而言需要先根据查找强转为从中拿到变量描述器结合维度信息可以计算数组长度得到类型在解析变量定义时判断中间代码节点实现函数内建和预声明内建函数先建立函数名返回值类型是否为内建如果有参数则添加参数参数类型参数名最后添加到中建立映射所有函数的预声明扫描整个生成函数头加入遍历整个如果是内建函数则从中拿到加入中如果是用户函数则手动构建函数有关信息最后得到统一加入到中即用户手动声明函数的构建返回值函数体函数名返回值类型是否为内建函数如果有形参则通过进行建立这里数组映射为标量映射为这里需要注意返回结果是类型基本块基本块处理的三个步骤创建基本块把基本块挂到当前函数中切换指令插入点为当前基本块建立新块加入函数中切换指令插入点指令插入指令插入的统一套路为先一条对应的指令接着把该指令插入中如果指令需要临时寄存器保存结果则返回这条指令终结指令终结指令终结指令注意其中三条指令是结束指令对应的中不能再插入别的普通指令应当立即切块或结束函数定义在中找到函数对象获取对应的接着遍历根据函数名相同找到对应的设置当前函数并且创建设置当前块为函数入口块切换作用域到函数体的如果有参数则处理形参调用具体实现如下形参寄存器值地址值进地址符号绑定地址对于每个注意这是的值形参在函数体里当局部变量用绑定分配的栈地址作为这里需要注意如果是数组形参落栈后符号表里存的是指针变量的地址要当数组首地址用必须先成再解析函数体这里不再需要切换作用域因为在中已经把设置为当前基本块作用域恢复补充恢复外层作用域如果当前基本块不存在结束指令需要手动补一条语句语句块作用域切换除函数进入自己的是在函数定义解析本身完成的其余作用域的切换都通过实现如果需要进入新作用域遍历等恢复作用域语句解析处理根据来判断如果是类则进一步根据判断计算但丢弃返回值表达式语句常变量解析所有的声明都从函数中进行分发根据当前的进行判断若没有所处函数体则为全局变量常量若存在所处函数体则为局部变量常量全局常量声明处理套路获取全局常量名根据常量名获取符号计算名得到全局常量类型把符号描述器传入中即可数组其中来自数组各维度的乘积标量生成初始化常量调用全局初始化生成器数组初始化值标量初始化值空则给生成全局变量符号全局变量类型全局变量名常量标记初始化值列表模块登记把符号绑定到值全局变量声明处理套路获取全局变量名全局变量符号拿到对应的类型这几步和全局常量声明完全相同生成名静态变量提升成的全局变量全局变量计算初始化值调用全局初始化生成器即可生成全局变量符号类型名称常量标记初始化值列表如果是静态变量需要设置内部链接全局变量加入模块中同时绑定符号表局部常量声明获取名称符号变量类型这三部和全局符号完全相同为局部常量分配栈上地址局部常量符号绑定的为其在栈上的地址因此需要绑定的结果解析局部常量初始化值数组调用专门的解析函数标量直接用局部常量对应的内部的编译器常量初始化接着即可局部常量在里通常也就是一块栈内存初值局部变量声明获取名称符号变量类型这三部和全局符号完全相同根据变量描述器中标记如果是静态变量则调用当做全局变量解析如果是普通局部变量则生成对应的语句为其分配地址解析局部变量初始化值没有这部分就直接数组类型初始化值调用方法解析标量初始化值调用方法解析注意局部数组初始化和局部常量初始化共用同一套逻辑初始化值列表解析全局初始化值解析使用全局变量常量对应的中的初始化列表根据列表的长度判断返回数组初始化值或者返回标量初始化值局部数组初始化值解析先调用把可能存在的多维数组初始化列表压缩成线性对于其中的每一个写入阶段补阶段初始化列表长度数组长度剩下部分需要补充局部标量初始化值解析此时中仅有一个节点相当于是对的一个封装总结你可以把初始化值处理背成这句全局只用常量对象初始化靠局部标量局部数组补数组初始化写入永远是缺省初始化全局靠默认局部数组靠补循环语义保证全局必须是编译期整数局部可含表达式左值的两种解析对于左值的解析如果当做右值需要读值如果当做左值只需要计算地址现在给符号表中的所绑定的全是地址局部标量数组对应的结果是或形参给绑定的是对应的结果是全局变量全局常量静态局部变量本质上也是地址符号的引用对应的结果是或因此对于而言其取出的都是一个地址而不是对应的值这决定了在作为右值的时候必须作为左值的时候直接用它当地址即可右值先拿到对应的这里的是指针类型我们认为如果其指向的元素是数组类型即当做数组元素处理即这里我们需要特殊考虑一种情况即是而是也就是数组传参的时候传入的参数是对应的形参取出记为此时需要先一次取出对应的指针后续这个指针才能继续作为数组首地址使用对应也就是把加载出的过程右值为标量直接即可右值为数组元素先得到数组元素对应的地址再得到对应的元素值右值为数组名用于传参的时候只需要得到数组首元素的地址即可因为此时数组在参数中退化为指向数组首元素地址的指针规律标量数组名取首地址数组元素后左值左值在我们当前的文法中只有两类是合理的一类是标量的左值直接返回地址即可一类是数组元素的左值需要返回那个元素具体的地址注意这里数组名不作为左值因此不需要考虑右值中的情况获取元素对应地址的思路还是同上同时如果是也要先做一次拿到对应内层的指针才能继续作为数组首元素的地址使用标量左值直接返回这个即可数组元素左值需要根据这个此时是数组首元素地址结合偏移计算出当前元素真正的地址再返回的结果这里的是类型短路求值表达式这个表达式在左递归文法下会表示成转化为文法符号也就是其中左侧的表达式统一看成一个的整体最后和最右边的一个运算因此会先计算生成对应的判断结束时控制流处于位置接着计算的结果记为的结果开始时控制流处于块内生成对应的结束时控制流处于位置计算过程进入内层时的当前块内层结果计算过程这里不仅是内层也变成了外层左值已就绪的位置最终结果表达式链每一层表达式链都在套用这个模版如果是单个的直接递归下去即可这里体现出我们语法分析生成满足左节点递归调用本运算类型右节点为单一子节点类型的优势便于我们在中间代码生成时进行递归调用的解析否则分别计算和解析生成对应的二元运算指令返回结果符号表语义分析扩展如果不考虑新增错误类型大概率考试重点也不会放在错误处理上模拟考只有一个和错误有关的测试点对符号表的可能的修改只有三个地方分发如果新增指令是一条控制流语句流指令需要在中根据其或者新增一条指向它的解析方法的分支处理即对这条新增的语句流具体解析的实现语义分析的解析还是比较简单的只需要遍历当前的所有对每个判断类型调用对应的方法进行解析如果是有关的子节点则调用类中的运算解析方法进行解析即可大致流程形如需要注意的是在解析循环相关新增指令比如这种的时候解析之前需要新增循环栈解析完成需要退出循环栈即实现这里给一个具体的示例新增循环的解析逻辑不允许为空处理如果是新增一类运算类指令具体又可以分为在某一级现有运算指令上增加一个新的运算符比如在的乘除模的基础上增加上取整除新增一个运算类的指令级比如在和之间新增一级前者的处理很简单只需要找到原有的那一级表达式在运算符那里加一个分支即可后者则需要先修改表达式调用链接着新增对应的表达式处理方法这个的实现也比较套路大致就是先判断如果只有一个则直接递归向下一级解析否则则分别解析左运算数和右运算数如果二者都是常量则继续根据的类型进行常量折叠计算最后构造向上一级传播即可新增移位运算上机题目题目要求新增文法即允许在循环的位置写变量声明对于下面的文法在语义上等价为下面的实现重点是对作用域的要求实现方法我们考虑把变量声明提出来把变量声明和剩下的循环体作为两条分别维护具体来讲我们原本解析的是一个现在我们将其手动封装为下面的结构我们的语法分析阶段是支持这么创建节点的通过的节点创建够能我们很容易完成这样一层封装对应的代码如下需要注意的是我们不能直接调用原有的因为原本的变量声明文法末尾是包含一个分号的这里我们提出的不解析这个分号而是把分号留给循环去解析对应的处理方法是仿照方法再重写一个方法在原本的时候直接创建一个加入子节点列表即可我们发现做完语法分析后我们自动把新文法拆成了一条和一条一定没有的这两条文法现有编译器都是支持的因此我们不需要再进行后续修改题目要求新增文法即允许在循环的写变量声明对于下面的文法在语义上等价为下面的实现重点是对作用域的要求实现方法本例和上一例相比难度增加之处在于不能把新增文法拆成完全独立的两条和因为声明的变量还要作为循环的条件填入位置但是文法保证此时的位置填写的一定是一个变量标识符即在生成阶段该条件的真假可以通过对应的和比较得到所以我们只要支持解析循环时能拿到对应变量的即可因此我们考虑在调用解析得到节点以后把这个填入对应的位置在生成的时候只需要在进入即将解析条件的时候根据位置到底是还是新增文法填入的特判即可如果是后者只需要根据变量找到它在作用域中绑定的地址把对应的值出来即可补充说明在实现了和中支持变量声明以后我们发现年期末对于的处理也可以用相同的原理实现几乎就是对本例的这里不再赘述题目要求文法说明在和之间插入一级注意是右结合运算即的计算顺序应为中没有现成支持乘方的指令需要用现有指令组合完成乘方运算实现方法首先考虑肯定要修改表达式链在和之间加入其次考虑右结合的实现所谓左结合运算比如我们维护的节点结构应当是也就是先把左侧的中的所有算出来再和最后一个运算对应我们用循环来实现而对于右结合运算我们维护的节点结构应当是也就是先把右侧的中所有的算出来再和第一个运算对应我们用来实现右递归保证右结合由于是表达式的修改有可能触发语义分析阶段的常量折叠同时语义分析阶段的表达式链也要做相应修改这部分实现比较简单不要遗漏即可最后是生成阶段这部分是重点因为本身不含有乘方指令因此我们需要考虑在中生成一个类似于下面的循环用来完成的计算也就是说这里需要我们自己构建指令所谓构造指令就是不参考对应的语法树直接生成指令比如对于这么一条语句可能翻译成就需要有了上述自己生成的思想我们在方法中手动生成一个循环用来求解乘方运算也就不困难了可以参考我构造的代码可能指令实现细节不同但大致逻辑是相同的如果指数是常量直接展开成连乘如果指数是变量需要在中生成循环可以按循环的格式来生成创建基本块处理块生成比较指令处理块回到处理块后面新建内建函数时对应函数体的建立其实也需要我们自己生成感觉这部分还挺有可能考到的新增内建函数题目要求文法说明现在需要你在语言中支持内建函数函数的作用为返回的绝对值注意中没有现成的绝对值函数因此需要手动完成函数体的实现具体实现本例考察在中如何新建一个伪内建函数仿照即在生成之前就把对应的函数声明和函数体打印出来使得语义分析阶段可以把这些函数当成库函数全局函数调用首先是语义分析阶段在中新建对应的内建函数记录函数这里需要中支持参数构建方法剩下的修改都是在代码生成阶段完成首先是在注册内建函数方法中添加对应内建函数的注册表示不仅是函数声明还要生成函数体只有加入中的函数才会输出函数体接着在全局方法中加入一个分发方法用于每个函数体的实现最后我们考虑函数的实现逻辑其在语义上等价于一个分支语句控制流合并的实现因此我们可以通过构造基本块分支结合进行控制流合并完成函数体的实现具体代码如下也是仅供参考后面有关内建函数的实现也可以参考这个实现逻辑保存当前状态切换函数体建立基本块处理入口块处理的处理的处理结尾块恢复状态这里需要注意和解析基本块需要同理解析函数体需要同时解析完成后要做函数体恢复也就是代码中的状态保存和状态恢复新建内建函数题目要求文法说明现在需要你仿照上面的实现继续新增新的内建函数如下最大值函数最小值函数交换函数截断函数如果则返回如果则返回其余情况返回保证不会出现用户自定义函数和内建函数重名的情况具体实现仿照的实现思路即可后缀困难题目要求文法说明修改的文法要求支持后缀要求的操作数必须是在语义上的效果为返回的旧值同时把的结果写回中实现思路不同于前缀的实现前缀只相当于中新增一个单目运算符甚至不需要对控制流进行修改只需要最后下沉到生成时做的解析即可至于是否要生成一条指令修改原变量则需要根据文法要求具体实现后缀的实现需要对控制流进行修改首先是新增语法单元的处理在和之间添加了一级这里做语法分析的一个难点在于由于和都可能扩展到需要实现二者的判断逻辑这里我选择先解析的分支因为它是好判断的只要是读到就可以确定一定是剩下的情况中先无脑当做解析接着判断下一个是否为如果不是则说明就是反之则说明是此时可以从中通过取子节点的方式取找到这个节点这么做是巧妙的利用了中支持包含的特性因此如果是的情况我们一上来先解析也不会出错只是会解析出多嵌套一层通过取子节点取出即可函数调用有参数这里需要回溯有可能是中真正的其实这里在区分和时也可以使用回溯的思想即使用现有架构已经支持的和来实现我们可以考虑上来先无脑读取一个节点接着判断这个节点是否出错因为如果不是但走了分支会造成错位一定会返回同时判断解析完以后下一个字符是否为如果这两个条件有一个不满足就即弹栈并且恢复指针走去解析反之则说明确实是则保留已经解析好的接着去解析即可说明是接着是语义分析阶段这里限制不能作用于常量因此不需要考虑常量折叠如果遇到反而应该返回只需要修改对应的表达式链即可最后是生成阶段需要完成对语义的正确解析即先返回的旧值接着把最后把自增的结果写回对应的地址对应的解析过程如下修改后的文法新增文法实现题目要求文法说明在和之间新增支持逻辑左移和右移运算说明不需要考虑溢出位移运算是左结合默认右移运算按逻辑右移实现注意这里把表达式链的解析也做了修改提示中有对应的二元运算如下因此你可能需要新增两条指令同时添加生成中对这两条指令翻译的支持而当前中只支持是立即数的位移运算因此还需要新建指令类支持三操作数的位移运算具体实现到中间代码生成为止前面的扩展都只是在表达式链中新增一个普通的做结合运算级比较常规在生成中需要现在中新增两个二元运算类型在对应的解析函数中只需要调用生成对应的二元运算指令即可左移右移重点是阶段的生成首先生成新的指令类最后在解析的方法中新增两个分支分别解析左移和右移运算符即可被移位的值常量移位量用只看低位也能避免越界如果你支持就打开没有时先别走到这里变量移位量必须用注意的指令自动使用的低位不需要你手动如果你支持就打开没有时先别走到这里约定考试应该不会考到层面的修改不然需要添加的代码量未免有些太大了题目描述文法要求在语句流中增加三目运算符说明这是年的一道题目根据往届学长的描述貌似出题人没有考虑三目运算有返回值的情况如果当成语句流解析返回值应该是要被丢弃了实现思路本例的重点在于语法分析时如何在向下分发节点的时候识别当前语句是三目运算语句因为此时该文法的开头是很难确定它的到底是什么这里考虑用回溯的思想求解即上来先无脑解析一个如果解析不出错且解析完的下一个符号确实为就走三目运算流如果出错则进行回溯正常解析已有文法这里之所以把退掉是因为还会把解析一遍因此这里需要回退剩下一个可能存在的难点在于生成的时候如果不考虑返回值则三目运算符完全可以当成分支来实现而如果考虑返回值则需要在中插入一条指令用于合并两个的结果并最后把作为最后的返回值返回题目要求新增控制流文法如下这类控制流属于比较好加的指令和我们已经实现的循环相比只需要把放在后面实现即可以第一条指令为例其中在期中模拟的时候前面也加过了这里展示中间代码生成时的参考如下建立基本块先进入后进入进入题目要求文法说明新增三目运算符但扩展文法要求如下题目要求文法说明新增语句题目要求文法说明新增语句后缀题目要求文法说明新增后缀语句题目要求文法说明对进行扩展前面提到的抽取出可以看成是一个方法还有一个比较常规的方法就是给语句也嵌套一层作用域就按照新增文法做常规解析需要在符号表解析的时候进行和如果是新增文法则需要为当前的变量声明新建作用域新增关联节点到作用域用完作用域记得弹出其实这里我们创建的作用域也仅包含当前的整个循环不会再包含其他多余的语句所以写的简单一点的话我们可以不做是否有的判断只要看到我们就为其新建一个作用域这样也是可以的对应在生成时每次进入循环解析时也需要根据去做作用域匹配判断是否要切换作用域题目要求文法说明对进行扩展其中的语义为保证是无符号整数本例和乘方运算差不多需要在中手动生成一个循环计算乘方计算的结果创建基本块加入基本块列表在栈上分配和的空间生成指针初始化时继续迭乘反之退出取出旧值和相乘结果存回的地址取出旧值执行结果存回的地址取出最后的值作为计算结果返回题目要求文法说明在中添加本例前面词法和语法期中考过重点是对的修改需要用数组存和链维护前后跳转关系优化简答控制流图构建原理把程序的基本块当节点跳转当边作用本身不直接省指令但所有控制流数据流优化都依赖它比如循环优化支配树活跃分析的可达性判断能发现什么哪些块不可达哪些边是回边循环一个块的前驱后继是谁简答里写法构建后才能做不可达删除分支化简循环识别等分支优化原理把条件恒真恒假的分支改成直接跳转把的空分支删掉把的目标修剪优化对象条件来自常量传播比较恒定的代码例子优化前形态优化后效果少一个分支少两个块基本块合并原理如果块无条件跳到且只有一个前驱那么和可以合并优化对象优化后产生的空跳转块中转块例子优化前优化后效果减少一次跳转减少块数提高后端局部优化机会函数内联原理把小函数的函数体复制到调用点替代优化对象短小频繁调用参数常量可触发后续常量传播的函数例子优化前有保存现场传参返回值开销优化后收益少让后续常量传播更强尤其参数是常量风险点简答可提一句内联会增大代码体积通常对小函数热路径做常量函数编译期计算原理如果函数是纯函数可推断无副作用且实参都是常量就在编译期直接算出返回值替换调用优化对象数学函数小工具函数递归若你做了等例子优化后效果调用消失后面还能继续传播常量循环优化你说循环优化通常包含循环不变式外提循环简化强度削弱归纳变量优化消除多余判断等循环不变式外提原理循环里不随迭代变化的表达式移到循环外算一次例子不变优化后效果少次乘法循环归纳变量简化原理把每轮重复计算的变成累加指针例子优化后低层形态用指针每轮减少乘法地址计算内存提升到原理把局部变量栈槽的转成值优化对象局部标量变量地址不逃逸只被访问例子优化前内存化优化后效果大量消失后端性能暴增也为常量传播铺路死代码删除原理删掉结果永远不会被用到的指令前提是它没有副作用优化对象临时变量冗余计算不可达块无用部分情况下例子都无用优化后注意简答里常考有副作用的不能删可能写全局的公共子表达式消除局部原理在一个基本块内相同表达式且操作数相同第二次直接复用第一次结果例子重复优化后全局原理跨基本块复用需要支配关系保证第一次计算一定发生且中间不被改例子若所在块支配这里且未被改优化后常量传播原理把已知常量替换到使用点进一步触发分支化简强度削弱例子传播后分支删除常量合并原理相同常量尤其字符串全局常量数组只保留一份多个引用共享例子数据段只保留一个两处都指向同一地址效果减小减小代码生成时重复加载地址的机会代数强度削弱原理用更便宜的指令替代昂贵运算经典例子算术右移注意负数语义里要谨慎仅对非负或按补码语义需谨慎例子优化后再比如你常见的优化后你之前也提过后端启发式图着色寄存器分配原理把值临时看作图的节点若两个值在某点同时活跃就连边冲突图着色把节点映射到有限寄存器优化对象减少栈上的减少例子非常直观优化前全落栈优化后寄存器承载都在寄存器里简答写法寄存器分配把热点变量放在减少指令提升性能也可以提一句是函数用到就要保存恢复是跨需要保存活跃值窥孔优化原理在很短的指令窗口里做局部等价替换删除冗余优化对象后端生成的机械重复模式常见例子删除删紧邻的抵消删后一句若中间无改写无别名冗余加载消除中间无到第二个删跳到下一块的删除块顺序相邻',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2026-01-17 15:28:15',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"><link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.4/img/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">Destiny's Blog</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)" rel="external nofollow noreferrer">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><span> 分类</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/tags/"><span> 标签</span></a></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/LLM%E4%B8%8E%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/" style="font-size: 1.05rem;">LLM与强化学习<sup>4</sup></a><a href="/tags/Python%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="font-size: 1.05rem;">Python与机器学习<sup>35</sup></a><a href="/tags/editing/" style="font-size: 1.05rem;">editing<sup>1</sup></a><a href="/tags/%E4%B8%93%E4%B8%9A%E8%AF%BE/" style="font-size: 1.05rem;">专业课<sup>33</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 1.05rem;">算法<sup>29</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2026/01/"><span class="card-archive-list-date">一月 2026</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">13</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/12/"><span class="card-archive-list-date">十二月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">6</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/11/"><span class="card-archive-list-date">十一月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">10</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/10/"><span class="card-archive-list-date">十月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">12</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/09/"><span class="card-archive-list-date">九月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">21</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/08/"><span class="card-archive-list-date">八月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">28</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/07/"><span class="card-archive-list-date">七月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">23</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);" rel="external nofollow noreferrer"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="article-meta tags"></span></div></div><h1 class="post-title" itemprop="name headline">无题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2026-01-17T07:28:15.121Z" title="发表于 2026-01-17 15:28:15">2026-01-17</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2026-01-17T07:28:15.122Z" title="更新于 2026-01-17 15:28:15">2026-01-17</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为香波地群岛"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>香波地群岛</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src=""></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://agilawood4.github.io/2026/01/17/%E4%B8%8A%E6%9C%BA%E9%A2%98%E7%9B%AE/"><header><h1 id="CrawlerTitle" itemprop="name headline">无题</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">Destiny</span><time itemprop="dateCreated datePublished" datetime="2026-01-17T07:28:15.121Z" title="发表于 2026-01-17 15:28:15">2026-01-17</time><time itemprop="dateCreated datePublished" datetime="2026-01-17T07:28:15.122Z" title="更新于 2026-01-17 15:28:15">2026-01-17</time></header><h2 id="llvm-文法规则"><strong>llvm 文法规则</strong></h2>
<h3 id="5-1-llvm-ir-文件的基本结构"><strong>5.1 LLVM IR 文件的基本结构</strong></h3>
<p>一个 <code>.ll</code> 文件大概分三层：</p>
<ol>
<li>模块级（Module）：全局变量、字符串常量、函数声明/定义</li>
<li>函数级（Function）：<code>define ... &#123; ... &#125;</code></li>
<li>基本块级（BasicBlock）：<code>label:</code> 开头的一段指令序列，以<strong>终结指令</strong>结束（<code>br</code>/<code>ret</code>/<code>switch</code>/<code>unreachable</code>）</li>
</ol>
<p>典型骨架：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">; 注释用分号</span><br><span class="line">@g = global i32 <span class="number">0</span></span><br><span class="line">@msg = <span class="keyword">private</span> unnamed_addr constant [<span class="number">6</span> x i8] c<span class="string">&quot;hello\00&quot;</span></span><br><span class="line"></span><br><span class="line">declare i32 @<span class="built_in">printf</span>(i8*, ...)</span><br><span class="line"></span><br><span class="line">define i32 @<span class="built_in">main</span>() &#123;</span><br><span class="line">entry:</span><br><span class="line">  ; ... instructions ...</span><br><span class="line">  ret i32 <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>llvm</code>中两个重要的文法规则：</p>
<ul>
<li>每条有结果的指令都长得像 SSA：<code>%x = ...</code>（一次定义，多次使用）</li>
<li>每个基本块必须以<strong>终结指令</strong>结束：<code>ret</code> 或 <code>br</code>（指令 jump 本质就是 <code>br label %dest</code>）</li>
</ul>
<h3 id="5-2-指令系统"><strong>5.2 指令系统</strong></h3>
<p>常见类型：</p>
<ul>
<li>整数：<code>i1</code>（布尔）、<code>i8</code>、<code>i32</code>、<code>i64</code></li>
<li>浮点：<code>float</code>、<code>double</code></li>
<li>指针：<code>i32*</code>、<code>i8*</code>、<code>%T*</code></li>
<li>数组：<code>[10 x i32]</code></li>
<li>结构体：<code>%S = type &#123; i32, i8 &#125;</code></li>
<li>函数类型：<code>i32 (i32, i32)*</code></li>
</ul>
<p>几个直觉：</p>
<ul>
<li>内存里存的是某个类型的对象，指针类型就是“指向那个对象”的指针：<code>T*</code></li>
<li><code>alloca T</code> 的结果是 <code>T*</code></li>
<li><code>load T, T* p</code> 的结果是 <code>T</code></li>
<li><code>store T v, T* p</code> 没有结果（void）</li>
</ul>
<h4 id="5-2-1-alloca-栈上分配局部变量"><strong>5.2.1 Alloca（栈上分配局部变量）</strong></h4>
<p><strong>格式</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%p = alloca &lt;type&gt; [, align N]</span><br></pre></td></tr></table></figure>
<p><strong>含义</strong></p>
<ul>
<li>在当前函数的栈帧上分配一块 <code>&lt;type&gt;</code> 大小的内存</li>
<li>返回一个指向这块内存的指针：<code>&lt;type&gt;*</code></li>
</ul>
<p><strong>例子</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%a = alloca i32</span><br><span class="line">store i32 <span class="number">5</span>, i32* %a</span><br><span class="line">%v = load i32, i32* %a</span><br></pre></td></tr></table></figure>
<ul>
<li><code>alloca</code> 分配的是<strong>内存</strong>，不是 SSA 值；要配合 <code>load/store</code> 用</li>
<li>在生成<code>llvm</code>时为每个局部变量的<code>curScope.getSymbol(name)</code>的符号所绑定的<code>IrValue</code>即为这个局部变量在内存中的地址，即只要我们能找到变量的<code>Ident</code>，即可得到其对应的地址<code>varPtr</code></li>
</ul>
<h4 id="5-5-2-load-从内存读"><strong>5.5.2 Load（从内存读）</strong></h4>
<p><strong>格式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%val = load &lt;type&gt;, &lt;type&gt;* &lt;ptr&gt; [, align N]</span><br></pre></td></tr></table></figure>
<p><strong>含义</strong></p>
<ul>
<li>从 <code>&lt;ptr&gt;</code> 指向的内存里读一个 <code>&lt;type&gt;</code> 出来</li>
</ul>
<p><strong>例子</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%v = load i32, i32* %a</span><br></pre></td></tr></table></figure>
<ul>
<li><code>load</code> 的第一个类型必须和指针指向的类型匹配：<code>load i32, i32*</code></li>
<li>不能 <code>load i32, i8*</code>（除非先 bitcast 或 gep 到合适类型）</li>
</ul>
<h4 id="5-2-3-store-写入内存"><strong>5.2.3 Store（写入内存）</strong></h4>
<p><strong>格式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store &lt;type&gt; &lt;value&gt;, &lt;type&gt;* &lt;ptr&gt; [, align N]</span><br></pre></td></tr></table></figure>
<p><strong>含义</strong></p>
<ul>
<li>把 <code>&lt;value&gt;</code> 写到 <code>&lt;ptr&gt;</code> 指向的内存里</li>
</ul>
<p><strong>例子</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store i32 <span class="number">123</span>, i32* %a</span><br></pre></td></tr></table></figure>
<ul>
<li><code>store</code> 没有 <code>%res =</code>，因为它没结果，在实现时可以直接<code>irBuilder.addInstruction(new IrStore(...))</code></li>
<li>类型也必须匹配：<code>store i32, i32*</code></li>
</ul>
<h4 id="5-2-4-gep-地址偏移计算"><strong>5.2.4 GEP（地址偏移计算）</strong></h4>
<p><code>GEP</code>指令是<code>llvm</code>中最特殊的一条指令，它只负责做地址偏移计算，不会发生实际的内存读写操作，相当于它会为<code>lw, sw</code>指令提前计算好访存需要的地址，后面的实际访存不由它负责</p>
<p><strong>基本格式</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%p2 = getelementptr &lt;pointeeType&gt;, &lt;pointeeType&gt;* &lt;base&gt;, i32 &lt;idx0&gt;, i32 &lt;idx1&gt;, ...</span><br></pre></td></tr></table></figure>
<p>数组例子：<code>int a[10]; a[i]</code></p>
<p>如果 <code>%arr = alloca [10 x i32]</code>，那么：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%elemPtr = getelementptr [<span class="number">10</span> x i32], [<span class="number">10</span> x i32]* %arr, i32 <span class="number">0</span>, i32 %i</span><br><span class="line">%val = load i32, i32* %elemPtr</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<ul>
<li>第一个 <code>i32 0</code>：从“指向数组的指针”进入数组本体（不偏移）</li>
<li>第二个 <code>i32 %i</code>：选第 <code>i</code> 个元素（每个元素 i32）</li>
</ul>
<p>指针数组退化：<code>int *p; p[i]</code></p>
<p>如果 <code>%p</code> 是 <code>i32*</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%elemPtr = getelementptr i32, i32* %p, i32 %i</span><br><span class="line">%val = load i32, i32* %elemPtr</span><br></pre></td></tr></table></figure>
<p>更直观：<code>%elemPtr = %p + i * sizeof(i32)</code></p>
<p><strong>坑</strong></p>
<ul>
<li>GEP 的“第一个类型参数”很关键：它告诉 LLVM 如何按元素大小做步进</li>
<li><strong>数组 vs 指针</strong> 的 GEP 索引层数不同：
<ul>
<li><code>[N x T]*</code> 通常需要 <code>0, i</code></li>
<li><code>T*</code> 直接 <code>i</code></li>
</ul>
</li>
</ul>
<h4 id="5-2-5-phi-ssa-合流：来自不同前驱块取不同值"><strong>5.2.5 Phi（SSA 合流：来自不同前驱块取不同值）</strong></h4>
<p>Phi 只会出现在 <strong>基本块开头（逻辑上）</strong>，用于把控制流合流点的变量合并</p>
<p><strong>格式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%x = phi &lt;type&gt; [ &lt;v1&gt;, %pred1 ], [ &lt;v2&gt;, %pred2 ], ...</span><br></pre></td></tr></table></figure>
<p><strong>直观含义</strong></p>
<ul>
<li>如果当前基本块是从块 <code>%pred1</code> 跳来的，那 <code>%x = v1</code>；如果从块 <code>%pred2</code> 跳来的，那 <code>%x = v2</code>，依次类推</li>
</ul>
<p><strong>例子：if-else 合流</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">br i1 %cond, label %then, label %else</span><br><span class="line"></span><br><span class="line">then:</span><br><span class="line">  %a1 = add i32 %a0, 1</span><br><span class="line">  br label %merge</span><br><span class="line"></span><br><span class="line">else:</span><br><span class="line">  %a2 = sub i32 %a0, 1</span><br><span class="line">  br label %merge</span><br><span class="line"></span><br><span class="line">merge:</span><br><span class="line">  %a = phi i32 [ %a1, %then ], [ %a2, %else ]</span><br></pre></td></tr></table></figure>
<ul>
<li>phi 的每个 incoming 必须覆盖<strong>所有</strong>前驱</li>
<li>incoming 值类型必须一致</li>
<li>如果后期要做做活跃变量/寄存器分配优化，phi 会引入边上的 use（不是块内 use），这里需要特殊处理，不能简单套课上讲的<code>in</code>和<code>out</code>公式</li>
</ul>
<h4 id="5-2-6-zext-trunc-整数位宽转换"><strong>5.2.6 Zext / Trunc（整数位宽转换）</strong></h4>
<p>Zext：零扩展（小 -&gt; 大，高位补 0）</p>
<p><strong>格式</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%y = zext i1 %x to i32</span><br><span class="line">%y = zext i8 %x to i32</span><br></pre></td></tr></table></figure>
<p>常见用途：把 <code>i1</code> 条件变成 <code>i32</code> 参与算术</p>
<p>Trunc：截断（大 -&gt; 小，砍高位）</p>
<p><strong>格式</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%y = trunc i32 %x to i8</span><br></pre></td></tr></table></figure>
<ul>
<li>这些是<strong>纯数值</strong>转换，不是指针转换</li>
<li>有符号扩展是 <code>sext</code>，如果考试提到，可以仿照<code>zext</code>进行扩展</li>
</ul>
<h4 id="5-2-7-cmp-比较：icmp"><strong>5.2.7 Cmp（比较：icmp）</strong></h4>
<p><strong>格式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%cond = icmp &lt;pred&gt; &lt;type&gt; &lt;a&gt;, &lt;b&gt;</span><br></pre></td></tr></table></figure>
<p><code>&lt;pred&gt;</code> 常见：</p>
<ul>
<li><code>eq</code> 等于</li>
<li><code>ne</code> 不等</li>
<li><code>slt</code> / <code>sle</code> / <code>sgt</code> / <code>sge</code>（<strong>有符号</strong>）</li>
<li><code>ult</code> / <code>ule</code> / <code>ugt</code> / <code>uge</code>（<strong>无符号</strong>）</li>
</ul>
<p><strong>例子</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%cond = icmp slt i32 %i, %n   ; i &lt; n</span><br></pre></td></tr></table></figure>
<p>结果类型永远是 <code>i1</code>，可以直接作为<code>Branch</code>指令的<code>cond</code>条件</p>
<h4 id="5-2-8-branch-jump-控制流跳转"><strong>5.2.8 Branch / Jump（控制流跳转）</strong></h4>
<p>LLVM 里没有单独的 <code>jump</code> 指令名，<strong>无条件跳转</strong>就是：</p>
<p>无条件 br（= jump）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">br label %dest</span><br></pre></td></tr></table></figure>
<p>条件 br</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">br i1 %cond, label %then, label %<span class="keyword">else</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>br</code> 是基本块终结指令：写了 br 就结束这个块了，后面不能再跟普通指令</li>
<li>条件必须是 <code>i1</code>，不是 <code>i32</code>（要用 <code>icmp</code> 或 <code>trunc</code>/<code>zext</code>/比较转出来）</li>
</ul>
<h4 id="5-2-9-二元运算指令-add-sub-mul-div-rem-and-or-xor-shl"><strong>5.2.9 二元运算指令（Add/Sub/Mul/Div/Rem/And/Or/Xor/Shl/…）</strong></h4>
<p>它们的“文法”基本一致：</p>
<p><strong>格式</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%r = &lt;op&gt; &lt;type&gt; &lt;lhs&gt;, &lt;rhs&gt;</span><br></pre></td></tr></table></figure>
<p>常见：</p>
<ul>
<li>算术：<code>add</code>, <code>sub</code>, <code>mul</code></li>
<li>除法/取模：
<ul>
<li><code>sdiv</code>/<code>srem</code>（有符号）</li>
<li><code>udiv</code>/<code>urem</code>（无符号）</li>
</ul>
</li>
<li>位运算：<code>and</code>, <code>or</code>, <code>xor</code></li>
<li>移位：<code>shl</code>, <code>lshr</code>（逻辑右移）, <code>ashr</code>（算术右移）</li>
</ul>
<p><strong>例子</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%a = add i32 %x, %y</span><br><span class="line">%q = sdiv i32 %x, %y</span><br><span class="line">%r = srem i32 %x, %y</span><br><span class="line">%z = <span class="keyword">and</span> i32 %x, <span class="number">255</span></span><br></pre></td></tr></table></figure>
<ul>
<li>LLVM 的 <code>add</code> 默认不溢出检查；有些可带 flags（<code>nsw</code>/<code>nuw</code>）可以先不管</li>
<li>除法请注意 signed/unsigned，否则跟 C 语义可能不一致</li>
</ul>
<h3 id="5-3-llvm-控制流实现"><strong>5.3 LLVM 控制流实现</strong></h3>
<p>LLVM 的控制流是：<strong>基本块 + br 跳转 +（需要变量合流时）phi</strong></p>
<h4 id="5-3-1-if-cond-a-else-b"><strong>5.3.1 if (cond) A else B</strong></h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">entry:</span><br><span class="line">  %cond = ...</span><br><span class="line">  br i1 %cond, label %then, label %<span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">then:</span><br><span class="line">  ; A</span><br><span class="line">  br label %merge</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  ; B</span><br><span class="line">  br label %merge</span><br><span class="line"></span><br><span class="line">merge:</span><br><span class="line">  ; 后续</span><br></pre></td></tr></table></figure>
<p>如果 if-else 里产生了一个值用于后面，就在 <code>merge</code> 用 <code>phi</code> 合并</p>
<h4 id="5-3-2-while-cond-body"><strong>5.3.2 while (cond) { body }</strong></h4>
<p>模板（经典三块）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">entry:</span><br><span class="line">  br label %cond</span><br><span class="line"></span><br><span class="line">cond:</span><br><span class="line">  %c = ...</span><br><span class="line">  br i1 %c, label %body, label %end</span><br><span class="line"></span><br><span class="line">body:</span><br><span class="line">  ; 循环体</span><br><span class="line">  br label %cond</span><br><span class="line"></span><br><span class="line">end:</span><br><span class="line">  ; 后续</span><br></pre></td></tr></table></figure>
<p>如果循环中更新变量、并在下一轮用到，SSA 形式通常要 <code>phi</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cond:</span><br><span class="line">  %i = phi i32 [ <span class="number">0</span>, %entry ], [ %i_next, %body ]</span><br><span class="line">  %c = icmp slt i32 %i, %n</span><br><span class="line">  br i1 %c, label %body, label %end</span><br><span class="line"></span><br><span class="line">body:</span><br><span class="line">  %i_next = add i32 %i, <span class="number">1</span></span><br><span class="line">  br label %cond</span><br></pre></td></tr></table></figure>
<p>如果做了<code>phi</code>的优化，你会发现：循环变量的“当前值”在 cond 块用 phi 合并来自 entry（初值）和 body（迭代值）</p>
<h4 id="5-3-3-for-init-cond-step-body"><strong>5.3.3 for (init; cond; step) { body }</strong></h4>
<p>for 本质就是把 init 放到 entry，然后做 while 的结构，只是多了 step 块（或把 step 放在 body 尾部）。</p>
<p>常见四块版本：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">entry:</span><br><span class="line">  ; init</span><br><span class="line">  br label %cond</span><br><span class="line"></span><br><span class="line">cond:</span><br><span class="line">  ; <span class="built_in">cond</span> (可能含 phi)</span><br><span class="line">  br i1 %c, label %body, label %end</span><br><span class="line"></span><br><span class="line">body:</span><br><span class="line">  ; body</span><br><span class="line">  br label %step</span><br><span class="line"></span><br><span class="line">step:</span><br><span class="line">  ; step</span><br><span class="line">  br label %cond</span><br><span class="line"></span><br><span class="line">end:</span><br></pre></td></tr></table></figure>
<p>带循环变量 SSA（非常典型）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">entry:</span><br><span class="line">  br label %cond</span><br><span class="line"></span><br><span class="line">cond:</span><br><span class="line">  %i = phi i32 [ <span class="number">0</span>, %entry ], [ %i2, %step ]</span><br><span class="line">  %c = icmp slt i32 %i, %n</span><br><span class="line">  br i1 %c, label %body, label %end</span><br><span class="line"></span><br><span class="line">body:</span><br><span class="line">  ; 用 %i 做事</span><br><span class="line">  br label %step</span><br><span class="line"></span><br><span class="line">step:</span><br><span class="line">  %i2 = add i32 %i, <span class="number">1</span></span><br><span class="line">  br label %cond</span><br><span class="line"></span><br><span class="line">end:</span><br></pre></td></tr></table></figure>
<h2 id="llvm-实现思路"><strong>llvm 实现思路</strong></h2>
<h3 id="6-1-变量符号介绍"><strong>6.1 变量符号介绍</strong></h3>
<p>因为中间代码生成需要依赖符号表中维护的信息，因此这里我们对符号表中维护的<code>symbol</code>等类所拥有的字段再进行一个详细的介绍和说明（只列出了和代码生成有关的字段）：</p>
<p><strong>Symbol - 基本符号类</strong></p>
<ol>
<li>符号名 String name</li>
<li>与之绑定的 IrValue IrValue</li>
</ol>
<p><strong>FuncSymbolInfo - 函数符号描述类</strong></p>
<ol>
<li>返回值基本类型 BasicType returnType(CHAR/INT/VOID) -&gt; 经过 getType() 得到 IrBaseType.I32 和 IrBaseType.VOID</li>
<li>函数名 String name</li>
<li>形参类型列表 List<ValueSymbolDescriptor> paramTypes</ValueSymbolDescriptor></li>
<li>形参名列表 List<String> paramNames</String></li>
<li>形参节点列表 List<AstNode> paramNodes</AstNode></li>
<li>函数体节点 AstNode blockNode</li>
<li>函数体对应的作用域 Scope bodyScope</li>
</ol>
<p><strong>ValueSymbolInfo - 变量符号描述类</strong></p>
<ol>
<li>变量基本类型 BasicType basicType(CHAR/INT/VOID) -&gt; 经过 getType() 得到 IrArrayType 和 IrBaseType.I32</li>
<li>数组各个维度长度信息 List<Integer> dimensions</Integer></li>
<li>是否为数组 isArray</li>
<li>是否为常量 isConst</li>
<li>是否为静态变量 isStatic</li>
</ol>
<p><strong>ValueSymbol(Symbol) - 变量符号</strong></p>
<ol>
<li>变量符号描述 ValueSymbolDescriptor ValueSymbolDescriptor</li>
<li>如果本身是常量，编译期求值 Integer constScalarValue（用于局部常量初始化值求解）</li>
<li>如果是有初始化值的变量，初始化值/值列表 List<Integer> initializerValues（用于局部数组初始化值求解）</Integer></li>
</ol>
<p><strong>FuncSymbol(Symbol) - 函数符号</strong></p>
<ol>
<li>函数符号描述 FunctionSignature functionSignature</li>
<li>直接返回 IrType 返回值类型 getIrType()</li>
</ol>
<p>对于函数而言，需要先根据 name 查找 symbol，强转为 funcSymbol，从中拿到函数签名 signature</p>
<ul>
<li>结合 getType() 可得到函数返回值类型</li>
<li>在提前声明函数时，使用 getParamTypes() 得到参数类型 i32 或 i32*</li>
<li>在解析 funcDef 的形参列表时，使用 getParamNames() 得到参数名</li>
</ul>
<p>对于变量而言，需要先根据 name 查找 symbol，强转为 valueSymbol，从中拿到变量描述器 valueSymbolDescriptor</p>
<ul>
<li>结合维度信息 getDimensions() 可以计算数组长度，得到 IrArrayType(N,I32) 类型</li>
<li>在解析变量定义 varDef 时判断 isArray，isConst，isStatic</li>
</ul>
<h3 id="6-2-中间代码节点实现"><strong>6.2 中间代码节点实现</strong></h3>
<h4 id="6-2-1-函数内建和预声明"><strong>6.2.1 函数内建和预声明</strong></h4>
<p>（1）内建函数（<code>builtin</code>）</p>
<p>先建立 <code>IrFunc</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 函数名 + 返回值类型 + 是否为内建 */</span></span><br><span class="line"><span class="type">IrFunc</span> <span class="variable">getint</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IrFunc</span>(<span class="string">&quot;@getint&quot;</span>, IrBaseType.I32, <span class="literal">true</span>);</span><br><span class="line"><span class="type">IrFunc</span> <span class="variable">putstr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IrFunc</span>(<span class="string">&quot;@putstr&quot;</span>, IrBaseType.VOID, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>如果有参数，则 <code>addParam</code> 添加参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 参数类型 + 参数名 */</span></span><br><span class="line">getint.addParam(<span class="keyword">new</span> <span class="title class_">IrValue</span>(IrBaseType.I32, <span class="string">&quot;%a&quot;</span>));</span><br><span class="line">putstr.addParam(<span class="keyword">new</span> <span class="title class_">IrValue</span>(<span class="keyword">new</span> <span class="title class_">IrPointerType</span>(IrBaseType.I32), <span class="string">&quot;%a&quot;</span>))</span><br></pre></td></tr></table></figure>
<p>最后添加到 <code>builtinFunc</code> 中建立映射</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">builtinFunc.put(<span class="string">&quot;getint&quot;</span>, getint);</span><br></pre></td></tr></table></figure>
<p>（2）所有函数的预声明</p>
<p>扫描整个 <code>funcMap</code>，生成函数头加入 <code>Module</code></p>
<ol>
<li>遍历整个 <code>funcMap(name -&gt; signature)</code></li>
<li>如果是内建函数，则从 <code>builtinFunc</code> 中拿到 <code>IrFunc</code>，加入 <code>Module</code> 中</li>
<li>如果是用户函数，则手动构建函数有关信息</li>
<li>最后得到 <code>IrFunc</code> 统一加入到 <code>Module</code> 中，即 <code>irBuilder.getModule().addFunction(function)</code></li>
</ol>
<p>用户手动声明函数的构建：</p>
<ul>
<li>返回值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">IrType</span> <span class="variable">retType</span> <span class="operator">=</span> getType(signature.getReturnType());</span><br></pre></td></tr></table></figure>
<ul>
<li>函数体 <code>IrFunc</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 函数名 + 返回值类型 + 是否为内建函数 */</span></span><br><span class="line"><span class="type">IrFunc</span> <span class="variable">function</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IrFunc</span>(<span class="string">&quot;@&quot;</span> + name, retType, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>如果有形参，则通过 <code>signature.getParamTypes()</code> 进行建立，这里数组映射为 <code>i32*</code>，标量映射为 <code>i32</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ValueSymbolDescriptor</span> <span class="variable">descriptor</span> <span class="operator">=</span> signature.getParamTypes().get(i);</span><br><span class="line">paramType = descriptor.isArray() ? <span class="keyword">new</span> <span class="title class_">IrPointerType</span>(IrBaseType.I32) : IrBaseType.I32;</span><br><span class="line">function.addParam(<span class="keyword">new</span> <span class="title class_">IrValue</span>(paraType, <span class="string">&quot;%&quot;</span> + i));</span><br></pre></td></tr></table></figure>
<p>这里需要注意 <code>getParamTypes()</code> 返回结果是 <code>ValueSymbolDescriptor</code> 类型</p>
<h4 id="6-2-2-基本块"><strong>6.2.2 基本块</strong></h4>
<p>基本块处理的三个步骤：</p>
<ul>
<li>创建基本块</li>
<li>把基本块挂到当前函数中</li>
<li>切换指令插入点为当前基本块</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 建立新块 */</span></span><br><span class="line"><span class="type">IrBasicBlock</span> <span class="variable">bb</span> <span class="operator">=</span> irBuilder.createBasicBlock(name);</span><br><span class="line"><span class="comment">/* 加入函数中 */</span></span><br><span class="line">irBuilder.getFunction().addBasicBlock(bb);</span><br><span class="line"><span class="comment">/* 切换指令插入点 */</span></span><br><span class="line">irBuilder.setCurBasicBlock();</span><br></pre></td></tr></table></figure>
<h4 id="6-2-3-指令插入"><strong>6.2.3 指令插入</strong></h4>
<p>指令插入的统一套路为先 <code>new</code> 一条对应的指令，接着把该指令插入 <code>irBuilder</code> 中，如果指令需要临时寄存器保存结果，则返回这条指令</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Alloca</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Alloca</span>(type); add(a);</span><br><span class="line"><span class="type">Store</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Store</span>(val, ptr); add(s);</span><br><span class="line"><span class="type">Load</span> <span class="variable">l</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Load</span>(ptr); add(l); <span class="keyword">return</span> l;</span><br><span class="line"><span class="type">BinaryOp</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BinaryOp</span>(op, x, y); add(b); <span class="keyword">return</span> b;</span><br><span class="line"><span class="type">Branch</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Branch</span>(cond, T, F); add(br);（终结指令）</span><br><span class="line"><span class="type">Jump</span> <span class="variable">j</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jump</span>(target); add(j);（终结指令）</span><br><span class="line"><span class="type">Return</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Return</span>(valOrNull); add(r);（终结指令）</span><br></pre></td></tr></table></figure>
<p>注意：其中 <code>Branch, Jump, Return</code> 三条指令是结束指令，对应的 <code>Block</code> 中不能再插入别的普通指令，应当立即切块或结束</p>
<h4 id="6-2-4-函数定义"><strong>6.2.4 函数定义</strong></h4>
<p>（1）在 <code>Module</code> 中找到函数对象，获取对应的 <code>IrFunc</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> funcDef.getIndexChild(<span class="number">0</span>).getTokenName();</span><br><span class="line"><span class="type">FuncSymbol</span> <span class="variable">funcSymbol</span> <span class="operator">=</span> (FuncSymbol)curScope.getSymbol(name);</span><br><span class="line"><span class="type">FunctionSignature</span> <span class="variable">signature</span> <span class="operator">=</span> funcSymbol.getSignature();</span><br></pre></td></tr></table></figure>
<p>接着遍历 <code>module.getFunctions()</code> 根据函数名相同 <code>irFunc.getName().equals(&quot;@&quot; + name)</code> 找到对应的 <code>IrFunc function</code></p>
<p>（2）设置当前函数并且创建 <code>entry</code>，设置当前块为函数入口块</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">irBuilder.setCurFunction(function)</span><br><span class="line">entry = createBasicBlock(<span class="string">&quot;entry&quot;</span>)</span><br><span class="line">curFunction.addBasicBlock(entry)</span><br><span class="line">setCurBlock(entry)</span><br></pre></td></tr></table></figure>
<p>（3）切换作用域到函数体的 <code>scope</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">savedScope = curScope;</span><br><span class="line">curScope = signature.getBodyScope();</span><br></pre></td></tr></table></figure>
<p>（4）如果有参数，则处理形参，调用 <code>allocaParam(function, signature.getParamNames()</code>，具体实现如下：</p>
<ul>
<li>形参寄存器值 -&gt; alloca 地址 -&gt; store 值进地址 -&gt; 符号绑定地址</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 对于每个 param i */</span></span><br><span class="line">param = function.getParams().get(i) <span class="comment">// 注意这是 %0/%1... 的值</span></span><br><span class="line"><span class="type">AllocaIns</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AllocaIns</span>(param.getType()); add(a);</span><br><span class="line"><span class="type">StoreIns</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StoreIns</span>(param, a); add(s);</span><br><span class="line">symbol.setIrValue(a) <span class="comment">// 形参在函数体里当局部变量用，绑定 alloca 分配的栈地址作为 IrValue</span></span><br></pre></td></tr></table></figure>
<p>这里需要注意，如果是<strong>数组形参</strong>落栈后，符号表里存的是指针变量的地址（T **），要当数组首地址用必须先 <code>load</code> 成 T *，再 <code>gep</code></p>
<p>（5）解析函数体 <code>Block</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">calcBlock(signature.bodyBlock(), <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>这里不再需要切换作用域，因为在（2）中已经把设置 <code>bodyBlock</code> 为当前基本块</p>
<p>（6）作用域恢复 + 补充 <code>return</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curScope = savedScope; <span class="comment">// 恢复外层作用域</span></span><br></pre></td></tr></table></figure>
<p>如果当前基本块不存在结束指令 <code>!curbasicBlock.hasTerminator()</code>，需要手动补一条 <code>return</code> 语句</p>
<h4 id="6-2-5-语句块-作用域切换"><strong>6.2.5 语句块 / 作用域切换</strong></h4>
<p>除函数进入自己的 <code>entryBlock</code> 是在函数定义解析本身完成的，其余作用域的切换都通过 <code>calcBlock(block, enterNewScope)</code> 实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">avedScope = curScope;</span><br><span class="line"><span class="comment">/* 如果需要进入新作用域 */</span></span><br><span class="line">curScope = matchScopeByNode(curScope, block);</span><br><span class="line"><span class="comment">/* 遍历BlockItem/Stmt/Decl等 */</span></span><br><span class="line">calcChildren(block)</span><br><span class="line"><span class="comment">/* 恢复作用域 */</span></span><br><span class="line">curScope = savedScope</span><br></pre></td></tr></table></figure>
<h4 id="6-2-6-语句-stmt-解析"><strong>6.2.6 语句 Stmt 解析</strong></h4>
<p>处理 <code>calcStmt</code> 根据 <code>stmt.getIndexChild(0).getType()</code> 来判断，如果是 <code>SyntaxType.Token</code> 类，则进一步根据 <code>tokenName()</code> 判断</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LVal → calcAssignStmt</span><br><span class="line">Exp → calcNode(exp) <span class="comment">// 计算但丢弃返回值（表达式语句）</span></span><br><span class="line">Block → calcNode(block)</span><br><span class="line">Token → <span class="keyword">return</span>/printf/<span class="keyword">if</span>/<span class="keyword">for</span>/<span class="keyword">break</span>/<span class="keyword">continue</span>/...</span><br></pre></td></tr></table></figure>
<h4 id="6-2-7-常变量解析"><strong>6.2.7 常变量解析</strong></h4>
<p>所有的声明都从 <code>calcNode()</code> 函数中进行分发，根据当前的 <code>irBuilder.getCurFuncton()</code> 进行判断：</p>
<ul>
<li>若没有所处函数体，则为全局变量 / 常量（<code>calcGlobalConstDef / calcGlobalVarDef</code>）</li>
<li>若存在所处函数体，则为局部变量 / 常量（<code>calcLoaclVarDef / calcLoaclConstDef</code>）</li>
</ul>
<p><strong>全局常量声明</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">calcNode -&gt; calcGlobalVarDef</span><br></pre></td></tr></table></figure>
<p>处理套路：</p>
<p>（1）获取全局常量名</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name = constDef.getIndexChild(<span class="number">0</span>).getTokenName();</span><br></pre></td></tr></table></figure>
<p>（2）根据常量名获取符号</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ValueSymbol</span> <span class="variable">valueSymbol</span> <span class="operator">=</span> (ValueSymbol) curScope.getSymbol(name);</span><br></pre></td></tr></table></figure>
<p>（3）计算 IR 名：<code>&quot;@&quot; + name</code></p>
<p>（4）得到全局常量 IR 类型，把符号描述器 <code>ValueSymbolDescriptor</code> 传入 <code>getType()</code> 中即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getIrType(valueSymbol.getValueSymbolDescriptor());</span><br></pre></td></tr></table></figure>
<ul>
<li>数组 → <code>IrArrayType(tot, i32)</code>，其中 <code>tot</code> 来自数组各维度的乘积 <code>dim1 * dim2 * ...</code></li>
<li>标量 → <code>i32</code></li>
</ul>
<p>（5）生成初始化常量，调用<strong>全局初始化</strong>生成器：<code>getGlobalInit(valueSymbol)</code></p>
<ul>
<li>数组初始化值 → <code>IrConstArray(initVals, IrArrayType(tot,i32))</code></li>
<li>标量初始化值 → <code>IrConstInt(val)</code>（空则给 0）</li>
</ul>
<p>（7）生成全局变量符号 global</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 全局变量类型 + 全局变量名 + 常量标记 + 初始化值 / 列表 */</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">IrGlobalVar</span>(type, <span class="string">&quot;@x&quot;</span>, <span class="literal">true</span>, initVal)</span><br></pre></td></tr></table></figure>
<p>（8）模块登记：<code>module.addGlobalVars(globalVar)</code></p>
<p>（9）<strong>把符号绑定到 IR 值</strong>：<code>symbol.setIrValue(globalVar)</code></p>
<p><strong>全局变量声明</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">calcNode -&gt; calcGlobalVarDef(isStatic)</span><br></pre></td></tr></table></figure>
<p>处理套路：</p>
<p>（1）获取全局变量名，全局变量符号，拿到对应的 IR 类型，这几步和全局常量声明完全相同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name = varDef.getIndexChild(<span class="number">0</span>).getTokenName();</span><br><span class="line">valueSymbol = (ValueSymbol)curScope.getSymbol(name);</span><br><span class="line">type = getType(valueSymbol.getValueSymbolDescriptor());</span><br></pre></td></tr></table></figure>
<p>（2）生成 IR 名</p>
<ul>
<li><code>isStatic = True</code>：<code>curFunctionName + &quot;_static_&quot; + name + count++</code>，静态变量提升成的全局变量</li>
<li><code>isStatic = False</code>：<code>&quot;@&quot; + name</code>，全局变量</li>
</ul>
<p>（3）计算初始化值，调用<strong>全局初始化</strong>生成器 <code>getGlobalInit(valueSymbol)</code> 即可</p>
<p>（4）生成全局变量符号</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 类型 + 名称 + 常量标记 + 初始化值 / 列表 */</span></span><br><span class="line">golbalVar = <span class="keyword">new</span> <span class="title class_">GlobalVar</span>(type, irName, <span class="literal">false</span>, initVal);</span><br></pre></td></tr></table></figure>
<p>（5）如果是静态变量，需要设置内部链接 <code>globalVar.setInternal(true)</code></p>
<p>（6）全局变量加入模块中，同时绑定符号表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">irBuilder.getModule().addGlobalVar(globalVar);</span><br><span class="line">symbol.setIrValue(globalVar);</span><br></pre></td></tr></table></figure>
<p><strong>局部常量声明</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">calcNode -&gt; calcLoaclConstDef</span><br></pre></td></tr></table></figure>
<p>（1）获取名称 name，符号 symbol，变量类型 IrType，这三部和全局符号完全相同</p>
<p>（2）为局部常量分配栈上地址</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Alloca</span> <span class="variable">alloca</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Alloca</span>(irType);</span><br><span class="line">irBuilder.addInstruction(alloca)</span><br></pre></td></tr></table></figure>
<p>（3）局部常量符号绑定的 IrValue 为其在栈上的地址，因此需要绑定 <code>Alloca</code> 的结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">symbol.setIrValue(alloca)</span><br></pre></td></tr></table></figure>
<p>（4）解析局部常量初始化值</p>
<ul>
<li>
<p>数组：调用专门的解析函数 <code>initArray(alloca, constInitVal, descriptor)</code></p>
</li>
<li>
<p>标量：直接用局部常量对应的 <code>valueSymbolDescriptor</code> 内部的编译器常量初始化 <code>IrConstInt</code>，接着 <code>store</code> 即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">IrConstInt</span> <span class="variable">initVal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IrConstInt</span>(valueSymbolDescriptor.getConstScalarValue());</span><br><span class="line"><span class="type">Store</span> <span class="variable">store</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Store</span>(initVal, alloca);</span><br><span class="line">irBuilder.addInstruction(store);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>局部常量在 LLVM IR 里通常也就是一块 alloca 栈内存 + store 初值</p>
<p><strong>局部变量声明</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">calcNode -&gt; calcLoaclVarDef</span><br></pre></td></tr></table></figure>
<p>（1）获取名称 name，符号 symbol，变量类型 IrType，这三部和全局符号完全相同</p>
<p>（2）根据变量描述器中 <code>isStatic</code> 标记，如果是静态变量，则调用 <code>calcGlobalVar(VarDef, true)</code> 当做全局变量解析</p>
<p>（3）如果是普通局部变量，则生成对应的 <code>alloca</code> 语句为其分配地址</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Alloca</span> <span class="variable">alloca</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Alloca</span>(irType);</span><br><span class="line">irBuilder.addInstruction(alloca);</span><br><span class="line">symbol.setIrValue(alloca);</span><br></pre></td></tr></table></figure>
<p>（4）解析局部变量初始化值</p>
<ul>
<li>没有 <code>init</code> 这部分就直接 <code>return</code></li>
<li>数组类型初始化值，调用 <code>initArray</code> 方法解析</li>
<li>标量初始化值，调用 <code>calcInitVal</code> 方法解析</li>
</ul>
<p>注意：局部数组初始化和局部常量初始化共用同一套 initArray 逻辑</p>
<h4 id="6-2-8-初始化值-列表解析"><strong>6.2.8 初始化值 / 列表解析</strong></h4>
<p>（1）全局初始化值解析 <code>getGlobalInit(ValueSymbol symbol)</code></p>
<p>使用全局变量 / 常量对应的 <code>valueSymbol</code> 中的初始化列表 <code>initializerValues</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; initVals = symbol.getInitializerValues();</span><br></pre></td></tr></table></figure>
<p>根据 <code>initVals</code> 列表的长度，判断返回数组初始化值 <code>IrConstArray</code> 或者返回标量初始化值 <code>IrConstInt</code></p>
<p>（2）局部数组初始化值解析 <code>initArray(IrValue arrayPtr, AstNode initNode, ValueSymbolDescriptor vsd)</code></p>
<p>先调用 <code>flattenInitVal</code> 把可能存在的多维数组初始化列表压缩成线性 <code>values</code>，对于其中的每一个 <code>value</code>：</p>
<ul>
<li>
<p>写入阶段</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Gep</span> <span class="variable">gep</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Gep</span>(arrayPtr, i); add(gep);</span><br><span class="line"><span class="type">Store</span> <span class="variable">store</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Store</span>(values[i], gep); add(store);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>补 0 阶段（初始化列表长度 &lt; 数组长度），剩下部分需要补充 0</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Gep</span> <span class="variable">gep</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Gep</span>(arrayPtr, i); add(gep);</span><br><span class="line"><span class="type">Store</span> <span class="variable">store</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Store</span>(<span class="number">0</span>, gep);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>（3）局部标量初始化值解析 <code>calcInitVal(initVal)</code></p>
<p>此时 <code>initVal</code> 中仅有一个 <code>exp</code> 节点，相当于是对 <code>calcNode(exp)</code> 的一个封装</p>
<p>总结：你可以把初始化值处理背成这 6 句：</p>
<ol>
<li>全局：只用常量对象初始化（<code>IrConstInt / IrConstArray</code>），靠 <code>getGlobalInit</code></li>
<li>局部标量：<code>alloca + calcInitVal(Exp) + store</code></li>
<li>局部数组：<code>alloca + initArray(flatten → gep/store → 补0</code>)</li>
<li>数组初始化写入永远是：<code>elemPtr = gep(base, i)；store(val, elemPtr);</code></li>
<li>缺省初始化：全局靠默认 0（<code>null/zeroinitializer</code>），局部数组靠补0循环</li>
<li>语义保证：全局 <code>initVals</code> 必须是编译期整数；局部 <code>initVal</code> 可含表达式</li>
</ol>
<h4 id="6-2-9-左值-lval-的两种解析"><strong>6.2.9 左值 LVal 的两种解析</strong></h4>
<p>对于左值 <code>LVal</code> 的解析，如果当做右值需要 <code>load</code> 读值，如果当做左值只需要计算地址 <code>gepPtr</code></p>
<p>现在给符号表中的 <code>symbol</code> 所绑定的 IrValue 全是<strong>地址</strong>：</p>
<ul>
<li>局部标量 / 数组：<code>alloca</code>，对应 <code>getIrValue()</code> 的结果是 <code>i32*</code> 或 <code>[N x i32]*</code></li>
<li>形参：<code>alloca + store</code>，给 <code>symbol</code> 绑定的是 <code>alloca</code>，对应 <code>getIrValue()</code> 的结果是 <code>i32**</code></li>
<li>全局变量 / 全局常量 / 静态局部变量：<code>IrGlobalVar</code>，本质上也是地址 / 符号的引用，对应 <code>getIrValue()</code> 的结果是 <code>i32*</code> 或 <code>[N x i32]*</code></li>
</ul>
<p>因此对于 <code>symbol.getIrValue()</code> 而言，其取出的都是一个地址，而不是对应的 <code>i32</code> 值，这决定了 <code>LVal</code> 在作为右值的时候必须 <code>load</code>，作为左值的时候直接用它当地址即可</p>
<p><strong>右值 calcLVal</strong></p>
<p>先拿到 <code>lVal</code> 对应的 <code>ptr</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Symbol</span> <span class="variable">symbol</span> <span class="operator">=</span> getVisibleSymbol(name);</span><br><span class="line"><span class="type">IrValue</span> <span class="variable">ptr</span> <span class="operator">=</span> symbol.getIrValue(symbol);</span><br></pre></td></tr></table></figure>
<p>这里的 <code>ptr</code> 是指针类型 T*，我们认为如果其指向的元素 T 是数组类型即当做数组元素处理，即 <code>((IrPointerType)ptr).getElementType() instance of IrArrayType</code></p>
<p>这里我们需要<strong>特殊</strong>考虑一种情况，即 <code>ptr</code> 是 T **，而 <code>ptr.getElementPtr()</code> 是 T *，也就是数组传参的时候，传入的参数是 <code>i32*</code>，对应的形参取出 IrValue 记为 <code>i32**</code>，此时需要先 <code>load</code> 一次取出对应的 <code>i32*</code> 指针，后续这个指针才能继续作为数组首地址使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">IrType</span> <span class="variable">arrayPtr</span> <span class="operator">=</span> ptr;</span><br><span class="line"><span class="keyword">if</span> (ptr instance of IrPointerType &amp;&amp; ptr.getElementPtr() instance of IrPointerType) &#123;</span><br><span class="line">	<span class="type">Load</span> <span class="variable">load</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Load</span>(ptr);</span><br><span class="line">    irBuilder.addInstruction(load);</span><br><span class="line">    arrayPtr = load;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应也就是把 <code>i32**</code> 加载出 <code>i32*</code> 的过程</p>
<p>（1）右值为标量</p>
<p>直接 <code>load</code> 即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Load</span> <span class="variable">load</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Load</span>(ptr);</span><br><span class="line">irBuilder.addInstruction(load);</span><br></pre></td></tr></table></figure>
<p>（2）右值为数组元素</p>
<p>先 <code>gep</code> 得到数组元素对应的地址，再 <code>load</code> 得到对应的元素值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">IrValue</span> <span class="variable">idx</span> <span class="operator">=</span> calcNode(exp);</span><br><span class="line"><span class="type">Gep</span> <span class="variable">gep</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Gep</span>(ptr, idx);</span><br><span class="line">irBuilder.addInstruction(gep);</span><br><span class="line"><span class="type">Load</span> <span class="variable">load</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Load</span>(gep);</span><br><span class="line">irBuilder.addInstruction(gep);</span><br></pre></td></tr></table></figure>
<p>（3）右值为数组名（用于传参的时候）</p>
<p>只需要 gep 得到数组首元素的地址即可，因为此时数组在参数中退化为指向数组首元素地址的指针</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Gep</span> <span class="variable">gep</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Gep</span>(ptr, <span class="keyword">new</span> <span class="title class_">IrConstInt</span>(<span class="number">0</span>));</span><br></pre></td></tr></table></figure>
<p>规律：标量：load；数组名：取首地址；数组元素：gep 后 load</p>
<p><strong>左值 calcLValAsPointer</strong></p>
<p>左值在我们当前的文法中只有两类是合理的，一类是标量的左值，直接返回地址 <code>ptr</code> 即可，一类是数组元素的左值，需要 <code>gep</code> 返回那个元素具体的地址，<strong>注意</strong>：这里数组名不作为左值，因此不需要考虑右值中（3）的情况</p>
<p>获取元素对应地址 <code>ptr</code> 的思路还是同上：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Symbol</span> <span class="variable">symbol</span> <span class="operator">=</span> getVisibleSymbol(name);</span><br><span class="line"><span class="type">IrValue</span> <span class="variable">ptr</span> <span class="operator">=</span> symbol.getIrValue();</span><br></pre></td></tr></table></figure>
<p>同时如果 <code>ptr</code> 是 T** 也要先做一次 <code>load</code> 拿到对应内层的指针，才能继续作为数组首元素的地址使用</p>
<p>（1）标量左值</p>
<p>直接返回这个 <code>ptr</code> 即可</p>
<p>（2）数组元素左值</p>
<p>需要根据这个 <code>ptr</code>（此时是数组首元素地址），结合偏移计算出当前元素真正的地址再返回 <code>gep</code> 的结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">IrValue</span> <span class="variable">index</span> <span class="operator">=</span> calcNode(exp);</span><br><span class="line"><span class="type">Gep</span> <span class="variable">gep</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Gep</span>(ptr, index); <span class="comment">// 这里的 index 是 IrValue 类型</span></span><br><span class="line">irBuilder.addInstruction(gep);</span><br></pre></td></tr></table></figure>
<h4 id="6-2-a-短路求值"><strong>6.2.A 短路求值</strong></h4>
<p>表达式 : a || b || c，这个表达式在左递归文法下会表示成 (a || b) || c，转化为文法符号也就是 <code>LOrExp || LAndExp</code>，其中左侧的表达式统一看成一个 <code>LOrExp</code> 的整体，最后和最右边的一个 <code>LAndExp</code> 运算</p>
<ol>
<li>因此会先计算 a || b 生成对应的 left_0，true_0，right_0，end_0，a || b 判断结束时控制流处于 end_0 位置</li>
<li>接着计算 a || b 的结果（记为 t_ab）t_ab || c 的结果，开始时控制流处于 end_0 块内，生成对应的 left_1，right_1，true_1，end_1，结束时控制流处于 end_1 位置<br>
t_ab = a || b</li>
</ol>
<p><code>a || b</code> 计算过程：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">                 ┌───────────────────────────────┐</span><br><span class="line">                 │   <span class="built_in">lor_left_0</span>  (进入内层时的当前块) │</span><br><span class="line">                 │   %a = <span class="built_in">eval</span>(a)                │</span><br><span class="line">                 │   %a_i1 = icmp ne %a, <span class="number">0</span>       │</span><br><span class="line">                 │   br %a_i1 ? true_0 : right_0 │</span><br><span class="line">                 └───────────────┬───────────────┘</span><br><span class="line">                                 │<span class="literal">true</span></span><br><span class="line">                                 v</span><br><span class="line">                        ┌─────────────────┐</span><br><span class="line">                        │   lor_true_0    │</span><br><span class="line">                        │   br lor_end_0  │</span><br><span class="line">                        └────────┬────────┘</span><br><span class="line">                                 │</span><br><span class="line">                                 │</span><br><span class="line"><span class="literal">false</span>                            v</span><br><span class="line">│                       ┌──────────────────────────┐</span><br><span class="line">v                       │        lor_end_0         │</span><br><span class="line">┌─────────────────┐     │ %t_ab = phi i32 [<span class="number">1</span>,true_0],│</span><br><span class="line">│  lor_right_0    │────&gt;│                [%b_i32,right_0]│</span><br><span class="line">│  %b = <span class="built_in">eval</span>(b)   │     └──────────────────────────┘</span><br><span class="line">│  %b_i1=icmp ne %b,<span class="number">0</span>   （内层结果：%t_ab）</span><br><span class="line">│  %b_i32=zext %b_i1-&gt;i32</span><br><span class="line">│  br lor_end_0</span><br><span class="line">└─────────────────┘</span><br></pre></td></tr></table></figure>
<p><code>t_ab || c</code> 计算过程：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">┌──────────────────────────┐</span><br><span class="line">│        lor_end_0         │  （这里不仅是内层 end，也变成了外层左值已就绪的位置）</span><br><span class="line">│  %t_ab = phi ...         │</span><br><span class="line">│  %t_ab_i1 = icmp ne %t_ab,<span class="number">0</span></span><br><span class="line">│  br %t_ab_i1 ? true_1 : right_1</span><br><span class="line">└──────────────┬───────────┘</span><br><span class="line">               │<span class="literal">true</span></span><br><span class="line">               v</span><br><span class="line">        ┌─────────────────┐</span><br><span class="line">        │   lor_true_1    │</span><br><span class="line">        │   br lor_end_1  │</span><br><span class="line">        └────────┬────────┘</span><br><span class="line">                 │</span><br><span class="line"><span class="literal">false</span>            v</span><br><span class="line">│        ┌──────────────────────────┐</span><br><span class="line">v        │        lor_end_1          │</span><br><span class="line">┌─────────────────┐  %t_abc = phi i32 [<span class="number">1</span>,true_1],  │</span><br><span class="line">│  lor_right_1    │  │                [%c_i32,right_1]│</span><br><span class="line">│  %c = <span class="built_in">eval</span>(c)   │  └──────────────────────────┘</span><br><span class="line">│  %c_i1=icmp ne %c,<span class="number">0</span>     （最终结果：%t_abc）</span><br><span class="line">│  %c_i32=zext %c_i1-&gt;i32</span><br><span class="line">│  br lor_end_1</span><br><span class="line">└─────────────────┘</span><br></pre></td></tr></table></figure>
<h4 id="6-2-b-表达式链"><strong>6.2.B 表达式链</strong></h4>
<p>每一层表达式链都在套用这个模版：</p>
<ul>
<li>如果是单个的 <code>childs.size() == 1</code>，直接递归下去即可，这里体现出我们语法分析生成 AST 满足左节点递归调用本运算类型，右节点为单一子节点类型的优势，便于我们在中间代码生成时进行递归调用的解析</li>
<li>否则分别计算 <code>left</code> 和 <code>right</code>，解析 <code>op</code>，生成对应的二元运算指令返回结果</li>
</ul>
<h2 id="符号表-语义分析扩展"><strong>符号表 &amp; 语义分析扩展</strong></h2>
<p>如果不考虑新增错误类型（大概率考试重点也不会放在错误处理上，模拟考只有一个和错误有关的测试点），对符号表的可能的修改只有三个地方：</p>
<h3 id="7-1-stmt-分发"><strong>7.1 Stmt 分发</strong></h3>
<p>如果新增指令是一条控制流 / 语句流指令，需要在<code>Stmt</code>中根据其<code>firstChild</code>或者<code>firstToken</code>新增一条指向它的解析方法的分支</p>
<h3 id="7-2-stmt-处理"><strong>7.2 Stmt 处理</strong></h3>
<p>即对这条新增的语句流具体解析的实现，语义分析的解析还是比较简单的，只需要遍历当前<code>Stmt</code>的所有<code>getChilds()</code>，对每个<code>child</code>判断类型，调用对应的方法进行解析，如果是<code>Exp</code>有关的子节点，则调用<code>expEvaluetor</code>类中的运算解析方法进行解析即可，大致流程形如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (AstNode child : stmt.getChilds()) &#123;</span><br><span class="line">	<span class="keyword">if</span> (child.getType() == ...) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (child.getType() == ....) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，在解析循环相关新增指令（比如<code>while</code>，<code>repeat-until</code>）这种的时候，解析之前需要新增循环栈，解析完成需要退出循环栈，即实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">loopStack.push(loopStack.size() - <span class="number">1</span>);</span><br><span class="line">...</span><br><span class="line">loopStack.pop();</span><br></pre></td></tr></table></figure>
<p>这里给一个具体的示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 新增 while 循环的解析逻辑，while 不允许 cond 为空 */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="type">void</span> <span class="title">processWhileStmt</span><span class="params">(AstNode stmt)</span> </span>&#123;</span><br><span class="line">    loopStack.<span class="built_in">push</span>(loopStack.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span> (AstNode child : stmt.<span class="built_in">getChilds</span>()) &#123;</span><br><span class="line">        SyntaxType childType = child.<span class="built_in">getType</span>();</span><br><span class="line">        <span class="keyword">if</span> (childType == SyntaxType.CondExp) &#123;</span><br><span class="line">            expEvaluater.<span class="built_in">evalCond</span>(child);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childType == SyntaxType.Stmt) &#123;</span><br><span class="line">            <span class="built_in">processStmt</span>(child);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    loopStack.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-3-exp-处理"><strong>7.3 Exp 处理</strong></h3>
<p>如果是新增一类运算类指令，具体又可以分为：</p>
<ul>
<li>在某一级现有运算指令上，增加一个新的运算符（比如在<code>MulExp</code>的乘，除，模的基础上，增加上取整除）</li>
<li>新增一个运算类的指令级，比如在<code>RelExp</code>和<code>AddExp</code>之间新增一级<code>ShiftExp</code></li>
</ul>
<p>前者的处理很简单，只需要找到原有的那一级表达式，在运算符<code>switch(op)</code>那里加一个分支即可，后者则需要先修改表达式调用链，接着新增对应的表达式处理方法，这个的实现也比较套路，大致就是先判断如果只有一个<code>child</code>，则直接递归向下一级解析，否则则分别解析左运算数和右运算数，如果二者都是常量，则继续根据<code>op</code>的类型，进行常量折叠计算，最后构造<code>ExpInfo</code>向上一级传播即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 新增移位运算 */</span></span><br><span class="line"><span class="keyword">private</span> ExpInfo <span class="title function_">evalShiftExp</span><span class="params">(AstNode eqExp)</span> &#123;</span><br><span class="line">    List&lt;AstNode&gt; childs = eqExp.getChilds();</span><br><span class="line">    <span class="keyword">if</span> (childs.size() == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> evalAddExp(childs.get(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ExpInfo</span> <span class="variable">left</span> <span class="operator">=</span> evalShiftExp(childs.get(<span class="number">0</span>));</span><br><span class="line">    <span class="type">ExpInfo</span> <span class="variable">right</span> <span class="operator">=</span> evalAddExp(childs.get(<span class="number">2</span>));</span><br><span class="line">    <span class="keyword">if</span> (left.isError || right.isError) &#123;</span><br><span class="line">        <span class="keyword">return</span> ExpInfo.error();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isConst</span> <span class="operator">=</span> left.isConst &amp;&amp; right.isConst;</span><br><span class="line">    <span class="type">TokenType</span> <span class="variable">op</span> <span class="operator">=</span> childs.get(<span class="number">1</span>).getToken().getTokenType();</span><br><span class="line">    <span class="keyword">if</span> (isConst) &#123;</span><br><span class="line">        value = <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">            <span class="keyword">case</span> TokenType.LeftShift -&gt; left.constValue &lt;&lt; right.constValue;</span><br><span class="line">            <span class="keyword">case</span> TokenType.RightShift -&gt; left.constValue &gt;&gt; right.constValue;</span><br><span class="line">            <span class="keyword">default</span> -&gt; <span class="number">0</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ExpInfo.scalar(BasicType.INT, isConst, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="上机题目"><strong>上机题目</strong></h2>
<h3 id="8-1-for-decl"><strong>8.1 for + decl</strong></h3>
<p><strong>题目要求</strong></p>
<p>新增文法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stmt → <span class="string">&#x27;for&#x27;</span> <span class="string">&#x27;(&#x27;</span> BType Ident <span class="string">&#x27;=&#x27;</span> InitVal <span class="string">&#x27;;&#x27;</span> Cond <span class="string">&#x27;;&#x27;</span> ForStmt <span class="string">&#x27;)&#x27;</span> Stmt</span><br></pre></td></tr></table></figure>
<p>即允许在<code>for</code>循环的<code>forInit</code>位置写变量声明，对于下面的文法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (BType Ident = InitVal; cond; forStep) &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在语义上等价为下面的实现（重点是对作用域的要求）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  BType Ident = InitVal;</span><br><span class="line">  <span class="keyword">for</span> (; Cond; ForStmt) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>实现方法</strong></p>
<p>我们考虑把变量声明提出来，把变量声明和剩下的<code>for</code>循环体作为两条<code>BlockItem</code>分别维护</p>
<p>具体来讲，我们原本解析的是一个<code>Stmt</code>，现在我们将其手动封装为下面的结构：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stmt -&gt; Block -&gt; <span class="string">&#x27;&#123;&#x27;</span> BlockItem1 BlockItem2 <span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line">BlockItem1 -&gt; Decl -&gt; VarDecl -&gt; ...</span><br><span class="line">BlockItem2 -&gt; Stmt -&gt; ...</span><br></pre></td></tr></table></figure>
<p>我们的语法分析阶段是支持这么创建节点的，通过<code>AstFactory</code>的节点创建够能，我们很容易完成这样一层封装，对应的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AstNode</span> <span class="variable">forInitStmt</span> <span class="operator">=</span> AstFactory.creatAstNode(SyntaxType.Stmt, forInitStmt_childs, lineNumber);</span><br><span class="line">List&lt;AstNode&gt; blockItem1_childs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">blockItem1_childs.add(decl);</span><br><span class="line"><span class="type">AstNode</span> <span class="variable">blockItem1</span> <span class="operator">=</span> AstFactory.creatAstNode(SyntaxType.BlockItem, blockItem1_childs, lineNumber);</span><br><span class="line">List&lt;AstNode&gt; blockItem2_childs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">blockItem2_childs.add(forInitStmt);</span><br><span class="line"><span class="type">AstNode</span> <span class="variable">blockItem2</span> <span class="operator">=</span> AstFactory.creatAstNode(SyntaxType.BlockItem, blockItem2_childs, lineNumber);</span><br><span class="line">List&lt;AstNode&gt; block_childs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">block_childs.add(AstFactory.creatAstLeafNode(<span class="keyword">new</span> <span class="title class_">Token</span>(TokenType.LBRACE,<span class="string">&quot;&#123;&quot;</span>, lineNumber)));</span><br><span class="line">block_childs.add(blockItem1);</span><br><span class="line">block_childs.add(blockItem2);</span><br><span class="line">block_childs.add(AstFactory.creatAstLeafNode(<span class="keyword">new</span> <span class="title class_">Token</span>(TokenType.RBRACE,<span class="string">&quot;&#125;&quot;</span>, lineNumber)));</span><br><span class="line"><span class="type">AstNode</span> <span class="variable">block</span> <span class="operator">=</span> AstFactory.creatAstNode(SyntaxType.Block, block_childs, lineNumber);</span><br><span class="line">List&lt;AstNode&gt; stmt_childs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">stmt_childs.add(block);</span><br></pre></td></tr></table></figure>
<p>需要注意的是，我们不能直接调用原有的<code>visitVarDecl</code>，因为原本的变量声明文法末尾是包含一个分号的，这里我们提出的<code>VarDecl</code>不解析这个分号，而是把分号留给<code>for</code>循环去解析，对应的处理方法是仿照<code>visitVarDecl</code>方法再重写一个<code>visitVarDeclWithoutSemicn</code>方法，在原本<code>expectToken(SEMICN)</code>的时候直接创建一个<code>SemicnToken</code>加入子节点列表即可</p>
<p>我们发现，做完语法分析后，我们自动把新文法拆成了一条<code>VarDecl</code>和一条一定没有<code>initStmt</code>的<code>ForStmt</code>，这两条文法现有编译器都是支持的，因此我们不需要再进行后续修改</p>
<h3 id="8-2-while-decl"><strong>8.2 while + decl</strong></h3>
<p><strong>题目要求</strong></p>
<p>新增文法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stmt → <span class="string">&#x27;While&#x27;</span> <span class="string">&#x27;(&#x27;</span> BType Ident <span class="string">&#x27;=&#x27;</span> InitVal <span class="string">&#x27;)&#x27;</span> Stmt</span><br></pre></td></tr></table></figure>
<p>即允许在<code>while</code>循环的<code>Cond</code>写变量声明，对于下面的文法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (BType Ident = InitVal) &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在语义上等价为下面的实现（重点是对作用域的要求）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  BType Ident = InitVal;</span><br><span class="line">  <span class="keyword">while</span> (Ident) &#123;</span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>实现方法</strong></p>
<p>本例和上一例相比难度增加之处在于不能把新增文法拆成完全独立的两条<code>VarDecl</code>和<code>WhileStmt</code>，因为声明的变量还要作为<code>While</code>循环的条件填入<code>Cond</code>位置，但是文法保证此时的<code>Cond</code>位置填写的一定是一个变量标识符<code>Ident</code>，即在<code>llvm</code>生成阶段，该条件的真假可以通过<code>Ident</code>对应的<code>IrValue</code>和<code>0</code>比较得到，所以我们只要支持解析<code>while</code>循环时，能拿到对应变量的<code>Ident</code>即可</p>
<p>因此我们考虑在调用解析<code>visitVarDeclWithoutSemicn</code>得到<code>VarDecl</code>节点以后，把这个<code>VarDecl</code>填入对应的<code>Cond</code>位置，在生成<code>llvm</code>的时候，只需要在进入<code>condBlock</code>即将解析条件的时候，根据<code>Cond</code>位置到底是<code>CondExp</code>还是新增文法填入的<code>VarDecl</code>特判即可，如果是后者，只需要根据变量<code>name</code>找到它在作用域中绑定的<code>Alloca</code>地址，把对应的值<code>Load</code>出来即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (node.getType() == SyntaxType.VarDecl) &#123;</span><br><span class="line">    <span class="comment">// WhileInitStmt</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> node.getIndexChild(<span class="number">1</span>).getIndexChild(<span class="number">0</span>).getTokenName();</span><br><span class="line">    <span class="type">IrValue</span> <span class="variable">ptr</span> <span class="operator">=</span> curScope.getSymbol(name).getIrValue();</span><br><span class="line">    <span class="type">IrLoad</span> <span class="variable">load</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IrLoad</span>(ptr);</span><br><span class="line">    irBuilder.addInstruction(load);</span><br><span class="line">    cond = load;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.getType() == SyntaxType.CondExp) &#123;</span><br><span class="line">    <span class="comment">// WhileStmt</span></span><br><span class="line">    cond = calcCond(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>补充说明</strong></p>
<p>在实现了<code>for</code>和<code>while</code>中支持变量声明以后，我们发现 2024 年期末对于<code>if</code>的处理也可以用相同的原理实现，几乎就是对本例的<code>copy</code>，这里不再赘述</p>
<h3 id="8-3-powexp"><strong>8.3 PowExp</strong></h3>
<p><strong>题目要求</strong></p>
<p>文法说明：在<code>MulExp</code>和<code>UnaryExp</code>之间插入一级<code>PowExp</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Exp     → AddExp</span><br><span class="line">AddExp  → MulExp &#123; (<span class="string">&#x27;+&#x27;</span> | <span class="string">&#x27;-&#x27;</span>) MulExp &#125;</span><br><span class="line">MulExp  → PowExp &#123; (<span class="string">&#x27;*&#x27;</span> | <span class="string">&#x27;/&#x27;</span> | <span class="string">&#x27;%&#x27;</span>) PowExp &#125;</span><br><span class="line">PowExp  → UnaryExp [ <span class="string">&#x27;**&#x27;</span> PowExp ]</span><br><span class="line">UnaryExp → PrimaryExp</span><br><span class="line">         | Ident <span class="string">&#x27;(&#x27;</span> [FuncRParams] <span class="string">&#x27;)&#x27;</span></span><br><span class="line">         | UnaryOp UnaryExp</span><br><span class="line">UnaryOp  → <span class="string">&#x27;+&#x27;</span> | <span class="string">&#x27;-&#x27;</span> | <span class="string">&#x27;!&#x27;</span></span><br><span class="line">PrimaryExp → <span class="string">&#x27;(&#x27;</span> Exp <span class="string">&#x27;)&#x27;</span></span><br><span class="line">           | LVal</span><br><span class="line">           | Number</span><br><span class="line">Cond    → LOrExp</span><br><span class="line">LOrExp  → LAndExp &#123; <span class="string">&#x27;||&#x27;</span> LAndExp &#125;</span><br><span class="line">LAndExp → EqExp   &#123; <span class="string">&#x27;&amp;&amp;&#x27;</span> EqExp   &#125;</span><br><span class="line">EqExp   → RelExp  &#123; (<span class="string">&#x27;==&#x27;</span> | <span class="string">&#x27;!=&#x27;</span>) RelExp &#125;</span><br><span class="line">RelExp  → AddExp  &#123; (<span class="string">&#x27;&lt;&#x27;</span> | <span class="string">&#x27;&lt;=&#x27;</span> | <span class="string">&#x27;&gt;&#x27;</span> | <span class="string">&#x27;&gt;=&#x27;</span>) AddExp &#125;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li><code>PowExp</code>是右结合运算，即<code>a**b**c</code>的计算顺序应为<code>a**(b**c)</code></li>
<li><code>llvm</code>中没有现成支持乘方的指令，需要用现有指令组合完成乘方运算</li>
</ul>
<p><strong>实现方法</strong></p>
<p>首先考虑肯定要修改表达式链，在<code>MulExp</code>和<code>UnaryExp</code>之间加入<code>PowExp</code></p>
<p>其次考虑右结合的实现，所谓左结合运算，比如<code>AddExp</code>，我们维护的节点结构应当是<code>[AddExp, op, MulExp]</code>，也就是先把左侧的<code>AddExp</code>中的所有<code>MulExp</code>算出来，再和最后一个<code>MulExp</code>运算，对应我们用<code>While</code>循环来实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AstNode</span> <span class="variable">node</span> <span class="operator">=</span> AstFactory.creatAstNode(SyntaxType.AddExp, visitMulExp(ctx));</span><br><span class="line"><span class="keyword">while</span> (ctx.checkType(TokenType.PLUS) || ctx.checkType(TokenType.MINU)) &#123;</span><br><span class="line">    <span class="type">Token</span> <span class="variable">opTk</span> <span class="operator">=</span> ctx.consume();</span><br><span class="line">    List&lt;AstNode&gt; childs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    childs.add(node);</span><br><span class="line">    childs.add(AstFactory.creatAstLeafNode(opTk));</span><br><span class="line">    childs.add(visitMulExp(ctx));</span><br><span class="line">    node = AstFactory.creatAstNode(SyntaxType.AddExp, childs, node.getLineNumber());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> node;</span><br></pre></td></tr></table></figure>
<p>而对于右结合运算<code>PowExp</code>，我们维护的节点结构应当是<code>[UnaryExp, op, PowExp]</code>，也就是先把右侧的<code>PowExp</code>中所有的<code>UnaryExp</code>算出来，再和第一个<code>UnaryExp</code>运算，对应我们用<code>if+dfs</code>来实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">lineNumber</span> <span class="operator">=</span> ctx.getCurrentLineNumber();</span><br><span class="line"><span class="type">AstNode</span> <span class="variable">leftUnary</span> <span class="operator">=</span> visitUnaryExp(ctx);</span><br><span class="line"><span class="keyword">if</span> (!ctx.checkType(TokenType.POW)) &#123;</span><br><span class="line">    <span class="keyword">return</span> AstFactory.creatAstNode(SyntaxType.PowExp, leftUnary);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Token</span> <span class="variable">opTk</span> <span class="operator">=</span> ctx.consume();</span><br><span class="line">List&lt;AstNode&gt; childs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">childs.add(leftUnary);</span><br><span class="line">childs.add(AstFactory.creatAstLeafNode(opTk));</span><br><span class="line">childs.add(visitPowExp(ctx)); <span class="comment">// 右递归保证右结合</span></span><br><span class="line"><span class="keyword">return</span> AstFactory.creatAstNode(SyntaxType.PowExp, childs, lineNumber);</span><br></pre></td></tr></table></figure>
<p>由于是表达式的修改，有可能触发语义分析阶段的常量折叠，同时语义分析阶段的表达式链也要做相应修改，这部分实现比较简单，不要遗漏即可</p>
<p>最后是<code>llvm</code>生成阶段，这部分是重点，因为<code>llvm</code>本身不含有乘方指令，因此我们需要考虑在<code>llvm</code>中生成一个类似于下面的循环，用来完成<code>a**b</code>的计算，也就是说这里需要我们自己构建<code>llvm</code>指令：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; b) &#123;</span><br><span class="line">    res = res * a;</span><br><span class="line">    i = i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure>
<p>所谓构造<code>llvm</code>指令，就是不参考对应的语法树，直接生成<code>llvm</code>指令，比如对于<code>int i = 0;</code>这么一条语句，可能翻译成<code>llvm</code>就需要：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">IrAlloca</span> <span class="variable">iPtr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IrAlloca</span>(IrBaseType.I32);</span><br><span class="line">irBuilder.addInstruction(iPtr);</span><br><span class="line">irBuilder.addInstruction(<span class="keyword">new</span> <span class="title class_">IrStore</span>(iPtr, <span class="keyword">new</span> <span class="title class_">IrConstInt</span>(<span class="number">0</span>)));</span><br></pre></td></tr></table></figure>
<p>有了上述自己生成<code>llvm</code>的思想，我们在<code>calcPowExp</code>方法中，手动生成一个循环用来求解乘方运算也就不困难了，可以参考我构造<code>llvm</code>的代码，可能指令实现细节不同，但大致逻辑是相同的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> IrValue <span class="title function_">calcPowExp</span><span class="params">(AstNode powExp)</span> &#123;</span><br><span class="line">    List&lt;AstNode&gt; childs = powExp.getChilds();</span><br><span class="line">    <span class="keyword">if</span> (childs.size() == <span class="number">1</span> &amp;&amp; childs.get(<span class="number">0</span>).getType() == SyntaxType.UnaryExp) &#123;</span><br><span class="line">        <span class="keyword">return</span> calcNode(childs.get(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (childs.size() == <span class="number">3</span> &amp;&amp;</span><br><span class="line">        childs.get(<span class="number">0</span>).getType() == SyntaxType.UnaryExp &amp;&amp;</span><br><span class="line">        childs.get(<span class="number">1</span>).getType() == SyntaxType.Token &amp;&amp;</span><br><span class="line">        childs.get(<span class="number">2</span>).getType() == SyntaxType.PowExp) &#123;</span><br><span class="line">        <span class="type">IrValue</span> <span class="variable">baseVal</span> <span class="operator">=</span> calcNode(childs.get(<span class="number">0</span>));</span><br><span class="line">        <span class="type">IrValue</span> <span class="variable">expVal</span> <span class="operator">=</span> calcNode(childs.get(<span class="number">2</span>));</span><br><span class="line">        <span class="comment">// 如果指数是常量，直接展开成连乘</span></span><br><span class="line">        <span class="keyword">if</span> (expVal <span class="keyword">instanceof</span> IrConstInt) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> ((IrConstInt) expVal).getValue();</span><br><span class="line">            <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">IrConstInt</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">IrValue</span> <span class="variable">res</span> <span class="operator">=</span> baseVal;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="type">IrBinaryOp</span> <span class="variable">mul</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IrBinaryOp</span>(IrBinaryOp.Op.MUL, res, baseVal);</span><br><span class="line">                irBuilder.addInstruction(mul);</span><br><span class="line">                res = mul;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 如果指数是变量，需要在 llvm 中生成循环，可以按 while 循环的格式来生成</span></span><br><span class="line"><span class="comment">             * res = 1, i = 0;</span></span><br><span class="line"><span class="comment">             * while (i &lt; exp) &#123;</span></span><br><span class="line"><span class="comment">             *   res = res * base, i = i + 1;</span></span><br><span class="line"><span class="comment">             * &#125;</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        <span class="comment">// (1) res = 1</span></span><br><span class="line">        <span class="type">IrAlloca</span> <span class="variable">resPtr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IrAlloca</span>(IrBaseType.I32);</span><br><span class="line">        irBuilder.addInstruction(resPtr);</span><br><span class="line">        irBuilder.addInstruction(<span class="keyword">new</span> <span class="title class_">IrStore</span>(<span class="keyword">new</span> <span class="title class_">IrConstInt</span>(<span class="number">1</span>), resPtr));</span><br><span class="line">        <span class="comment">// (2) i = 0</span></span><br><span class="line">        <span class="type">IrAlloca</span> <span class="variable">iPtr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IrAlloca</span>(IrBaseType.I32);</span><br><span class="line">        irBuilder.addInstruction(iPtr);</span><br><span class="line">        irBuilder.addInstruction(<span class="keyword">new</span> <span class="title class_">IrStore</span>(<span class="keyword">new</span> <span class="title class_">IrConstInt</span>(<span class="number">0</span>), iPtr));</span><br><span class="line">        <span class="comment">// (3) exp</span></span><br><span class="line">        <span class="type">IrAlloca</span> <span class="variable">expPtr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IrAlloca</span>(IrBaseType.I32);</span><br><span class="line">        irBuilder.addInstruction(expPtr);</span><br><span class="line">        irBuilder.addInstruction(<span class="keyword">new</span> <span class="title class_">IrStore</span>(expVal, expPtr));</span><br><span class="line">        <span class="comment">// (4) 创建基本块</span></span><br><span class="line">        <span class="type">IrBasicBlock</span> <span class="variable">condBlock</span> <span class="operator">=</span> irBuilder.createBasicBlock(<span class="string">&quot;pow_cond&quot;</span>);</span><br><span class="line">        <span class="type">IrBasicBlock</span> <span class="variable">bodyBlock</span> <span class="operator">=</span> irBuilder.createBasicBlock(<span class="string">&quot;pow_body&quot;</span>);</span><br><span class="line">        <span class="type">IrBasicBlock</span> <span class="variable">endBlock</span> <span class="operator">=</span> irBuilder.createBasicBlock(<span class="string">&quot;pow_end&quot;</span>);</span><br><span class="line">        <span class="comment">// (5) 处理 cond 块</span></span><br><span class="line">        <span class="keyword">if</span> (!irBuilder.getCurBlock().hasTerminator()) &#123;</span><br><span class="line">            irBuilder.addInstruction(<span class="keyword">new</span> <span class="title class_">IrJump</span>(condBlock));</span><br><span class="line">        &#125;</span><br><span class="line">        irBuilder.getCurFunction().addBasicBlock(condBlock);</span><br><span class="line">        irBuilder.setCurBlock(condBlock);</span><br><span class="line">        <span class="comment">// (6) 生成比较指令</span></span><br><span class="line">        <span class="type">IrLoad</span> <span class="variable">iLoad</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IrLoad</span>(iPtr);</span><br><span class="line">        irBuilder.addInstruction(iLoad);</span><br><span class="line">        <span class="type">IrLoad</span> <span class="variable">expLoad</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IrLoad</span>(expPtr);</span><br><span class="line">        irBuilder.addInstruction(expLoad);</span><br><span class="line">        <span class="type">IrBinaryOp</span> <span class="variable">cmp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IrBinaryOp</span>(IrBinaryOp.Op.ICMP_SLT, iLoad, expLoad);</span><br><span class="line">        irBuilder.addInstruction(cmp);</span><br><span class="line">        <span class="keyword">if</span> (!irBuilder.getCurBlock().hasTerminator()) &#123;</span><br><span class="line">            irBuilder.addInstruction(<span class="keyword">new</span> <span class="title class_">IrBranch</span>(cmp, bodyBlock, endBlock));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// (7) 处理 body 块</span></span><br><span class="line">        irBuilder.getCurFunction().addBasicBlock(bodyBlock);</span><br><span class="line">        irBuilder.setCurBlock(bodyBlock);</span><br><span class="line">        <span class="comment">// res = res * base</span></span><br><span class="line">        <span class="type">IrLoad</span> <span class="variable">resLoad</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IrLoad</span>(resPtr);</span><br><span class="line">        irBuilder.addInstruction(resLoad);</span><br><span class="line">        <span class="type">IrBinaryOp</span> <span class="variable">resMul</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IrBinaryOp</span>(IrBinaryOp.Op.MUL, resLoad, baseVal);</span><br><span class="line">        irBuilder.addInstruction(resMul);</span><br><span class="line">        irBuilder.addInstruction(<span class="keyword">new</span> <span class="title class_">IrStore</span>(resMul, resPtr));</span><br><span class="line">        <span class="comment">// i = i + 1</span></span><br><span class="line">        <span class="type">IrLoad</span> <span class="variable">iLoad2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IrLoad</span>(iPtr);</span><br><span class="line">        irBuilder.addInstruction(iLoad2);</span><br><span class="line">        <span class="type">IrBinaryOp</span> <span class="variable">iAdd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IrBinaryOp</span>(IrBinaryOp.Op.ADD, iLoad2, <span class="keyword">new</span> <span class="title class_">IrConstInt</span>(<span class="number">1</span>));</span><br><span class="line">        irBuilder.addInstruction(iAdd);</span><br><span class="line">        irBuilder.addInstruction(<span class="keyword">new</span> <span class="title class_">IrStore</span>(iAdd, iPtr));</span><br><span class="line">        <span class="comment">// 回到 cond</span></span><br><span class="line">        <span class="keyword">if</span> (!irBuilder.getCurBlock().hasTerminator()) &#123;</span><br><span class="line">            irBuilder.addInstruction(<span class="keyword">new</span> <span class="title class_">IrJump</span>(condBlock));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// (8) 处理 end 块</span></span><br><span class="line">        irBuilder.getCurFunction().addBasicBlock(endBlock);</span><br><span class="line">        irBuilder.setCurBlock(endBlock);</span><br><span class="line">        <span class="type">IrLoad</span> <span class="variable">finalRes</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IrLoad</span>(resPtr);</span><br><span class="line">        irBuilder.addInstruction(finalRes);</span><br><span class="line">        <span class="keyword">return</span> finalRes;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">IrConstInt</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后面新建内建函数时，对应函数体的建立其实也需要我们自己生成<code>llvm</code>，感觉这部分还挺有可能考到的</p>
<h3 id="8-4-新增内建函数"><strong>8.4 新增内建函数</strong></h3>
<p><strong>题目要求</strong></p>
<p>文法说明：</p>
<p>现在需要你在 C 语言中支持内建函数<code>int abs(int x)</code>，函数的作用为返回<code>x</code>的绝对值</p>
<p>注意：<code>llvm</code>中没有现成的绝对值函数，因此需要手动完成函数体的实现</p>
<p><strong>具体实现</strong></p>
<p>本例考察在<code>llvm</code>中如何新建一个伪内建函数（仿照<code>getint</code>），即在生成<code>llvm</code>之前，就把对应的函数声明和函数体打印出来，使得语义分析阶段可以把这些函数当成库函数 / 全局函数调用</p>
<p>首先是语义分析阶段，在<code>registerBuiltins</code>中新建对应的内建函数记录：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">registerBuiltinFunction(<span class="string">&quot;abs&quot;</span>, BasicType.INT, List.of(ValueSymbolInfo.paramInt())); <span class="comment">// abs 函数</span></span><br></pre></td></tr></table></figure>
<p>这里需要<code>ValueSymbolInfo</code>中支持参数构建方法<code>paramInt()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ValueSymbolInfo <span class="title function_">paramInt</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ValueSymbolInfo</span>(BasicType.INT, Collections.emptyList(), <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>剩下的修改都是在<code>llvm</code>代码生成阶段完成，首先是在注册内建函数<code>initBuiltin</code>方法中，添加对应内建函数的注册：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (1) abs</span></span><br><span class="line"><span class="type">IrFunc</span> <span class="variable">abs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IrFunc</span>(<span class="string">&quot;@abs&quot;</span>, IrBaseType.I32, <span class="literal">false</span>); <span class="comment">// false 表示不仅是函数声明，还要生成函数体</span></span><br><span class="line">abs.addParam(<span class="keyword">new</span> <span class="title class_">IrValue</span>(IrBaseType.I32, <span class="string">&quot;%x&quot;</span>));</span><br><span class="line">builtinFunc.put(<span class="string">&quot;abs&quot;</span>, abs);</span><br><span class="line">irBuilder.getIrModule().addFunction(abs); <span class="comment">// 只有加入 IrModule 中的函数才会输出函数体</span></span><br></pre></td></tr></table></figure>
<p>接着在全局<code>Generate</code>方法中加入一个分发方法<code>emitBuiltinBodies</code>，用于每个函数体的实现，最后我们考虑<code>abs</code>函数的实现逻辑，其在语义上等价于一个分支语句+控制流合并的实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x &gt; <span class="number">0</span>:</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">else</span>:	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>-x;</span><br></pre></td></tr></table></figure>
<p>因此我们可以通过构造基本块分支，结合<code>IrPhi</code>进行控制流合并，完成<code>abs</code>函数体的实现，具体代码如下，也是仅供参考，后面有关<code>max, min</code>内建函数的实现也可以参考这个实现逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">emitAbsBody</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">IrFunc</span> <span class="variable">f</span> <span class="operator">=</span> builtinFunc.get(<span class="string">&quot;abs&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (f.getBasicBlocks() != <span class="literal">null</span> &amp;&amp; !f.getBasicBlocks().isEmpty()) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// (1) 保存当前状态，切换函数体</span></span><br><span class="line">    <span class="type">IrFunc</span> <span class="variable">saveFunc</span> <span class="operator">=</span> irBuilder.getCurFunction();</span><br><span class="line">    <span class="type">IrBasicBlock</span> <span class="variable">saveBlock</span> <span class="operator">=</span> irBuilder.getCurBlock();</span><br><span class="line">    irBuilder.setCurFunction(f);</span><br><span class="line">    <span class="comment">// (2) 建立基本块</span></span><br><span class="line">    <span class="type">IrBasicBlock</span> <span class="variable">entryBlock</span> <span class="operator">=</span> irBuilder.createBasicBlock(<span class="string">&quot;abs_entry&quot;</span>);</span><br><span class="line">    <span class="type">IrBasicBlock</span> <span class="variable">negBlock</span> <span class="operator">=</span> irBuilder.createBasicBlock(<span class="string">&quot;abs_neg&quot;</span>);</span><br><span class="line">    <span class="type">IrBasicBlock</span> <span class="variable">posBlock</span> <span class="operator">=</span> irBuilder.createBasicBlock(<span class="string">&quot;abs_pos&quot;</span>);</span><br><span class="line">    <span class="type">IrBasicBlock</span> <span class="variable">endBlock</span> <span class="operator">=</span> irBuilder.createBasicBlock(<span class="string">&quot;abs_end&quot;</span>);</span><br><span class="line">    f.addBasicBlock(entryBlock);</span><br><span class="line">    f.addBasicBlock(negBlock);</span><br><span class="line">    f.addBasicBlock(posBlock);</span><br><span class="line">    f.addBasicBlock(endBlock);</span><br><span class="line">    <span class="comment">// (3) 处理入口块</span></span><br><span class="line">    irBuilder.setCurBlock(entryBlock);</span><br><span class="line">    <span class="type">IrValue</span> <span class="variable">x</span> <span class="operator">=</span> f.getParams().get(<span class="number">0</span>);</span><br><span class="line">    <span class="type">IrBinaryOp</span> <span class="variable">isNeg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IrBinaryOp</span>(IrBinaryOp.Op.ICMP_SLT, x, <span class="keyword">new</span> <span class="title class_">IrConstInt</span>(<span class="number">0</span>));</span><br><span class="line">    irBuilder.addInstruction(isNeg);</span><br><span class="line">    irBuilder.addInstruction(<span class="keyword">new</span> <span class="title class_">IrBranch</span>(isNeg, negBlock, posBlock));</span><br><span class="line">    <span class="comment">// (4) 处理 x&lt;0 的 negBlock</span></span><br><span class="line">    irBuilder.setCurBlock(negBlock);</span><br><span class="line">    <span class="type">IrBinaryOp</span> <span class="variable">negVal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IrBinaryOp</span>(IrBinaryOp.Op.SUB, <span class="keyword">new</span> <span class="title class_">IrConstInt</span>(<span class="number">0</span>), x);</span><br><span class="line">    irBuilder.addInstruction(negVal);</span><br><span class="line">    irBuilder.addInstruction(<span class="keyword">new</span> <span class="title class_">IrJump</span>(endBlock));</span><br><span class="line">    <span class="comment">// (5) 处理 x&gt;=0 的 posBlock</span></span><br><span class="line">    irBuilder.setCurBlock(posBlock);</span><br><span class="line">    irBuilder.addInstruction(<span class="keyword">new</span> <span class="title class_">IrJump</span>(endBlock));</span><br><span class="line">    <span class="comment">// (6) 处理结尾块</span></span><br><span class="line">    irBuilder.setCurBlock(endBlock);</span><br><span class="line">    <span class="type">IrPhi</span> <span class="variable">phi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IrPhi</span>(IrBaseType.I32);</span><br><span class="line">    phi.addIncoming(negVal, negBlock);</span><br><span class="line">    phi.addIncoming(x, posBlock);</span><br><span class="line">    irBuilder.addInstruction(phi);</span><br><span class="line">    irBuilder.addInstruction(<span class="keyword">new</span> <span class="title class_">IrReturn</span>(phi));</span><br><span class="line">    <span class="comment">// (7) 恢复状态</span></span><br><span class="line">    irBuilder.setCurFunction(saveFunc);</span><br><span class="line">    irBuilder.setCurBlock(saveBlock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要注意，和解析基本块需要<code>setCurBlock</code>同理，解析函数体需要<code>setCurFunction</code>，同时解析完成后要做函数体恢复，也就是代码中（1）（7）的状态保存和状态恢复</p>
<h3 id="8-5-新建内建函数"><strong>8.5 新建内建函数</strong></h3>
<p><strong>题目要求</strong></p>
<p>文法说明：</p>
<p>现在需要你仿照上面<code>int abs(int x)</code>的实现，继续新增新的内建函数如下</p>
<ul>
<li><code>int max(int a, int b)</code>：最大值函数</li>
<li><code>int min(int a, int b)</code>：最小值函数</li>
<li><code>int swap(int *a, int *b)</code>：交换函数</li>
<li><code>int cluster(int x, int l, int r)</code>：截断函数（如果 x &lt; l 则返回 l，如果 x &gt; r 则返回 r，其余情况返回 x）</li>
</ul>
<p>保证不会出现用户自定义函数和内建函数重名的情况</p>
<p><strong>具体实现</strong></p>
<p>仿照<code>abs</code>的实现思路即可</p>
<h3 id="8-6-后缀-困难"><strong>8.6 后缀++（困难）</strong></h3>
<p><strong>题目要求</strong></p>
<p>文法说明：修改<code>UnaryExp</code>的文法，要求支持后缀<code>++</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UnaryExp    → PostfixExp | UnaryOp UnaryExp</span><br><span class="line">UnaryOp     → <span class="string">&#x27;+&#x27;</span> | <span class="string">&#x27;-&#x27;</span> | <span class="string">&#x27;!&#x27;</span></span><br><span class="line">PostfixExp  → PrimaryExp | Ident <span class="string">&#x27;(&#x27;</span> [FuncRParams] <span class="string">&#x27;)&#x27;</span> | LVal <span class="string">&#x27;++&#x27;</span>                     </span><br></pre></td></tr></table></figure>
<p>要求：<code>x++</code>的操作数必须是<code>LVal</code>，在语义上<code>x++</code>的效果为返回<code>x</code>的旧值，同时把<code>x+1</code>的结果写回<code>x</code>中</p>
<p><strong>实现思路</strong></p>
<p>不同于前缀<code>++</code>的实现，前缀<code>++</code>只相当于<code>UnaryOp</code>中新增一个单目运算符，甚至不需要对控制流进行修改，只需要最后下沉到<code>llvm</code>生成时，做<code>oldValue + 1</code>的解析即可（至于是否要生成一条<code>IrStore</code>指令修改原变量，则需要根据文法要求具体实现），后缀<code>++</code>的实现需要对控制流进行修改</p>
<p>首先是新增语法单元的处理，在<code>UnaryExp</code>和<code>PrimaryExp</code>之间添加了一级<code>PostfixExp</code>，这里做语法分析的一个难点在于，由于<code>PostfixExp</code>和<code>PrimaryExp</code>都可能扩展到<code>LVal</code>，需要实现二者的判断逻辑，这里我选择先解析<code>visitCallFunction</code>的分支，因为它是好判断的，只要是读到<code>Ident '('</code>就可以确定一定是<code>functionCall</code></p>
<p>剩下的情况中，先<strong>无脑</strong>当做<code>PrimaryExp</code>解析，接着判断下一个<code>Token</code>是否为<code>DoublePlus(&quot;++&quot;)</code>，如果不是，则说明就是<code>PrimaryExp</code>，反之，则说明是<code>LVal++</code>，此时可以从<code>PrimaryExp</code>中，通过取子节点的方式，取<code>getIndexChild(0)</code>找到这个<code>LVal</code>节点，这么做是巧妙的利用了<code>PrimaryExp</code>中支持包含<code>LVal</code>的特性，因此如果是<code>LVal++</code>的情况，我们一上来先解析<code>PrimaryExp</code>也不会出错，只是会解析出<code>PrimaryExp-&gt;LVal</code>多嵌套一层，通过取子节点取出即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> AstNode <span class="title function_">visitPostfixExp</span><span class="params">(ParseContext ctx)</span> &#123;</span><br><span class="line">    List&lt;AstNode&gt; childs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">lineNumber</span> <span class="operator">=</span> ctx.getCurrentLineNumber();</span><br><span class="line">    <span class="keyword">if</span> (ctx.checkType(<span class="number">0</span>, TokenType.IDENFR) &amp;&amp; ctx.checkType(<span class="number">1</span>, TokenType.LPARENT)) &#123;</span><br><span class="line">        <span class="comment">// 函数调用</span></span><br><span class="line">        expectToken(ctx, childs, TokenType.IDENFR);</span><br><span class="line">        expectToken(ctx, childs, TokenType.LPARENT);</span><br><span class="line">        <span class="keyword">if</span> (!ctx.checkType(<span class="number">0</span>, TokenType.RPARENT)) &#123;</span><br><span class="line">            <span class="comment">// 有参数，这里需要回溯</span></span><br><span class="line">            ctx.addStack();</span><br><span class="line">            <span class="type">AstNode</span> <span class="variable">fpNode</span> <span class="operator">=</span> visitFuncRParams(ctx);</span><br><span class="line">            <span class="keyword">if</span> (fpNode.isErrorNode()) &#123;</span><br><span class="line">                ctx.popAndMove();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ctx.popStack();</span><br><span class="line">                childs.add(fpNode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        expectToken(ctx, childs, TokenType.RPARENT);</span><br><span class="line">        <span class="keyword">return</span> AstFactory.creatAstNode(SyntaxType.PostfixExp, childs, lineNumber);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">AstNode</span> <span class="variable">primaryExp</span> <span class="operator">=</span> visitPrimaryExp(ctx);</span><br><span class="line">    <span class="keyword">if</span> (primaryExp.getChilds().size() == <span class="number">1</span> &amp;&amp; primaryExp.getIndexChild(<span class="number">0</span>).getType() == SyntaxType.LVal) &#123;</span><br><span class="line">        <span class="comment">// 有可能是 PostfixExp 中真正的 LVal++</span></span><br><span class="line">        <span class="keyword">if</span> (ctx.checkType(TokenType.DoublePlus)) &#123;</span><br><span class="line">            <span class="type">AstNode</span> <span class="variable">lVal</span> <span class="operator">=</span> primaryExp.getIndexChild(<span class="number">0</span>);</span><br><span class="line">            childs.add(lVal);</span><br><span class="line">            expectToken(ctx, childs, TokenType.DoublePlus);</span><br><span class="line">            <span class="keyword">return</span> AstFactory.creatAstNode(SyntaxType.PostfixExp, childs, lineNumber);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    childs.add(primaryExp);</span><br><span class="line">    <span class="keyword">return</span> AstFactory.creatAstNode(SyntaxType.PostfixExp, childs, lineNumber);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实这里在区分<code>PrimaryExp</code>和<code>LVal++</code>时，也可以使用<strong>回溯</strong>的思想，即使用现有架构已经支持的<code>AddStack</code>和<code>popStack</code>来实现，我们可以考虑上来先<strong>无脑</strong>读取一个<code>LVal</code>节点，接着判断这个节点是否出错（因为如果不是<code>LVal</code>但走了<code>visitLVal</code>分支会造成<code>TokenStream</code>错位，一定会返回<code>error</code>），同时判断解析完<code>LVal</code>以后下一个字符是否为<code>DoublePlus</code>，如果这两个条件有一个不满足，就<code>popAndMove</code>，即弹栈并且恢复指针，走<code>visitPrimaryExp</code>去解析，反之则说明确实是<code>LVal++</code>，则保留已经解析好的<code>LVal</code>，接着去解析<code>++</code>即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">ctx.addStack();</span><br><span class="line"><span class="type">AstNode</span> <span class="variable">lVal</span> <span class="operator">=</span> visitLVal(ctx);</span><br><span class="line"><span class="keyword">if</span> (!lVal.isErrorNode() &amp;&amp; ctx.checkType(TokenType.DoublePlus)) &#123; <span class="comment">// 说明是 LVal++</span></span><br><span class="line">	ctx.popStack();</span><br><span class="line">    childs.add(lVal);</span><br><span class="line">    expectToken(ctx, childs, TokenType.DoublePlus);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ctx.popAndMove();</span><br><span class="line">    childs.add(visitPrimaryExp(ctx));</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>接着是语义分析阶段，这里限制<code>++</code>不能作用于常量，因此不需要考虑常量折叠（如果<code>const</code>遇到<code>++</code>反而应该返回<code>ExpInfo.error()</code>），只需要修改对应的表达式链即可</p>
<p>最后是<code>llvm</code>生成阶段，需要完成对<code>i++</code>语义的正确解析，即先返回<code>i</code>的旧值，接着把<code>i+1</code>，最后把自增的结果写回<code>i</code>对应的地址，对应的解析过程如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> IrValue <span class="title function_">calcPostfixExp</span><span class="params">(AstNode postfixExp)</span> &#123;</span><br><span class="line">    <span class="comment">/* 修改后的文法 :</span></span><br><span class="line"><span class="comment">         * UnaryExp   → PostfixExp | UnaryOp UnaryExp</span></span><br><span class="line"><span class="comment">         * PostfixExp → PrimaryExp | Ident &#x27;(&#x27; [FuncRParams] &#x27;)&#x27; | LVal &#x27;++&#x27;</span></span><br><span class="line"><span class="comment">         * PrimaryExp → &#x27;(&#x27; Exp &#x27;)&#x27; | LVal | Number</span></span><br><span class="line"><span class="comment">         * LVal       → Ident &#123;&#x27;[&#x27; Exp &#x27;]&#x27;&#125; */</span></span><br><span class="line">    <span class="keyword">if</span> (postfixExp == <span class="literal">null</span> || postfixExp.getChilds().isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">IrConstInt</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">AstNode</span> <span class="variable">firstChild</span> <span class="operator">=</span> postfixExp.getIndexChild(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (firstChild.getType() == SyntaxType.PrimaryExp) &#123;</span><br><span class="line">        <span class="comment">// PrimaryExp</span></span><br><span class="line">        <span class="keyword">return</span> calcNode(firstChild);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (postfixExp.getIndexChild(<span class="number">0</span>).getType() == SyntaxType.Token &amp;&amp;</span><br><span class="line">               postfixExp.getIndexChild(<span class="number">0</span>).getToken().getTokenType() == TokenType.IDENFR &amp;&amp;</span><br><span class="line">               postfixExp.getIndexChild(<span class="number">0</span>).getType() == SyntaxType.Token &amp;&amp;</span><br><span class="line">               postfixExp.getIndexChild(<span class="number">1</span>).getToken().getTokenType() == TokenType.LPARENT) &#123;</span><br><span class="line">        <span class="comment">// CallFunction</span></span><br><span class="line">        <span class="keyword">return</span> calcFunctionCall(postfixExp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (postfixExp.getIndexChild(<span class="number">0</span>).getType() == SyntaxType.LVal &amp;&amp; postfixExp.getIndexChild(<span class="number">1</span>).getToken().getTokenType() == TokenType.DoublePlus) &#123;</span><br><span class="line">        <span class="comment">// LVal++(新增文法实现)</span></span><br><span class="line">        <span class="type">IrValue</span> <span class="variable">lValPtr</span> <span class="operator">=</span> calcLValAsPointer(postfixExp.getIndexChild(<span class="number">0</span>));</span><br><span class="line">        <span class="type">IrLoad</span> <span class="variable">lVal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IrLoad</span>(lValPtr);</span><br><span class="line">        irBuilder.addInstruction(lVal);</span><br><span class="line">        <span class="type">IrBinaryOp</span> <span class="variable">add</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IrBinaryOp</span>(IrBinaryOp.Op.ADD, lVal, <span class="keyword">new</span> <span class="title class_">IrConstInt</span>(<span class="number">1</span>));</span><br><span class="line">        irBuilder.addInstruction(add);</span><br><span class="line">        irBuilder.addInstruction(<span class="keyword">new</span> <span class="title class_">IrStore</span>(add, lValPtr));</span><br><span class="line">        <span class="keyword">return</span> lVal;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">IrConstInt</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-7-shiftexp"><strong>8.7 ShiftExp</strong></h3>
<p><strong>题目要求</strong></p>
<p>文法说明：在<code>RelExp</code>和<code>AddExp</code>之间新增<code>ShiftExp</code>，支持逻辑左移和右移运算</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">EqExp    → RelExp  &#123; (<span class="string">&#x27;==&#x27;</span> | <span class="string">&#x27;!=&#x27;</span>) RelExp &#125;</span><br><span class="line">RelExp   → ShiftExp &#123; (<span class="string">&#x27;&lt;&#x27;</span> | <span class="string">&#x27;&gt;&#x27;</span> | <span class="string">&#x27;&lt;=&#x27;</span> | <span class="string">&#x27;&gt;=&#x27;</span>) ShiftExp &#125;</span><br><span class="line">ShiftExp → AddExp &#123; (<span class="string">&#x27;&lt;&lt;&#x27;</span> | <span class="string">&#x27;&gt;&gt;&#x27;</span>) AddExp &#125;</span><br><span class="line">AddExp   → MulExp &#123; (<span class="string">&#x27;+&#x27;</span> | <span class="string">&#x27;-&#x27;</span>) MulExp &#125;</span><br><span class="line">...</span><br><span class="line">Exp → ShiftExp → AddExp    </span><br></pre></td></tr></table></figure>
<p>说明：不需要考虑溢出，位移运算是左结合，默认右移运算按逻辑右移实现，注意这里把<code>Exp</code>表达式链的解析也做了修改</p>
<p>提示：<code>llvm</code>中有对应的二元运算如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a &lt;&lt; b → shl i32 a, b</span><br><span class="line">a &gt;&gt; b → ashr i32 a, b</span><br></pre></td></tr></table></figure>
<p>因此你可能需要新增两条<code>llvm</code>指令，同时添加<code>mips</code>生成中对这两条指令翻译的支持，而当前<code>mips</code>中只支持<code>shamt</code>是立即数的位移运算，因此还需要新建<code>mips</code>指令类，支持三操作数的位移运算</p>
<p><strong>具体实现</strong></p>
<p>到中间代码生成为止，前面的扩展都只是在表达式链中新增一个普通的做结合运算级，比较常规，在<code>llvm</code>生成中，需要现在<code>BinaryOp</code>中新增两个二元运算类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SHL(<span class="string">&quot;shl&quot;</span>)</span><br><span class="line">ASHR(<span class="string">&quot;ashr&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>在对应的解析函数<code>calcShiftExp</code>中，只需要调用生成对应的二元运算指令即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (op.equals(<span class="string">&quot;&lt;&lt;&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// 左移</span></span><br><span class="line">    <span class="type">IrBinaryOp</span> <span class="variable">shl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IrBinaryOp</span>(IrBinaryOp.Op.SHL, left, right);</span><br><span class="line">    irBuilder.addInstruction(shl);</span><br><span class="line">    <span class="keyword">return</span> shl;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (op.equals(<span class="string">&quot;&gt;&gt;&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// 右移</span></span><br><span class="line">    <span class="type">IrBinaryOp</span> <span class="variable">shr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IrBinaryOp</span>(IrBinaryOp.Op.ASHR, left, right);</span><br><span class="line">    irBuilder.addInstruction(shr);</span><br><span class="line">    <span class="keyword">return</span> shr;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">IrConstInt</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重点是<code>mips</code>阶段的生成，首先生成新的指令类<code>ShiftV</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShiftV</span> <span class="keyword">extends</span> <span class="title class_">Instruction</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ShiftVType</span> &#123;</span><br><span class="line">        SLLV(<span class="string">&quot;sllv&quot;</span>),   <span class="comment">// sllv rd, rt, rs</span></span><br><span class="line">        SRLV(<span class="string">&quot;srlv&quot;</span>),   <span class="comment">// srlv rd, rt, rs</span></span><br><span class="line">        SRAV(<span class="string">&quot;srav&quot;</span>);   <span class="comment">// srav rd, rt, rs</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">        ShiftVType(String name) &#123; <span class="built_in">this</span>.name = name; &#125;</span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ShiftVType type;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Register rd;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Register rt; <span class="comment">// value</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Register rs; <span class="comment">// shift amount</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ShiftV</span><span class="params">(ShiftVType type, Register rd, Register rt, Register rs)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">        <span class="built_in">this</span>.rd = rd;</span><br><span class="line">        <span class="built_in">this</span>.rt = rt;</span><br><span class="line">        <span class="built_in">this</span>.rs = rs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> type.getName() + <span class="string">&quot; &quot;</span> + rd.getName() + <span class="string">&quot;, &quot;</span> + rt.getName() + <span class="string">&quot;, &quot;</span> + rs.getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后在解析<code>BinaryOp</code>的方法中，新增两个分支，分别解析左移和右移运算符即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (op.equals(IrBinaryOp.Op.SHL) || op.equals(IrBinaryOp.Op.ASHR) <span class="comment">/*|| op.equals(IrBinaryOp.Op.LSHR)*/</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 被移位的值</span></span><br><span class="line">    <span class="type">Register</span> <span class="variable">x</span> <span class="operator">=</span> ensureValueInReg(lhs, Register.T1, block);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -------- 1) 常量移位量：用 sll/sra/srl (Shift immediate) --------</span></span><br><span class="line">    <span class="keyword">if</span> (isConstInt(rhs)) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sh</span> <span class="operator">=</span> getConstInt(rhs) &amp; <span class="number">31</span>; <span class="comment">// MIPS 只看低 5 位；也能避免 shamt 越界</span></span><br><span class="line">        Shift.ShiftType st;</span><br><span class="line">        <span class="keyword">if</span> (op.equals(IrBinaryOp.Op.SHL)) &#123;</span><br><span class="line">            st = Shift.ShiftType.SLL;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op.equals(IrBinaryOp.Op.ASHR)) &#123;</span><br><span class="line">            st = Shift.ShiftType.SRA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// st = Shift.ShiftType.SRL; // 如果你支持 LSHR 就打开</span></span><br><span class="line">            st = Shift.ShiftType.SRA;   <span class="comment">// 没有 LSHR 时，先别走到这里</span></span><br><span class="line">        &#125;</span><br><span class="line">        block.addInstruction(<span class="keyword">new</span> <span class="title class_">Shift</span>(st, dst, x, sh));</span><br><span class="line">        storeValue(binaryOp, dst, block);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -------- 2) 变量移位量：必须用 sllv/srav/srlv --------</span></span><br><span class="line">    <span class="comment">// 注意：MIPS 的 *v 指令自动使用 shiftReg 的低 5 位，不需要你手动 &amp;31</span></span><br><span class="line">    <span class="type">Register</span> <span class="variable">shReg</span> <span class="operator">=</span> ensureValueInReg(rhs, Register.T2, block);</span><br><span class="line"></span><br><span class="line">    ShiftV.ShiftVType vt;</span><br><span class="line">    <span class="keyword">if</span> (op.equals(IrBinaryOp.Op.SHL)) &#123;</span><br><span class="line">        vt = ShiftV.ShiftVType.SLLV;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op.equals(IrBinaryOp.Op.ASHR)) &#123;</span><br><span class="line">        vt = ShiftV.ShiftVType.SRAV;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// vt = ShiftV.ShiftVType.SRLV; // 如果你支持 LSHR 就打开</span></span><br><span class="line">        vt = ShiftV.ShiftVType.SRAV;  <span class="comment">// 没有 LSHR 时，先别走到这里</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 约定：ShiftV(type, rd, rt, rs)  ===  type rd, rt, rs</span></span><br><span class="line">    <span class="comment">// sllv rd, rt, rs  ; rd = rt &lt;&lt; (rs &amp; 31)</span></span><br><span class="line">    block.addInstruction(<span class="keyword">new</span> <span class="title class_">ShiftV</span>(vt, dst, x, shReg));</span><br><span class="line">    storeValue(binaryOp, dst, block);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>考试应该不会考到<code>mips</code>层面的修改，不然需要添加的代码量未免有些太大了（）</p>
<h3 id="8-8-ternarystmt"><strong>8.8 TernaryStmt</strong></h3>
<p><strong>题目描述</strong></p>
<p>文法要求：在语句流中增加三目运算符</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stmt → Cond <span class="string">&#x27;?&#x27;</span> Exp <span class="string">&#x27;:&#x27;</span> Exp <span class="string">&#x27;;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>说明：这是 2024 年的一道题目，根据往届学长的描述，貌似出题人没有考虑三目运算有返回值的情况，如果当成语句流解析，返回值应该是要被丢弃了</p>
<p><strong>实现思路</strong></p>
<p>本例的重点在于语法分析时，如何在向下分发<code>Stmt</code>节点的时候，识别当前语句是三目运算语句，因为此时该文法的开头是<code>Cond</code>，很难确定它的<code>firstToken</code>到底是什么，这里考虑用回溯的思想求解，即上来先无脑解析一个<code>Cond</code>，如果解析不出错，且解析完的下一个符号确实为<code>?</code>，就走三目运算流，如果出错，则进行回溯，正常解析已有文法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ctx.addStack();</span><br><span class="line"><span class="type">AstNode</span> <span class="variable">cond</span> <span class="operator">=</span> visitCond(ctx);</span><br><span class="line"><span class="keyword">if</span> (!cond.isErrorNode() &amp;&amp; ctx.checkType(TokenType.QUE)) &#123;</span><br><span class="line">	ctx.popAndMove(); <span class="comment">// 这里之所以把 cond 退掉，是因为 visitTernaryStmt 还会把 cond 解析一遍，因此这里需要回退</span></span><br><span class="line">	<span class="keyword">return</span> visitTernaryStmt(ctx);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	ctx.popAndMove();</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>剩下一个可能存在的难点在于生成<code>llvm</code>的时候，如果不考虑返回值，则三目运算符完全可以当成<code>if-else</code>分支来实现，而如果考虑返回值，则需要在<code>endBlock</code>中插入一条<code>IrPhi</code>指令，用于合并两个<code>Exp</code>的结果，并最后把<code>IrPhi</code>作为最后的返回值返回</p>
<h3 id="8-9-repeat-cond"><strong>8.9 repeat-cond</strong></h3>
<p><strong>题目要求</strong></p>
<p>新增控制流文法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stmt → <span class="string">&#x27;repeat&#x27;</span> <span class="string">&#x27;&#123;&#x27;</span> Stmt <span class="string">&#x27;&#125;&#x27;</span> <span class="string">&#x27;until&#x27;</span> <span class="string">&#x27;(&#x27;</span> Cond <span class="string">&#x27;)&#x27;</span> <span class="string">&#x27;;&#x27;</span></span><br><span class="line">Stmt → <span class="string">&#x27;do&#x27;</span> <span class="string">&#x27;&#123;&#x27;</span> Stmt <span class="string">&#x27;&#125;&#x27;</span> <span class="string">&#x27;while&#x27;</span> <span class="string">&#x27;(&#x27;</span> Cond <span class="string">&#x27;)&#x27;</span> <span class="string">&#x27;;&#x27;</span>    </span><br></pre></td></tr></table></figure>
<p>这类控制流属于比较好加的指令，和我们已经实现的<code>while</code>循环相比，只需要把<code>condBlock</code>放在<code>bodyBlock</code>后面实现即可，以第一条<code>repeat</code>指令为例，其中<code>repeat</code>在期中模拟的时候前面也加过了，这里展示中间代码生成时的参考如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">calcRepeatUntilStmt</span><span class="params">(AstNode stmt)</span> &#123;</span><br><span class="line">    <span class="comment">/* Stmt → &#x27;repeat&#x27; &#x27;&#123;&#x27; Stmt &#x27;&#125;&#x27; &#x27;until&#x27; &#x27;(&#x27; Cond &#x27;)&#x27; &#x27;;&#x27; */</span></span><br><span class="line">    <span class="type">AstNode</span> <span class="variable">loopStmt</span> <span class="operator">=</span> stmt.getIndexChild(<span class="number">1</span>);</span><br><span class="line">    <span class="type">AstNode</span> <span class="variable">cond</span> <span class="operator">=</span> stmt.getIndexChild(<span class="number">4</span>);</span><br><span class="line">    <span class="comment">// 建立基本块</span></span><br><span class="line">    <span class="type">IrBasicBlock</span> <span class="variable">bodyBlock</span> <span class="operator">=</span> irBuilder.createBasicBlock(<span class="string">&quot;repeat_until_body&quot;</span>);</span><br><span class="line">    <span class="type">IrBasicBlock</span> <span class="variable">condBlock</span> <span class="operator">=</span> irBuilder.createBasicBlock(<span class="string">&quot;cond_body&quot;</span>);</span><br><span class="line">    <span class="type">IrBasicBlock</span> <span class="variable">endBlock</span> <span class="operator">=</span> irBuilder.createBasicBlock(<span class="string">&quot;end_body&quot;</span>);</span><br><span class="line">    <span class="comment">// 先进入 bodyBlock</span></span><br><span class="line">    <span class="keyword">if</span> (!irBuilder.getCurBlock().hasTerminator()) &#123;</span><br><span class="line">        <span class="type">IrJump</span> <span class="variable">jump2body</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IrJump</span>(bodyBlock);</span><br><span class="line">        irBuilder.addInstruction(jump2body);</span><br><span class="line">    &#125;</span><br><span class="line">    irBuilder.getCurFunction().addBasicBlock(bodyBlock);</span><br><span class="line">    irBuilder.setCurBlock(bodyBlock);</span><br><span class="line">    <span class="keyword">if</span> (loopStmt != <span class="literal">null</span>) &#123;</span><br><span class="line">        calcStmt(loopStmt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!irBuilder.getCurBlock().hasTerminator()) &#123;</span><br><span class="line">        <span class="type">IrJump</span> <span class="variable">body2cond</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IrJump</span>(condBlock);</span><br><span class="line">        irBuilder.addInstruction(body2cond);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 后进入 condBlock</span></span><br><span class="line">    irBuilder.getCurFunction().addBasicBlock(condBlock);</span><br><span class="line">    irBuilder.setCurBlock(condBlock);</span><br><span class="line">    <span class="type">IrValue</span> <span class="variable">condValue</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (cond != <span class="literal">null</span>) &#123;</span><br><span class="line">        condValue = calcCond(cond);</span><br><span class="line">    &#125;</span><br><span class="line">    condValue = Trunc(condValue);</span><br><span class="line">    <span class="keyword">if</span> (!irBuilder.getCurBlock().hasTerminator()) &#123;</span><br><span class="line">        <span class="type">IrBranch</span> <span class="variable">branch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IrBranch</span>(condValue, endBlock, bodyBlock);</span><br><span class="line">        irBuilder.addInstruction(branch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 进入 endBlock</span></span><br><span class="line">    irBuilder.getCurFunction().addBasicBlock(endBlock);</span><br><span class="line">    irBuilder.setCurBlock(endBlock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-a-ternaryexp"><strong>8.A TernaryExp</strong></h3>
<p><strong>题目要求</strong></p>
<p>文法说明：新增三目运算符，但扩展文法要求如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CondExp -&gt; LOrExp [<span class="string">&#x27;?&#x27;</span> Exp <span class="string">&#x27;:&#x27;</span> CondExp]</span><br></pre></td></tr></table></figure>
<h3 id="8-b-switch-case"><strong>8.B switch-case</strong></h3>
<p><strong>题目要求</strong></p>
<p>文法说明：新增<code>sitch-case</code>语句</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stmt -&gt; <span class="string">&#x27;switch&#x27;</span> <span class="string">&#x27;(&#x27;</span> Exp <span class="string">&#x27;)&#x27;</span> <span class="string">&#x27;&#123;&#x27;</span> &#123;CaseStmt &#125; [defaultStmt] <span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line">CaseStmt -&gt; <span class="string">&#x27;case&#x27;</span> ConstExp <span class="string">&#x27;:&#x27;</span> Stmt</span><br><span class="line">defaultStmt -&gt; <span class="string">&#x27;default&#x27;</span> <span class="string">&#x27;:&#x27;</span> Stmt</span><br></pre></td></tr></table></figure>
<h3 id="8-c-match-case"><strong>8.C match-case</strong></h3>
<p><strong>题目要求</strong></p>
<p>文法说明：新增<code>match-case</code>语句</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PrimaryExp</span><br><span class="line">  -&gt; <span class="string">&#x27;(&#x27;</span> Exp <span class="string">&#x27;)&#x27;</span></span><br><span class="line">  | LVal</span><br><span class="line">  | Number</span><br><span class="line">  | MatchExp</span><br><span class="line">  </span><br><span class="line">MatchExp</span><br><span class="line">  -&gt; <span class="string">&#x27;match&#x27;</span> <span class="string">&#x27;(&#x27;</span> Exp <span class="string">&#x27;)&#x27;</span> <span class="string">&#x27;&#123;&#x27;</span> MatchArm &#123; MatchArm &#125; <span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line">MatchArm</span><br><span class="line">  -&gt; <span class="string">&#x27;case&#x27;</span> ConstExp <span class="string">&#x27;=&gt;&#x27;</span> Exp <span class="string">&#x27;;&#x27;</span></span><br><span class="line">  | <span class="string">&#x27;default&#x27;</span> <span class="string">&#x27;=&gt;&#x27;</span> Exp <span class="string">&#x27;;&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="8-d-后缀"><strong>8.D 后缀++</strong></h3>
<p><strong>题目要求</strong></p>
<p>文法说明：新增后缀<code>++</code>语句</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stmt → Ident <span class="string">&#x27;++&#x27;</span> | Ident <span class="string">&#x27;--&#x27;</span> <span class="string">&#x27;;&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="8-e-forstmt-btype-vardef"><strong>8.E ForStmt → BType VarDef</strong></h3>
<p><strong>题目要求</strong></p>
<p>文法说明：对<code>ForStmt</code>进行扩展</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ForStmt → LVal <span class="string">&#x27;=&#x27;</span> Exp | BType VarDef</span><br></pre></td></tr></table></figure>
<p>前面提到的抽取出<code>VarDecl</code>可以看成是一个方法，还有一个比较常规的方法就是给<code>for</code>语句也嵌套一层作用域，就按照新增文法做常规解析，需要在符号表解析<code>forLoopStmt</code>的时候，进行<code>pushScope</code>和<code>popScope</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processForLoopStmt</span><span class="params">(AstNode stmt)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">hasDecl</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (AstNode child : stmt.getChilds()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (child.getType() == SyntaxType.ForStmt) &#123;</span><br><span class="line">            <span class="keyword">if</span> (child.getIndexChild(<span class="number">0</span>).getType() == SyntaxType.BType) &#123;</span><br><span class="line">                hasDecl = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果是新增文法，则需要为当前的变量声明新建作用域</span></span><br><span class="line">    <span class="keyword">if</span> (hasDecl) &#123;</span><br><span class="line">        symbolTable.pushScope(<span class="string">&quot;forDecl&quot;</span>);</span><br><span class="line">        <span class="comment">// 新增：关联AST节点到作用域</span></span><br><span class="line">        <span class="type">Scope</span> <span class="variable">currentScope</span> <span class="operator">=</span> symbolTable.getCur_scope();</span><br><span class="line">        currentScope.setAssociatedNode(stmt);</span><br><span class="line">    &#125;</span><br><span class="line">    loopStack.push(loopStack.size());</span><br><span class="line">    <span class="keyword">for</span> (AstNode component : stmt.getChilds()) &#123;</span><br><span class="line">        <span class="type">SyntaxType</span> <span class="variable">childType</span> <span class="operator">=</span> component.getType();</span><br><span class="line">        <span class="keyword">if</span> (childType == SyntaxType.ForStmt) &#123;</span><br><span class="line">            processForStmt(component);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childType == SyntaxType.CondExp) &#123;</span><br><span class="line">            expEvaluater.evalCond(component);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childType == SyntaxType.Stmt) &#123;</span><br><span class="line">            processStmt(component);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    loopStack.pop();</span><br><span class="line">    <span class="comment">// 用完作用域记得弹出</span></span><br><span class="line">    <span class="keyword">if</span> (hasDecl) &#123;</span><br><span class="line">        symbolTable.popScope();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实这里我们创建的作用域也仅包含当前的整个 for 循环，不会再包含其他多余的语句，所以写的简单一点的话，我们可以不做是否有<code>VarDecl</code>的判断，只要看到<code>for</code>我们就为其新建一个作用域，这样也是可以的，对应在<code>llvm</code>生成时，每次进入循环解析时，也需要根据<code>forStmt</code>去做作用域匹配</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否要切换作用域</span></span><br><span class="line"><span class="type">Scope</span> <span class="variable">savedScope</span> <span class="operator">=</span> curScope;</span><br><span class="line"><span class="keyword">if</span> ((initStmt != <span class="literal">null</span> &amp;&amp; initStmt.getIndexChild(<span class="number">0</span>).getType() == SyntaxType.BType) || (stepStmt != <span class="literal">null</span> &amp;&amp; stepStmt.getIndexChild(<span class="number">0</span>).getType() == SyntaxType.BType)) &#123;</span><br><span class="line">    curScope = matchScopeByNode(curScope, stmt);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">curScope = savedScope;</span><br></pre></td></tr></table></figure>
<h3 id="8-f-a-b-b"><strong>8.F (a+b)^b</strong></h3>
<p><strong>题目要求</strong></p>
<p>文法说明：对<code>MulExp</code>进行扩展</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MulExp → UnaryExp | <span class="built_in">MuleExp</span> (<span class="string">&#x27;*&#x27;</span> | <span class="string">&#x27;/&#x27;</span> | <span class="string">&#x27;%&#x27;</span> | <span class="string">&#x27;**&#x27;</span>) UnaryExp</span><br></pre></td></tr></table></figure>
<p>其中<code>a**b</code>的语义为<code>(a+b)^b</code>，保证<code>b</code>是无符号整数，本例和乘方运算差不多，需要在<code>llvm</code>中手动生成一个<code>for</code>循环计算乘方</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> IrValue <span class="title function_">calcDoubleMulExp</span><span class="params">(IrValue a, IrValue b)</span> &#123;</span><br><span class="line">    <span class="comment">// 计算 (a+b) 的结果</span></span><br><span class="line">    <span class="type">IrBinaryOp</span> <span class="variable">add</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IrBinaryOp</span>(IrBinaryOp.Op.ADD, a, b);</span><br><span class="line">    irBuilder.addInstruction(add);</span><br><span class="line">    <span class="comment">// 创建基本块 + 加入基本块列表</span></span><br><span class="line">    <span class="type">IrBasicBlock</span> <span class="variable">condBlock</span> <span class="operator">=</span> irBuilder.createBasicBlock(<span class="string">&quot;pow_cond&quot;</span>);</span><br><span class="line">    <span class="type">IrBasicBlock</span> <span class="variable">bodyBlock</span> <span class="operator">=</span> irBuilder.createBasicBlock(<span class="string">&quot;pow_body&quot;</span>);</span><br><span class="line">    <span class="type">IrBasicBlock</span> <span class="variable">endBlock</span> <span class="operator">=</span> irBuilder.createBasicBlock(<span class="string">&quot;pow_end&quot;</span>);</span><br><span class="line">    irBuilder.getCurFunction().addBasicBlock(condBlock);</span><br><span class="line">    irBuilder.getCurFunction().addBasicBlock(bodyBlock);</span><br><span class="line">    irBuilder.getCurFunction().addBasicBlock(endBlock);</span><br><span class="line">    <span class="comment">// 在栈上分配 i 和 res 的空间，生成指针</span></span><br><span class="line">    <span class="type">IrAlloca</span> <span class="variable">resPtr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IrAlloca</span>(IrBaseType.I32);</span><br><span class="line">    <span class="type">IrAlloca</span> <span class="variable">iPtr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IrAlloca</span>(IrBaseType.I32);</span><br><span class="line">    irBuilder.addInstruction(resPtr);</span><br><span class="line">    irBuilder.addInstruction(iPtr);</span><br><span class="line">    <span class="comment">// 初始化 i=0，res=1</span></span><br><span class="line">    irBuilder.addInstruction(<span class="keyword">new</span> <span class="title class_">IrStore</span>(<span class="keyword">new</span> <span class="title class_">IrConstInt</span>(<span class="number">1</span>), resPtr));</span><br><span class="line">    irBuilder.addInstruction(<span class="keyword">new</span> <span class="title class_">IrStore</span>(<span class="keyword">new</span> <span class="title class_">IrConstInt</span>(<span class="number">0</span>), iPtr));</span><br><span class="line">    <span class="keyword">if</span> (!irBuilder.getCurBlock().hasTerminator()) &#123;</span><br><span class="line">        irBuilder.addInstruction(<span class="keyword">new</span> <span class="title class_">IrJump</span>(condBlock));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// i &lt; b 时，继续迭乘，反之退出</span></span><br><span class="line">    irBuilder.setCurBlock(condBlock);</span><br><span class="line">    <span class="type">IrLoad</span> <span class="variable">iLoad</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IrLoad</span>(iPtr);</span><br><span class="line">    irBuilder.addInstruction(iLoad);</span><br><span class="line">    <span class="type">IrBinaryOp</span> <span class="variable">icmp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IrBinaryOp</span>(IrBinaryOp.Op.ICMP_SLT, iLoad, b);</span><br><span class="line">    irBuilder.addInstruction(icmp);</span><br><span class="line">    irBuilder.addInstruction(<span class="keyword">new</span> <span class="title class_">IrBranch</span>(icmp, bodyBlock, endBlock));</span><br><span class="line">    <span class="comment">// 取出 res 旧值，和 (a+b) 相乘，结果存回 res 的地址</span></span><br><span class="line">    irBuilder.setCurBlock(bodyBlock);</span><br><span class="line">    <span class="type">IrLoad</span> <span class="variable">resLoad</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IrLoad</span>(resPtr);</span><br><span class="line">    irBuilder.addInstruction(resLoad);</span><br><span class="line">    <span class="type">IrBinaryOp</span> <span class="variable">mul</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IrBinaryOp</span>(IrBinaryOp.Op.MUL, resLoad, add);</span><br><span class="line">    irBuilder.addInstruction(mul);</span><br><span class="line">    irBuilder.addInstruction(<span class="keyword">new</span> <span class="title class_">IrStore</span>(mul, resPtr));</span><br><span class="line">    <span class="comment">// 取出 i 旧值，执行 i+1，结果存回 i 的地址</span></span><br><span class="line">    <span class="type">IrLoad</span> <span class="variable">iLoad1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IrLoad</span>(iPtr);</span><br><span class="line">    irBuilder.addInstruction(iLoad1);</span><br><span class="line">    <span class="type">IrBinaryOp</span> <span class="variable">addi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IrBinaryOp</span>(IrBinaryOp.Op.ADD, iLoad1, <span class="keyword">new</span> <span class="title class_">IrConstInt</span>(<span class="number">1</span>));</span><br><span class="line">    irBuilder.addInstruction(addi);</span><br><span class="line">    irBuilder.addInstruction(<span class="keyword">new</span> <span class="title class_">IrStore</span>(addi, iPtr));</span><br><span class="line">    irBuilder.addInstruction(<span class="keyword">new</span> <span class="title class_">IrJump</span>(condBlock));</span><br><span class="line">    <span class="comment">// 取出 res 最后的值，作为计算结果返回</span></span><br><span class="line">    irBuilder.setCurBlock(endBlock);</span><br><span class="line">    <span class="type">IrLoad</span> <span class="variable">finalRes</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IrLoad</span>(resPtr);</span><br><span class="line">    irBuilder.addInstruction(finalRes);</span><br><span class="line">    <span class="keyword">return</span> finalRes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-g-if-elif-else"><strong>8.G if-elif-else</strong></h3>
<p><strong>题目要求</strong></p>
<p>文法说明：在<code>if-else</code>中添加<code>if-elif...-else</code>，本例前面词法和语法期中考过，重点是对<code>llvm</code>的修改，需要用数组存<code>cond</code>和<code>stmt</code>链，维护前后跳转关系</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">_calcIfStmt</span><span class="params">(AstNode stmt)</span> &#123;</span><br><span class="line">    <span class="comment">/* if ( Cond ) Stmt elif ( Cond ) Stmt else Stmt */</span></span><br><span class="line">    List&lt;AstNode&gt; conds = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;AstNode&gt; stmts = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (AstNode child : stmt.getChilds()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (child.getType() == SyntaxType.CondExp) &#123;</span><br><span class="line">            conds.add(child);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (child.getType() == SyntaxType.Stmt) &#123;</span><br><span class="line">            stmts.add(child);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;IrBasicBlock&gt; condBlocks = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;IrBasicBlock&gt; stmtBlocks = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; stmts.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; conds.size()) &#123;</span><br><span class="line">            <span class="type">IrBasicBlock</span> <span class="variable">condBlock</span> <span class="operator">=</span> irBuilder.createBasicBlock(<span class="string">&quot;cond_&quot;</span> + i);</span><br><span class="line">            condBlocks.add(condBlock);</span><br><span class="line">            irBuilder.getCurFunction().addBasicBlock(condBlock);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">IrBasicBlock</span> <span class="variable">stmtBlock</span> <span class="operator">=</span> irBuilder.createBasicBlock(<span class="string">&quot;stmt&quot;</span> + i);</span><br><span class="line">        stmtBlocks.add(stmtBlock);</span><br><span class="line">        irBuilder.getCurFunction().addBasicBlock(stmtBlock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">hasElse</span> <span class="operator">=</span> condBlocks.size() &gt; stmtBlocks.size();</span><br><span class="line">    <span class="type">IrBasicBlock</span> <span class="variable">endBlock</span> <span class="operator">=</span> irBuilder.createBasicBlock(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">    irBuilder.getCurFunction().addBasicBlock(endBlock);</span><br><span class="line">    <span class="keyword">if</span> (!irBuilder.getCurBlock().hasTerminator()) &#123;</span><br><span class="line">        irBuilder.addInstruction(<span class="keyword">new</span> <span class="title class_">IrJump</span>(condBlocks.get(<span class="number">0</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; condBlocks.size(); i++) &#123;</span><br><span class="line">        irBuilder.setCurBlock(condBlocks.get(i));</span><br><span class="line">        <span class="type">IrValue</span> <span class="variable">condValue</span> <span class="operator">=</span> calcCond(conds.get(i));</span><br><span class="line">        condValue = Trunc(condValue);</span><br><span class="line">        <span class="type">IrBasicBlock</span> <span class="variable">trueBlock</span> <span class="operator">=</span> stmtBlocks.get(i);</span><br><span class="line">        <span class="type">IrBasicBlock</span> <span class="variable">falseBlock</span> <span class="operator">=</span> i + <span class="number">1</span> &lt; condBlocks.size() ? condBlocks.get(i + <span class="number">1</span>) :</span><br><span class="line">        hasElse ? stmtBlocks.get(i + <span class="number">1</span>) : endBlock;</span><br><span class="line">        <span class="keyword">if</span> (!irBuilder.getCurBlock().hasTerminator()) &#123;</span><br><span class="line">            irBuilder.addInstruction(<span class="keyword">new</span> <span class="title class_">IrBranch</span>(condValue, trueBlock, falseBlock));</span><br><span class="line">        &#125;</span><br><span class="line">        irBuilder.setCurBlock(stmtBlocks.get(i));</span><br><span class="line">        calcStmt(stmts.get(i));</span><br><span class="line">        <span class="keyword">if</span> (!irBuilder.getCurBlock().hasTerminator()) &#123;</span><br><span class="line">            irBuilder.addInstruction(<span class="keyword">new</span> <span class="title class_">IrJump</span>(endBlock));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hasElse) &#123;</span><br><span class="line">        irBuilder.setCurBlock(stmtBlocks.get(stmtBlocks.size() - <span class="number">1</span>));</span><br><span class="line">        calcStmt(stmts.get(stmts.size() - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span> (!irBuilder.getCurBlock().hasTerminator()) &#123;</span><br><span class="line">            irBuilder.addInstruction(<span class="keyword">new</span> <span class="title class_">IrJump</span>(endBlock));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    irBuilder.setCurBlock(endBlock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="优化简答"><strong>优化简答</strong></h2>
<h4 id="9-1-cfg-控制流图-构建"><strong>9.1 CFG（控制流图）构建</strong></h4>
<p><strong>原理</strong>：把程序的基本块当节点，跳转当边<br>
<strong>作用</strong>：本身不直接省指令，但<strong>所有控制流/数据流优化都依赖它</strong>（比如 DCE、循环优化、支配树、活跃分析、CSE 的可达性判断）</p>
<p><strong>能发现什么</strong>：</p>
<ul>
<li>哪些块不可达</li>
<li>哪些边是回边（循环）</li>
<li>一个块的前驱/后继是谁</li>
</ul>
<p>简答里写法：</p>
<blockquote>
<p>“构建 CFG 后才能做不可达删除、分支化简、循环识别等”</p>
</blockquote>
<h4 id="9-2-分支优化-branch-simplify"><strong>9.2 分支优化（Branch Simplify）</strong></h4>
<p><strong>原理</strong>：把“条件恒真/恒假”的分支改成直接跳转；把 <code>if</code> 的空分支删掉；把 <code>br</code> 的目标修剪<br>
<strong>优化对象</strong>：条件来自常量传播/比较恒定的代码</p>
<p><strong>例子</strong><br>
优化前：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="number">1</span>) x=<span class="number">3</span>; <span class="keyword">else</span> x=<span class="number">4</span>;</span><br></pre></td></tr></table></figure>
<p>IR/CFG 形态：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">br i1 <span class="literal">true</span>, then, <span class="keyword">else</span></span><br><span class="line">then: x=<span class="number">3</span>; br end</span><br><span class="line"><span class="keyword">else</span>: x=<span class="number">4</span>; br end</span><br></pre></td></tr></table></figure>
<p>优化后：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>效果：少一个分支，少两个块。</p>
<h4 id="9-3-基本块合并-block-merge"><strong>9.3 基本块合并（Block Merge）</strong></h4>
<p><strong>原理</strong>：如果 A 块无条件跳到 B，且 B 只有 A 一个前驱，那么 A 和 B 可以合并<br>
<strong>优化对象</strong>：优化后产生的空跳转块/中转块</p>
<p><strong>例子</strong><br>
优化前：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A: ...; j B</span><br><span class="line">B: ...; j C</span><br></pre></td></tr></table></figure>
<p>优化后：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A: ...; ...; j C</span><br></pre></td></tr></table></figure>
<p>效果：减少一次跳转、减少块数，提高后端局部优化机会。</p>
<h4 id="9-3-函数内联-inlining"><strong>9.3 函数内联（Inlining）</strong></h4>
<p><strong>原理</strong>：把小函数的函数体复制到调用点，替代 <code>call</code><br>
<strong>优化对象</strong>：短小频繁调用、参数常量可触发后续常量传播的函数</p>
<p><strong>例子</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add1</span><span class="params">(<span class="type">int</span> x)</span></span>&#123; <span class="keyword">return</span> x<span class="number">+1</span>; &#125;</span><br><span class="line">y = <span class="built_in">add1</span>(a);</span><br></pre></td></tr></table></figure>
<p>优化前：有 <code>call add1</code> + 保存现场/传参/返回值开销<br>
优化后：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y = a + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>收益：</p>
<ul>
<li>少 call/ret</li>
<li>让后续 CSE、常量传播更强（尤其参数是常量）</li>
</ul>
<p>风险点（简答可提一句）：</p>
<blockquote>
<p>内联会增大代码体积，通常对小函数/热路径做</p>
</blockquote>
<h4 id="常量函数编译期计算-compile-time-evaluation-constfold-call"><strong>常量函数编译期计算（Compile-time evaluation / ConstFold Call）</strong></h4>
<p><strong>原理</strong>：如果函数是“纯函数/可推断无副作用”，且实参都是常量，就在编译期直接算出返回值，替换调用<br>
<strong>优化对象</strong>：数学函数、小工具函数、递归（若你做了）等</p>
<p><strong>例子</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x)</span></span>&#123; <span class="keyword">return</span> x*x<span class="number">+3</span>; &#125;</span><br><span class="line"><span class="type">int</span> y = <span class="built_in">f</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<p>优化后：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> y = <span class="number">28</span>;</span><br></pre></td></tr></table></figure>
<p>效果：调用消失，后面还能继续传播常量。</p>
<h4 id="9-4-循环优化-loop-optimizations"><strong>9.4 循环优化（Loop Optimizations）</strong></h4>
<p>你说循环优化通常包含：<strong>循环不变式外提（LICM）/循环简化/强度削弱/归纳变量优化/消除多余判断</strong>等</p>
<p><strong>9.4.1 循环不变式外提（LICM）</strong></p>
<p><strong>原理</strong>：循环里不随迭代变化的表达式移到循环外算一次<br>
<strong>例子</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) s += a*b;</span><br></pre></td></tr></table></figure>
<p><code>a*b</code> 不变：优化后</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t = a*b;</span><br><span class="line"><span class="keyword">for</span>(...) s += t;</span><br></pre></td></tr></table></figure>
<p>效果：少 (n-1) 次乘法</p>
<p><strong>9.4.2 循环归纳变量简化</strong></p>
<p><strong>原理</strong>：把每轮重复计算的 <code>i*4</code> 变成累加指针。<br>
<strong>例子</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++) sum += A[i];</span><br></pre></td></tr></table></figure>
<p>优化后低层形态：用指针 <code>p</code> 每轮 <code>p += 4</code>，减少乘法/地址计算。</p>
<h4 id="9-5-mem2reg-内存提升到-ssa"><strong>9.5 Mem2Reg（内存提升到 SSA）</strong></h4>
<p><strong>原理</strong>：把“局部变量栈槽（alloca）”的 load/store 转成 SSA 值 + phi<br>
<strong>优化对象</strong>：局部标量变量（地址不逃逸、只被 load/store 访问）</p>
<p><strong>例子</strong><br>
优化前（内存化）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">%x = alloca i32</span><br><span class="line">store <span class="number">0</span>, %x</span><br><span class="line">...</span><br><span class="line">t = load %x</span><br><span class="line">t2 = add t, <span class="number">1</span></span><br><span class="line">store t2, %x</span><br><span class="line">...</span><br><span class="line">ret load %x</span><br></pre></td></tr></table></figure>
<p>优化后（SSA）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">; x0 = <span class="number">0</span></span><br><span class="line">; x1 = x0<span class="number">+1</span></span><br><span class="line">ret x1</span><br></pre></td></tr></table></figure>
<p>效果：大量 <code>lw/sw</code> 消失，后端性能暴增；也为 CSE/常量传播铺路</p>
<h4 id="9-6-死代码删除-dce"><strong>9.6 死代码删除（DCE）</strong></h4>
<p><strong>原理</strong>：删掉“结果永远不会被用到”的指令，前提是它<strong>没有副作用</strong><br>
<strong>优化对象</strong>：临时变量、冗余计算、不可达块、无用 store（部分情况下）</p>
<p><strong>例子</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = a+b;</span><br><span class="line"><span class="type">int</span> y = x*<span class="number">2</span>;</span><br><span class="line"><span class="keyword">return</span> a;</span><br></pre></td></tr></table></figure>
<p><code>x,y</code> 都无用：优化后</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> a;</span><br></pre></td></tr></table></figure>
<p>注意简答里常考：</p>
<blockquote>
<p>有副作用的不能删（I/O、volatile、可能写全局的 call）</p>
</blockquote>
<h4 id="9-7-公共子表达式消除-cse"><strong>9.7 公共子表达式消除（CSE）</strong></h4>
<p><strong>9.7.1 局部 CSE（LVN）</strong></p>
<p><strong>原理</strong>：在一个基本块内，相同表达式且操作数相同，第二次直接复用第一次结果。<br>
<strong>例子</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t1 = a*b;</span><br><span class="line">t2 = a*b;   <span class="comment">// 重复</span></span><br></pre></td></tr></table></figure>
<p>优化后：<code>t2 = t1</code></p>
<p><strong>9.7.2 全局 CSE（GVN）</strong></p>
<p><strong>原理</strong>：跨基本块复用，需要支配关系保证第一次计算一定发生且中间不被改<br>
<strong>例子</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(c)&#123; t=a*b; &#125;</span><br><span class="line">... </span><br><span class="line">u=a*b;  <span class="comment">// 若 t 所在块支配这里且 a,b 未被改</span></span><br></pre></td></tr></table></figure>
<p>优化后：<code>u = t</code></p>
<h3 id="9-8-常量传播-constant-propagation"><strong>9.8 常量传播（Constant Propagation）</strong></h3>
<p><strong>原理</strong>：把已知常量替换到使用点，进一步触发分支化简、DCE、强度削弱<br>
<strong>例子</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> y = x + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">if</span> (y &gt; <span class="number">10</span>) ...</span><br></pre></td></tr></table></figure>
<p>传播后：</p>
<ul>
<li><code>y = 8</code></li>
<li><code>if (false)</code> → 分支删除</li>
</ul>
<h4 id="9-9-常量合并-constant-merge-pooling"><strong>9.9 常量合并（Constant Merge / Pooling）</strong></h4>
<p><strong>原理</strong>：相同常量（尤其字符串/全局常量数组）只保留一份，多个引用共享<br>
<strong>例子</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hi&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>数据段只保留一个 <code>&quot;hi\0&quot;</code>，两处都指向同一地址<br>
效果：减小 .data，减小代码生成时重复加载地址的机会</p>
<h4 id="9-a-代数强度削弱-strength-reduction"><strong>9.A 代数强度削弱（Strength Reduction）</strong></h4>
<p><strong>原理</strong>：用更便宜的指令替代昂贵运算（mul/div/mod）<br>
<strong>经典例子</strong>：</p>
<ul>
<li><code>x * 2^k</code> → <code>x &lt;&lt; k</code></li>
<li><code>x / 2^k</code> → 算术右移（注意负数语义，C 里要谨慎）</li>
<li><code>x % 2^k</code> → <code>x &amp; (2^k-1)</code>（仅对非负/或按补码语义需谨慎）</li>
</ul>
<p>例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y = x * <span class="number">8</span>;</span><br></pre></td></tr></table></figure>
<p>优化后：<code>y = x &lt;&lt; 3</code></p>
<p>再比如你常见的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x % <span class="number">2</span> == <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>优化后：<code>if ((x &amp; 1) == 0)</code>（你之前也提过）</p>
<p><strong>9.B 后端：启发式图着色 + 寄存器分配</strong></p>
<p><strong>原理</strong>：把 SSA 值/临时看作图的节点，若两个值在某点同时活跃就连边（冲突）；图着色把节点映射到有限寄存器。<br>
<strong>优化对象</strong>：减少栈上的 spill，减少 <code>lw/sw</code>。</p>
<p><strong>例子（非常直观）</strong><br>
优化前（全落栈）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lw t0, <span class="built_in">x</span>($fp)</span><br><span class="line">lw t1, <span class="built_in">y</span>($fp)</span><br><span class="line">addu t2, t0, t1</span><br><span class="line">sw  t2, <span class="built_in">tmp</span>($fp)</span><br><span class="line">lw  t3, <span class="built_in">tmp</span>($fp)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>优化后（寄存器承载）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">addu $t2, $t0, $t1   <span class="meta"># x,y,t2 都在寄存器里</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>简答写法：</p>
<blockquote>
<p>“寄存器分配把热点变量放在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi mathvariant="normal">/</mi></mrow><annotation encoding="application/x-tex">t/</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mord">/</span></span></span></span>s，减少 memory 指令，提升性能。”</p>
</blockquote>
<p>也可以提一句 ABI：</p>
<ul>
<li><code>$s</code> 是 callee-save：函数用到就要保存恢复</li>
<li><code>$t</code> 是 caller-save：跨 call 需要保存活跃值</li>
</ul>
<h4 id="9-c-窥孔优化-peephole"><strong>9.C 窥孔优化（Peephole）</strong></h4>
<p><strong>原理</strong>：在很短的指令窗口里做局部等价替换/删除冗余<br>
<strong>优化对象</strong>：后端生成的“机械重复模式”</p>
<p>常见例子：</p>
<ol>
<li>删除 <code>move r,r</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">move $t0, $t0   ; 删</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>紧邻的 store/load 抵消</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sw $t0, <span class="built_in">off</span>($fp)</span><br><span class="line">lw $t0, <span class="built_in">off</span>($fp)  ; 删后一句（若中间无改写/无别名）</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>冗余加载消除</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lw $t0, <span class="built_in">off</span>($fp)</span><br><span class="line">... (中间无 store 到 off)</span><br><span class="line">lw $t0, <span class="built_in">off</span>($fp)  ; 第二个删</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>跳到下一块的 <code>j next</code> 删除（块顺序相邻）</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">j L2</span><br><span class="line">L2: ...</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images/picture.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images/picture.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">Destiny</div><div class="post-copyright__author_desc">跋涉浮尘烛光灭</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://agilawood4.github.io/2026/01/17/%E4%B8%8A%E6%9C%BA%E9%A2%98%E7%9B%AE/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://agilawood4.github.io/2026/01/17/%E4%B8%8A%E6%9C%BA%E9%A2%98%E7%9B%AE/')">Destiny's Blog</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://agilawood4.github.io/2026/01/17/%E4%B8%8A%E6%9C%BA%E9%A2%98%E7%9B%AE/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=Destiny's Blog&amp;url=https://agilawood4.github.io/2026/01/17/%E4%B8%8A%E6%9C%BA%E9%A2%98%E7%9B%AE/&amp;pic=" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://agilawood4.github.io" target="_blank">Destiny's Blog</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"></div></div></div><div class="post_share"><div class="social-share" data-image="/../images/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A297.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2026/01/17/(SQL1)%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%AE%BA/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2122.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">数据库概论</div></div></a></div><div class="next-post pull-right"><a href="/2026/01/17/%E5%A5%87%E5%A6%99%E6%95%85%E4%BA%8B0/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A22.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">你好 世界</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/images/picture.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description"></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://bu.dusays.com/2023/05/13/645fa415e8694.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#llvm-%E6%96%87%E6%B3%95%E8%A7%84%E5%88%99"><span class="toc-number">1.</span> <span class="toc-text">llvm 文法规则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-llvm-ir-%E6%96%87%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.</span> <span class="toc-text">5.1 LLVM IR 文件的基本结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.2.</span> <span class="toc-text">5.2 指令系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-1-alloca-%E6%A0%88%E4%B8%8A%E5%88%86%E9%85%8D%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">1.2.1.</span> <span class="toc-text">5.2.1 Alloca（栈上分配局部变量）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5-2-load-%E4%BB%8E%E5%86%85%E5%AD%98%E8%AF%BB"><span class="toc-number">1.2.2.</span> <span class="toc-text">5.5.2 Load（从内存读）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-3-store-%E5%86%99%E5%85%A5%E5%86%85%E5%AD%98"><span class="toc-number">1.2.3.</span> <span class="toc-text">5.2.3 Store（写入内存）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-4-gep-%E5%9C%B0%E5%9D%80%E5%81%8F%E7%A7%BB%E8%AE%A1%E7%AE%97"><span class="toc-number">1.2.4.</span> <span class="toc-text">5.2.4 GEP（地址偏移计算）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-5-phi-ssa-%E5%90%88%E6%B5%81%EF%BC%9A%E6%9D%A5%E8%87%AA%E4%B8%8D%E5%90%8C%E5%89%8D%E9%A9%B1%E5%9D%97%E5%8F%96%E4%B8%8D%E5%90%8C%E5%80%BC"><span class="toc-number">1.2.5.</span> <span class="toc-text">5.2.5 Phi（SSA 合流：来自不同前驱块取不同值）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-6-zext-trunc-%E6%95%B4%E6%95%B0%E4%BD%8D%E5%AE%BD%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.2.6.</span> <span class="toc-text">5.2.6 Zext &#x2F; Trunc（整数位宽转换）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-7-cmp-%E6%AF%94%E8%BE%83%EF%BC%9Aicmp"><span class="toc-number">1.2.7.</span> <span class="toc-text">5.2.7 Cmp（比较：icmp）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-8-branch-jump-%E6%8E%A7%E5%88%B6%E6%B5%81%E8%B7%B3%E8%BD%AC"><span class="toc-number">1.2.8.</span> <span class="toc-text">5.2.8 Branch &#x2F; Jump（控制流跳转）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-9-%E4%BA%8C%E5%85%83%E8%BF%90%E7%AE%97%E6%8C%87%E4%BB%A4-add-sub-mul-div-rem-and-or-xor-shl"><span class="toc-number">1.2.9.</span> <span class="toc-text">5.2.9 二元运算指令（Add&#x2F;Sub&#x2F;Mul&#x2F;Div&#x2F;Rem&#x2F;And&#x2F;Or&#x2F;Xor&#x2F;Shl&#x2F;…）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-llvm-%E6%8E%A7%E5%88%B6%E6%B5%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.</span> <span class="toc-text">5.3 LLVM 控制流实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-1-if-cond-a-else-b"><span class="toc-number">1.3.1.</span> <span class="toc-text">5.3.1 if (cond) A else B</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-2-while-cond-body"><span class="toc-number">1.3.2.</span> <span class="toc-text">5.3.2 while (cond) { body }</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-3-for-init-cond-step-body"><span class="toc-number">1.3.3.</span> <span class="toc-text">5.3.3 for (init; cond; step) { body }</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#llvm-%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF"><span class="toc-number">2.</span> <span class="toc-text">llvm 实现思路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E5%8F%98%E9%87%8F%E7%AC%A6%E5%8F%B7%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.1.</span> <span class="toc-text">6.1 变量符号介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E8%8A%82%E7%82%B9%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.2.</span> <span class="toc-text">6.2 中间代码节点实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-1-%E5%87%BD%E6%95%B0%E5%86%85%E5%BB%BA%E5%92%8C%E9%A2%84%E5%A3%B0%E6%98%8E"><span class="toc-number">2.2.1.</span> <span class="toc-text">6.2.1 函数内建和预声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-2-%E5%9F%BA%E6%9C%AC%E5%9D%97"><span class="toc-number">2.2.2.</span> <span class="toc-text">6.2.2 基本块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-3-%E6%8C%87%E4%BB%A4%E6%8F%92%E5%85%A5"><span class="toc-number">2.2.3.</span> <span class="toc-text">6.2.3 指令插入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-4-%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89"><span class="toc-number">2.2.4.</span> <span class="toc-text">6.2.4 函数定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-5-%E8%AF%AD%E5%8F%A5%E5%9D%97-%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%88%87%E6%8D%A2"><span class="toc-number">2.2.5.</span> <span class="toc-text">6.2.5 语句块 &#x2F; 作用域切换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-6-%E8%AF%AD%E5%8F%A5-stmt-%E8%A7%A3%E6%9E%90"><span class="toc-number">2.2.6.</span> <span class="toc-text">6.2.6 语句 Stmt 解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-7-%E5%B8%B8%E5%8F%98%E9%87%8F%E8%A7%A3%E6%9E%90"><span class="toc-number">2.2.7.</span> <span class="toc-text">6.2.7 常变量解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-8-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%80%BC-%E5%88%97%E8%A1%A8%E8%A7%A3%E6%9E%90"><span class="toc-number">2.2.8.</span> <span class="toc-text">6.2.8 初始化值 &#x2F; 列表解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-9-%E5%B7%A6%E5%80%BC-lval-%E7%9A%84%E4%B8%A4%E7%A7%8D%E8%A7%A3%E6%9E%90"><span class="toc-number">2.2.9.</span> <span class="toc-text">6.2.9 左值 LVal 的两种解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-a-%E7%9F%AD%E8%B7%AF%E6%B1%82%E5%80%BC"><span class="toc-number">2.2.10.</span> <span class="toc-text">6.2.A 短路求值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-b-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E9%93%BE"><span class="toc-number">2.2.11.</span> <span class="toc-text">6.2.B 表达式链</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E8%A1%A8-%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90%E6%89%A9%E5%B1%95"><span class="toc-number">3.</span> <span class="toc-text">符号表 &amp; 语义分析扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-stmt-%E5%88%86%E5%8F%91"><span class="toc-number">3.1.</span> <span class="toc-text">7.1 Stmt 分发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-stmt-%E5%A4%84%E7%90%86"><span class="toc-number">3.2.</span> <span class="toc-text">7.2 Stmt 处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-exp-%E5%A4%84%E7%90%86"><span class="toc-number">3.3.</span> <span class="toc-text">7.3 Exp 处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8A%E6%9C%BA%E9%A2%98%E7%9B%AE"><span class="toc-number">4.</span> <span class="toc-text">上机题目</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-for-decl"><span class="toc-number">4.1.</span> <span class="toc-text">8.1 for + decl</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-while-decl"><span class="toc-number">4.2.</span> <span class="toc-text">8.2 while + decl</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-powexp"><span class="toc-number">4.3.</span> <span class="toc-text">8.3 PowExp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-%E6%96%B0%E5%A2%9E%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0"><span class="toc-number">4.4.</span> <span class="toc-text">8.4 新增内建函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-%E6%96%B0%E5%BB%BA%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0"><span class="toc-number">4.5.</span> <span class="toc-text">8.5 新建内建函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-6-%E5%90%8E%E7%BC%80-%E5%9B%B0%E9%9A%BE"><span class="toc-number">4.6.</span> <span class="toc-text">8.6 后缀++（困难）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-7-shiftexp"><span class="toc-number">4.7.</span> <span class="toc-text">8.7 ShiftExp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-8-ternarystmt"><span class="toc-number">4.8.</span> <span class="toc-text">8.8 TernaryStmt</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-9-repeat-cond"><span class="toc-number">4.9.</span> <span class="toc-text">8.9 repeat-cond</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-a-ternaryexp"><span class="toc-number">4.10.</span> <span class="toc-text">8.A TernaryExp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-b-switch-case"><span class="toc-number">4.11.</span> <span class="toc-text">8.B switch-case</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-c-match-case"><span class="toc-number">4.12.</span> <span class="toc-text">8.C match-case</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-d-%E5%90%8E%E7%BC%80"><span class="toc-number">4.13.</span> <span class="toc-text">8.D 后缀++</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-e-forstmt-btype-vardef"><span class="toc-number">4.14.</span> <span class="toc-text">8.E ForStmt → BType VarDef</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-f-a-b-b"><span class="toc-number">4.15.</span> <span class="toc-text">8.F (a+b)^b</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-g-if-elif-else"><span class="toc-number">4.16.</span> <span class="toc-text">8.G if-elif-else</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E7%AE%80%E7%AD%94"><span class="toc-number">5.</span> <span class="toc-text">优化简答</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-cfg-%E6%8E%A7%E5%88%B6%E6%B5%81%E5%9B%BE-%E6%9E%84%E5%BB%BA"><span class="toc-number">5.0.1.</span> <span class="toc-text">9.1 CFG（控制流图）构建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-%E5%88%86%E6%94%AF%E4%BC%98%E5%8C%96-branch-simplify"><span class="toc-number">5.0.2.</span> <span class="toc-text">9.2 分支优化（Branch Simplify）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-%E5%9F%BA%E6%9C%AC%E5%9D%97%E5%90%88%E5%B9%B6-block-merge"><span class="toc-number">5.0.3.</span> <span class="toc-text">9.3 基本块合并（Block Merge）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-%E5%87%BD%E6%95%B0%E5%86%85%E8%81%94-inlining"><span class="toc-number">5.0.4.</span> <span class="toc-text">9.3 函数内联（Inlining）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E5%87%BD%E6%95%B0%E7%BC%96%E8%AF%91%E6%9C%9F%E8%AE%A1%E7%AE%97-compile-time-evaluation-constfold-call"><span class="toc-number">5.0.5.</span> <span class="toc-text">常量函数编译期计算（Compile-time evaluation &#x2F; ConstFold Call）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-4-%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96-loop-optimizations"><span class="toc-number">5.0.6.</span> <span class="toc-text">9.4 循环优化（Loop Optimizations）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-5-mem2reg-%E5%86%85%E5%AD%98%E6%8F%90%E5%8D%87%E5%88%B0-ssa"><span class="toc-number">5.0.7.</span> <span class="toc-text">9.5 Mem2Reg（内存提升到 SSA）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-6-%E6%AD%BB%E4%BB%A3%E7%A0%81%E5%88%A0%E9%99%A4-dce"><span class="toc-number">5.0.8.</span> <span class="toc-text">9.6 死代码删除（DCE）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-7-%E5%85%AC%E5%85%B1%E5%AD%90%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B6%88%E9%99%A4-cse"><span class="toc-number">5.0.9.</span> <span class="toc-text">9.7 公共子表达式消除（CSE）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-8-%E5%B8%B8%E9%87%8F%E4%BC%A0%E6%92%AD-constant-propagation"><span class="toc-number">5.1.</span> <span class="toc-text">9.8 常量传播（Constant Propagation）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-9-%E5%B8%B8%E9%87%8F%E5%90%88%E5%B9%B6-constant-merge-pooling"><span class="toc-number">5.1.1.</span> <span class="toc-text">9.9 常量合并（Constant Merge &#x2F; Pooling）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-a-%E4%BB%A3%E6%95%B0%E5%BC%BA%E5%BA%A6%E5%89%8A%E5%BC%B1-strength-reduction"><span class="toc-number">5.1.2.</span> <span class="toc-text">9.A 代数强度削弱（Strength Reduction）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-c-%E7%AA%A5%E5%AD%94%E4%BC%98%E5%8C%96-peephole"><span class="toc-number">5.1.3.</span> <span class="toc-text">9.C 窥孔优化（Peephole）</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2026/01/17/%EF%BC%88%E7%BC%96%E8%AF%91%EF%BC%89%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%84%E7%BB%87%E5%8F%8A%E7%AE%A1%E7%90%86/" title="运行时的存储组织及管理"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A297.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="运行时的存储组织及管理"/></a><div class="content"><a class="title" href="/2026/01/17/%EF%BC%88%E7%BC%96%E8%AF%91%EF%BC%89%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%84%E7%BB%87%E5%8F%8A%E7%AE%A1%E7%90%86/" title="运行时的存储组织及管理">运行时的存储组织及管理</a><time datetime="2026-01-17T07:28:15.283Z" title="发表于 2026-01-17 15:28:15">2026-01-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2026/01/17/%EF%BC%88%E7%AE%97%E6%B3%95%EF%BC%89%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B/" title="算法设计与分析"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A2120.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="算法设计与分析"/></a><div class="content"><a class="title" href="/2026/01/17/%EF%BC%88%E7%AE%97%E6%B3%95%EF%BC%89%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B/" title="算法设计与分析">算法设计与分析</a><time datetime="2026-01-17T07:28:15.259Z" title="发表于 2026-01-17 15:28:15">2026-01-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/01/17/%EF%BC%88%E7%AE%97%E6%B3%95%EF%BC%89NP%E9%97%AE%E9%A2%98/" title="无题">无题</a><time datetime="2026-01-17T07:28:15.257Z" title="发表于 2026-01-17 15:28:15">2026-01-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/01/17/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E8%A1%A5%E5%85%85/" title="无题">无题</a><time datetime="2026-01-17T07:28:15.216Z" title="发表于 2026-01-17 15:28:15">2026-01-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2026/01/17/%E8%A1%8C%E4%BA%BA%E9%87%8D%E8%AF%86%E5%88%AB%E5%AD%A6%E4%B9%A0/" title="ReID"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/../images/%E6%96%87%E7%AB%A0%E5%B0%81%E9%9D%A233.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ReID"/></a><div class="content"><a class="title" href="/2026/01/17/%E8%A1%8C%E4%BA%BA%E9%87%8D%E8%AF%86%E5%88%AB%E5%AD%A6%E4%B9%A0/" title="ReID">ReID</a><time datetime="2026-01-17T07:28:15.214Z" title="发表于 2026-01-17 15:28:15">2026-01-17</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2026 By <a class="footer-bar-link" href="/" title="Destiny" target="_blank">Destiny</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">113</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">4</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" rel="external nofollow noreferrer" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener external nofollow noreferrer" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener external nofollow noreferrer" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><span> 分类</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/tags/"><span> 标签</span></a></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/LLM%E4%B8%8E%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/" style="font-size: 0.88rem;">LLM与强化学习<sup>4</sup></a><a href="/tags/Python%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="font-size: 0.88rem;">Python与机器学习<sup>35</sup></a><a href="/tags/editing/" style="font-size: 0.88rem;">editing<sup>1</sup></a><a href="/tags/%E4%B8%93%E4%B8%9A%E8%AF%BE/" style="font-size: 0.88rem;">专业课<sup>33</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 0.88rem;">算法<sup>29</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.6.14",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 Destiny 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/fireworks.min.js"></script><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>